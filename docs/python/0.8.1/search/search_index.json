{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"writing_docs/","title":"Python Docs","text":"<p>A high-level overview of writing and previewing the Rerun python documentation.</p>"},{"location":"writing_docs/#getting-started-with-docs","title":"Getting started with docs","text":""},{"location":"writing_docs/#dependencies","title":"Dependencies","text":"<p>All of the dependencies for documentation generation are captured in the requirements file: <pre><code>pip install -r rerun_py/requirements-doc.txt\n</code></pre></p>"},{"location":"writing_docs/#serving-the-docs-locally","title":"Serving the docs locally","text":"<p>The docs can be previewed locally using <code>mkdocs</code></p> <p>This will watch the contents of the <code>rerun_py</code> folder and refresh documentation live as files are changed. <pre><code>mkdocs serve -f rerun_py/mkdocs.yml -w rerun_py\n</code></pre> or <pre><code>just py-docs-serve\n</code></pre></p>"},{"location":"writing_docs/#how-versioned-docs-are-generated-and-served","title":"How versioned docs are generated and served","text":"<p>Our documentation is versioned with releases and generated via mike</p> <p>The documentation exists as a GitHub Pages project which is hosted from the contents of the <code>gh-pages</code> branch.</p> <p><code>mike</code> updates this branch with new content as part of CI</p> <p>Every commit that lands to main will generate bleeding edge documentation as HEAD. Behind the scenes, a GitHub action is just running: <pre><code>mike deploy -F rerun_py/mkdocs.yml HEAD\n</code></pre></p> <p>On release, when GitHub sees a new tag: <code>X.Y.Z</code>, the GitHub action will instead deploy with a version tag: <pre><code>mike deploy -F rerun_py/mkdocs.yml X.Y.Z latest\n</code></pre></p> <p>You can also locally preview the publicly hosted site with all versions, using mike: <pre><code>mike serve -F rerun_py/mkdocs.yml\n</code></pre> though when locally developing docs you are better off using <code>mkdocs serve</code> as described above since it will handle hot-reloading for you as you edit.</p>"},{"location":"common/","title":"Getting Started","text":"<ul> <li>Quick start</li> <li>Tutorial</li> <li>Examples on GitHub</li> <li>Troubleshooting</li> </ul> <p>There are many different ways of sending data to the Rerun Viewer depending on what you're trying to achieve and whether the viewer is running in the same process as your code, in another process, or even as a separate web application.</p> <p>Checkout SDK Operating Modes for an overview of what's possible and how.</p>"},{"location":"common/#apis","title":"APIs","text":""},{"location":"common/#initialization","title":"Initialization","text":"Function Description <code>rerun.init()</code> Initialize the Rerun SDK with a user-chosen application id (name). <code>rerun.connect()</code> Connect to a remote Rerun Viewer on the given ip:port. <code>rerun.disconnect()</code> Closes all TCP connections, servers, and files. <code>rerun.spawn()</code> Spawn a Rerun Viewer, listening on the given port. <code>rerun.serve()</code> Serve log-data over WebSockets and serve a Rerun web viewer over HTTP. <code>rerun.save()</code> Stream all log-data to a file. <code>rerun.memory_recording()</code> Streams all log-data to a memory buffer."},{"location":"common/#viewer-control","title":"Viewer Control","text":"Function Description <code>rerun.save()</code> Stream all log-data to a file."},{"location":"common/#time","title":"Time","text":"Function Description <code>rerun.set_time_sequence()</code> Set the current time for this thread as an integer sequence. <code>rerun.set_time_seconds()</code> Set the current time for this thread in seconds. <code>rerun.set_time_nanos()</code> Set the current time for this thread."},{"location":"common/#spatial-primitives","title":"Spatial Primitives","text":"Function Description <code>rerun.log_point()</code> Log a 2D or 3D point, with a position and optional color, radii, label, etc. <code>rerun.log_points()</code> Log 2D or 3D points, with positions and optional colors, radii, labels, etc. <code>rerun.log_rect()</code> Log a 2D rectangle. <code>rerun.log_rects()</code> Log multiple 2D rectangles. <code>rerun.log_obb()</code> Log a 3D Oriented Bounding Box, or OBB. <code>rerun.log_line_strip()</code> Log a line strip through 2D or 3D space. <code>rerun.log_line_segments()</code> Log many 2D or 3D line segments. <code>rerun.log_arrow()</code> Log a 3D arrow. <code>rerun.log_mesh()</code> Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor. <code>rerun.log_meshes()</code> Log multiple raw 3D meshes by specifying their different buffers and albedo factors. <code>rerun.log_mesh_file()</code> Log the contents of a mesh file (.gltf, .glb, .obj, \u2026)."},{"location":"common/#images","title":"Images","text":"Function Description <code>rerun.log_image()</code> Log a gray or color image. <code>rerun.log_image_file()</code> Log an image file given its contents or path on disk. <code>rerun.log_depth_image()</code> Log a depth image. <code>rerun.log_segmentation_image()</code> Log an image made up of integer class-ids."},{"location":"common/#tensors","title":"Tensors","text":"Function Description <code>rerun.log_tensor()</code> Log an n-dimensional tensor."},{"location":"common/#annotations","title":"Annotations","text":"Function Description <code>rerun.log_annotation_context()</code> Log an annotation context made up of a collection of ClassDescriptions. Class Description <code>rerun.ClassDescription</code> Metadata about a class type identified by an id. <code>rerun.AnnotationInfo</code> Annotation info annotating a class id or key-point id."},{"location":"common/#extension-components","title":"Extension Components","text":"Function Description <code>rerun.log_extension_components()</code> Log an arbitrary collection of extension components."},{"location":"common/#plotting","title":"Plotting","text":"Function Description <code>rerun.log_scalar()</code> Log a double-precision scalar that will be visualized as a timeseries plot."},{"location":"common/#transforms","title":"Transforms","text":"Function Description <code>rerun.log_transform3d()</code> Log an (affine) 3D transform between this entity and the parent. <code>rerun.log_pinhole()</code> Log a perspective camera model. <code>rerun.log_unknown_transform()</code> Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate. <code>rerun.log_disconnected_space()</code> Log that this entity is NOT in the same space as the parent. <code>rerun.log_view_coordinates()</code> Log the view coordinates for an entity."},{"location":"common/#text","title":"Text","text":"Function Description <code>rerun.log_text_entry()</code> Log a text entry, with optional level. Class Description <code>rerun.LogLevel</code> Represents the standard log levels. <code>rerun.LoggingHandler</code> Provides a logging handler that forwards all events to the Rerun SDK."},{"location":"common/#clearing-entities","title":"Clearing Entities","text":"Function Description <code>rerun.log_cleared()</code> Indicate that an entity at a given path should no longer be displayed."},{"location":"common/#helpers","title":"Helpers","text":"Function Description <code>rerun.script_add_args()</code> Add common Rerun script arguments to <code>parser</code>. <code>rerun.script_setup()</code> Run common Rerun script setup actions. Connect to the viewer if necessary. <code>rerun.script_teardown()</code> Run common post-actions. Sleep if serving the web viewer."},{"location":"common/#experimental","title":"Experimental","text":"Function Description <code>rerun.experimental.log_text_box()</code> Log a textbox. <code>rerun.experimental.new_blueprint()</code> Creates a new blueprint with a user-chosen application id (name) to configure the appearance of Rerun. <code>rerun.experimental.add_space_view()</code> Add a new space view to the blueprint. <code>rerun.experimental.set_panels()</code> Change the visibility of the view panels. <code>rerun.experimental.set_auto_space_views()</code> Change whether or not the blueprint automatically adds space views for all entities."},{"location":"common/#troubleshooting","title":"Troubleshooting","text":"<p>You can set <code>RUST_LOG=debug</code> before running your Python script and/or <code>rerun</code> process to get some verbose logging output.</p> <p>If you run into any issues don't hesitate to open a ticket or join our Discord.</p>"},{"location":"common/annotations/","title":"Annotations","text":""},{"location":"common/annotations/#rerun.log_annotation_context","title":"<code>def rerun.log_annotation_context(entity_path, class_descriptions, *, timeless=True, recording=None)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>ClassDescriptionLike | Iterable[ClassDescriptionLike]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/annotations/#rerun.ClassDescription","title":"<code>class rerun.ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"common/annotations/#rerun.log.annotation.ClassDescription.info","title":"<code>info: AnnotationInfoLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"common/annotations/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Iterable[AnnotationInfoLike] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"common/annotations/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Iterable[int | tuple[int, int]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"common/annotations/#rerun.AnnotationInfo","title":"<code>class rerun.AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"common/annotations/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"common/annotations/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"common/annotations/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Color | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"common/clearing_entities/","title":"Clearing Entities","text":""},{"location":"common/clearing_entities/#rerun.log_cleared","title":"<code>def rerun.log_cleared(entity_path, *, recursive=False, recording=None)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>recursive:     Should this apply to all entity paths below <code>entity_path</code>?</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"common/experimental/","title":"Experimental","text":"<p>Experimental features for Rerun.</p> <p>These features are not yet stable and may change in future releases without going through the normal deprecation cycle.</p>"},{"location":"common/experimental/#rerun.experimental.log_text_box","title":"<code>def rerun.experimental.log_text_box(entity_path, text, *, ext=None, timeless=False)</code>","text":"<p>Log a textbox.</p> <p>This is intended to be used for multi-line text entries to be displayed in their own view.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text-box should be timeless.</p> <code>False</code>"},{"location":"common/experimental/#rerun.experimental.new_blueprint","title":"<code>def rerun.experimental.new_blueprint(application_id, *, blueprint_id=None, make_default=False, make_thread_default=False, spawn=False, add_to_app_default_blueprint=False, default_enabled=True)</code>","text":"<p>Creates a new blueprint with a user-chosen application id (name) to configure the appearance of Rerun.</p> <p>If you only need a single global blueprint, <code>rerun.init</code> might be simpler.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>blueprint_id</code> <code>Optional[str]</code> <p>Set the blueprint ID that this process is logging to, as a UUIDv4.</p> <p>The default blueprint_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default blueprint_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same blueprint), you will need to manually assign them all the same blueprint_id. Any random UUIDv4 will work, or copy the blueprint_id for the parent process.</p> <code>None</code> <code>make_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the global scope.</p> <code>False</code> <code>make_thread_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the thread-local scope.</p> <code>False</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>add_to_app_default_blueprint</code> <code>bool</code> <p>Should the blueprint append to the existing app-default blueprint instead instead of creating a new one.</p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>RecordingStream</code> <p>A handle to the <code>rerun.RecordingStream</code>. Use it to log data to Rerun.</p>"},{"location":"common/experimental/#rerun.experimental.add_space_view","title":"<code>def rerun.experimental.add_space_view(*, origin, name, entity_paths, blueprint=None)</code>","text":"<p>Add a new space view to the blueprint.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>The EntityPath to use as the origin of this space view. All other entities will be transformed to be displayed relative to this origin.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the space view to show in the UI. Will default to the origin if not provided.</p> required <code>entity_paths</code> <code>Optional[List[str]]</code> <p>The entities to be shown in the space view. If not provided, this will default to [origin]</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"common/experimental/#rerun.experimental.set_panels","title":"<code>def rerun.experimental.set_panels(*, all_expanded=None, blueprint_view_expanded=None, selection_view_expanded=None, timeline_view_expanded=None, blueprint=None)</code>","text":"<p>Change the visibility of the view panels.</p> <p>Parameters:</p> Name Type Description Default <code>all_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse all panels.</p> <code>None</code> <code>blueprint_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the blueprint view panel.</p> <code>None</code> <code>selection_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the selection view panel.</p> <code>None</code> <code>timeline_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the timeline view panel.</p> <code>None</code> <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"common/experimental/#rerun.experimental.set_auto_space_views","title":"<code>def rerun.experimental.set_auto_space_views(enabled, blueprint=None)</code>","text":"<p>Change whether or not the blueprint automatically adds space views for all entities.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>Optional[bool]</code> <p>Whether or not to automatically add space views for all entities.</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"common/extension_components/","title":"Extension Components","text":""},{"location":"common/extension_components/#rerun.log_extension_components","title":"<code>def rerun.log_extension_components(entity_path, ext, *, identifiers=None, timeless=False, recording=None)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Sequence[int] | None</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/helpers/","title":"Helpers","text":"<p>Helper functions for Rerun scripts.</p> <p>These helper functions can be used to wire up common Rerun features to your script CLi arguments.</p>"},{"location":"common/helpers/#rerun.script_helpers--example","title":"Example","text":"<pre><code>import argparse\nimport rerun as rr\n\nparser = argparse.ArgumentParser()\nrr.script_add_args(parser)\nargs = parser.parse_args()\nrr.script_setup(args, \"my_application\")\n# ... Run your logging code here ...\nrr.script_teardown(args)\n</code></pre>"},{"location":"common/helpers/#rerun.script_add_args","title":"<code>def rerun.script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"common/helpers/#rerun.script_setup","title":"<code>def rerun.script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"common/helpers/#rerun.script_teardown","title":"<code>def rerun.script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"common/images/","title":"Images","text":""},{"location":"common/images/#rerun.log_image","title":"<code>def rerun.log_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None, jpeg_quality=None)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"common/images/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8, uint16, uint32, uint64: color components should be in 0-<code>max_uint</code> sRGB gamma space, except for alpha    which should be in 0-<code>max_uint</code> linear space.</li> <li>float16, float32, float64: all color components should be in 0-1 linear space.</li> <li>int8, int16, int32, int64: if all pixels are positive, they are interpreted as their unsigned counterparts.    Otherwise, the image is normalized before display (the pixel with the lowest value is black and the pixel with    the highest value is white).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>jpeg_quality</code> <code>int | None</code> <p>If set, encode the image as a JPEG to save storage space. Higher quality = larger file size. A quality of 95 still saves a lot of space, but is visually very similar. JPEG compression works best for photographs. Only RGB images are supported. Note that compressing to JPEG costs a bit of CPU time, both when logging and later when viewing them.</p> <code>None</code>"},{"location":"common/images/#rerun.log_image_file","title":"<code>def rerun.log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False, recording=None)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>Only JPEGs and PNGs are supported right now.</p> <p>JPEGs will be stored compressed, saving memory, whilst PNGs will currently be decoded before they are logged. This may change in the future.</p> <p>If no <code>img_format</code> is specified, rerun will try to guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>bytes | None</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Path | None</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>ImageFormat | None</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/images/#rerun.log_depth_image","title":"<code>def rerun.log_depth_image(entity_path, image, *, draw_order=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"common/images/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>float16, float32, float64, uint8, uint16, uint32, uint64, int8, int16, int32, int64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/images/#rerun.log_segmentation_image","title":"<code>def rerun.log_segmentation_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"common/images/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/","title":"Initialization","text":""},{"location":"common/initialization/#rerun.init","title":"<code>def rerun.init(application_id, recording_id=None, spawn=False, init_logging=True, default_enabled=True, strict=False, exp_init_blueprint=False, exp_add_to_app_default_blueprint=True)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>You must call this function first in order to initialize a global recording. Without an active recording, all methods of the SDK will turn into no-ops.</p> <p>For more advanced use cases, e.g. multiple recordings setups, see <code>rerun.new_recording</code>.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>recording_id</code> <code>Optional[str]</code> <p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <code>None</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can be overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <code>init_logging</code> <code>bool</code> <p>Should we initialize the logging for this application?</p> <code>True</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, an exceptions is raised on use error (wrong parameter types, etc.). If <code>False</code>, errors are logged as warnings instead.</p> <code>False</code> <code>exp_init_blueprint</code> <code>bool</code> <p>(Experimental) Should we initialize the blueprint for this application?</p> <code>False</code> <code>exp_add_to_app_default_blueprint</code> <code>bool</code> <p>(Experimental) Should the blueprint append to the existing app-default blueprint instead of creating a new one.</p> <code>True</code>"},{"location":"common/initialization/#rerun.connect","title":"<code>def rerun.connect(addr=None, flush_timeout_sec=2.0, recording=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer by typing 'rerun' in a terminal.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str | None</code> <p>The ip:port to connect to</p> <code>None</code> <code>flush_timeout_sec</code> <code>float | None</code> <p>The minimum time the SDK will wait during a flush before potentially dropping data if progress is not being made. Passing <code>None</code> indicates no timeout, and can cause a call to <code>flush</code> to block indefinitely.</p> <code>2.0</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/#rerun.disconnect","title":"<code>def rerun.disconnect(recording=None)</code>","text":"<p>Closes all TCP connections, servers, and files.</p> <p>Closes all TCP connections, servers, and files that have been opened with [<code>rerun.connect</code>], [<code>rerun.serve</code>], [<code>rerun.save</code>] or [<code>rerun.spawn</code>].</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/#rerun.spawn","title":"<code>def rerun.spawn(port=9876, connect=True, recording=None)</code>","text":"<p>Spawn a Rerun Viewer, listening on the given port.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>You can also call rerun.init with a <code>spawn=True</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code> <code>connect</code> <code>bool</code> <p>also connect to the viewer and stream logging data to it.</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use if <code>connect = True</code>. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/#rerun.serve","title":"<code>def rerun.serve(open_browser=True, web_port=None, ws_port=None, recording=None)</code>","text":"<p>Serve log-data over WebSockets and serve a Rerun web viewer over HTTP.</p> <p>You can also connect to this server with the native viewer using <code>rerun localhost:9090</code>.</p> <p>WARNING: This is an experimental feature.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>open_browser</code> <code>bool</code> <p>Open the default browser to the viewer.</p> <code>True</code> <code>web_port</code> <code>int | None</code> <p>The port to serve the web viewer on (defaults to 9090).</p> <code>None</code> <code>ws_port</code> <code>int | None</code> <p>The port to serve the WebSocket server on (defaults to 9877)</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/#rerun.save","title":"<code>def rerun.save(path, recording=None)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/initialization/#rerun.memory_recording","title":"<code>def rerun.memory_recording(recording=None)</code>","text":"<p>Streams all log-data to a memory buffer.</p> <p>This can be used to display the RRD to alternative formats such as html. See: rerun.MemoryRecording.as_html.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>MemoryRecording</code> <p>A memory recording object that can be used to read the data.</p>"},{"location":"common/plotting/","title":"Plotting","text":""},{"location":"common/plotting/#rerun.log_scalar","title":"<code>def rerun.log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None, recording=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"common/plotting/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>str | None</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear gray in the legend.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>bool | None</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/","title":"Spatial Primitives","text":""},{"location":"common/spatial_primitives/#rerun.log_point","title":"<code>def rerun.log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"common/spatial_primitives/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>int | None</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_points","title":"<code>def rerun.log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/spatial_primitives/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>npt.ArrayLike | None</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_rect","title":"<code>def rerun.log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>npt.ArrayLike | None</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_rects","title":"<code>def rerun.log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/spatial_primitives/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>npt.ArrayLike | None</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Sequence[int] | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <pre><code>If true, the rects will be timeless (default: False).\n</code></pre> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_obb","title":"<code>def rerun.log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"common/spatial_primitives/#rerun.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>npt.ArrayLike | None</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>npt.ArrayLike | None</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_line_strip","title":"<code>def rerun.log_line_strip(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_line_segments","title":"<code>def rerun.log_line_segments(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_arrow","title":"<code>def rerun.log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>npt.ArrayLike | None</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>npt.ArrayLike | None</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>float | None</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_mesh","title":"<code>def rerun.log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False, recording=None)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"common/spatial_primitives/#rerun.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Any | None</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Any | None</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Any | None</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Colors | None</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_meshes","title":"<code>def rerun.log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False, recording=None)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Colors | None]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/spatial_primitives/#rerun.log_mesh_file","title":"<code>def rerun.log_mesh_file(entity_path, mesh_format, *, mesh_bytes=None, mesh_path=None, transform=None, timeless=False, recording=None)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You must pass either <code>mesh_bytes</code> or <code>mesh_path</code>.</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"common/spatial_primitives/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_bytes</code> <code>bytes | None</code> <p>Content of an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>mesh_path</code> <code>Path | None</code> <p>Path to an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>transform</code> <code>npt.ArrayLike | None</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/tensors/","title":"Tensors","text":""},{"location":"common/tensors/#rerun.log_tensor","title":"<code>def rerun.log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Iterable[str | None] | None</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/text/","title":"Text","text":""},{"location":"common/text/#rerun.log_text_entry","title":"<code>def rerun.log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>str | None</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/text/#rerun.LogLevel","title":"<code>class rerun.LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"common/text/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"common/text/#rerun.LoggingHandler","title":"<code>class rerun.LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"common/text/#rerun.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"common/text/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"common/time/","title":"Time","text":""},{"location":"common/time/#rerun.set_time_sequence","title":"<code>def rerun.set_time_sequence(timeline, sequence, recording=None)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For example: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/time/#rerun.set_time_seconds","title":"<code>def rerun.set_time_seconds(timeline, seconds, recording=None)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_seconds</code> or <code>rerun.set_time_nanos</code>.</p> <p>For example: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as seconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/time/#rerun.set_time_nanos","title":"<code>def rerun.set_time_nanos(timeline, nanos, recording=None)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>For example: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as nanoseconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/transforms/","title":"Transforms","text":"<p>Methods for logging transforms on entity paths.</p> <p>Learn more about transforms in the manual</p>"},{"location":"common/transforms/#rerun.log_transform3d","title":"<code>def rerun.log_transform3d(entity_path, transform, *, from_parent=False, timeless=False, recording=None)</code>","text":"<p>Log an (affine) 3D transform between this entity and the parent.</p> <p>If <code>from_parent</code> is set to <code>True</code>, the transformation is from the parent to the space of the entity_path, otherwise it is from the child to the parent.</p> <p>Note that new transforms replace previous, i.e. if you call this function several times on the same path, each new transform will replace the previous one and does not combine with it.</p> <p>Examples:</p> <pre><code># Log translation only.\nrr.log_transform3d(\"transform_test/translation\", rr.Translation3D((2, 1, 3)))\n\n# Log scale along the x axis only.\nrr.log_transform3d(\"transform_test/x_scaled\", rr.Scale3D((3, 1, 1)))\n\n# Log a rotation around the z axis.\nrr.log_transform3d(\"transform_test/z_rotated_object\", rr.RotationAxisAngle((0, 0, 1), degrees=20))\n\n# Log scale followed by translation along the Y-axis.\nrr.log_transform3d(\n    \"transform_test/scaled_and_translated_object\", rr.TranslationRotationScale3D([0.0, 1.0, 0.0], scale=2)\n)\n\n# Log translation + rotation, also called a rigid transform.\nrr.log_transform3d(\"transform_test/rigid3\", rr.Rigid3D([1, 2, 3], rr.RotationAxisAngle((0, 1, 0), radians=1.57)))\n\n# Log translation, rotation &amp; scale all at once.\nrr.log_transform3d(\n    \"transform_test/transformed\",\n    rr.TranslationRotationScale3D(\n        translation=[0, 1, 5],\n        rotation=rr.RotationAxisAngle((0, 0, 1), degrees=20),\n        scale=2,\n    ),\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>transform</code> <code>TranslationAndMat3 | TranslationRotationScale3D | RotationAxisAngle | Translation3D | Scale3D | Quaternion | Rigid3D</code> <p>Instance of a rerun data class that describes a three dimensional transform. One of: * <code>TranslationAndMat3</code> * <code>TranslationRotationScale3D</code> * <code>Rigid3D</code> * <code>RotationAxisAngle</code> * <code>Translation3D</code> * <code>Quaternion</code> * <code>Scale3D</code></p> required <code>from_parent</code> <code>bool</code> <p>If True, the transform is from the parent to the child, otherwise it is from the child to the parent.</p> <code>False</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/transforms/#rerun.log_pinhole","title":"<code>def rerun.log_pinhole(entity_path, *, width, height, focal_length_px=None, principal_point_px=None, child_from_parent=None, timeless=False, recording=None, camera_xyz=None)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"common/transforms/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  focal_length_px = f_len)\n\n# More explicit:\nu_cen = width / 2\nv_cen = height / 2\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  camera_xyz=\"RDF\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>focal_length_px</code> <code>float | npt.ArrayLike | None</code> <p>The focal length of the camera in pixels. This is the diagonal of the projection matrix. Set one value for symmetric cameras, or two values (X=Right, Y=Down) for anamorphic cameras.</p> <code>None</code> <code>principal_point_px</code> <code>npt.ArrayLike | None</code> <p>The center of the camera in pixels. The default is half the width and height. This is the last column of the projection matrix. Expects two values along the dimensions Right and Down</p> <code>None</code> <code>child_from_parent</code> <code>npt.ArrayLike | None</code> <p>Row-major intrinsics matrix for projecting from camera space to image space. The first two axes are X=Right and Y=Down, respectively. Projection is done along the positive third (Z=Forward) axis. This can be specified instead of <code>focal_length_px</code> and <code>principal_point_px</code>.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>camera_xyz</code> <code>str | None</code> <p>Sets the view coordinates for the camera. The default is \"RDF\", i.e. X=Right, Y=Down, Z=Forward, and this is also the recommended setting. This means that the camera frustum will point along the positive Z axis of the parent space, and the cameras \"up\" direction will be along the negative Y axis of the parent space.</p> <p>Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>The camera furstum will point whichever axis is set to <code>F</code> (or the oppositve of <code>B</code>). When logging a depth image under this entity, this is the direction the point cloud will be projected. With XYZ=RDF, the default forward is +Z.</p> <p>The frustum's \"up\" direction will be whichever axis is set to <code>U</code> (or the oppositve of <code>D</code>). This will match the negative Y direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default is up is -Y.</p> <p>The frustum's \"right\" direction will be whichever axis is set to <code>R</code> (or the oppositve of <code>L</code>). This will match the positive X direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default right is +x.</p> <p>Other common formats are \"RUB\" (X=Right, Y=Up, Z=Back) and \"FLU\" (X=Forward, Y=Left, Z=Up).</p> <p>Equivalent to calling <code>rerun.log_view_coordinates(entity, xyz=\u2026)</code>.</p> <p>NOTE: setting this to something else than \"RDF\" (the default) will change the orientation of the camera frustum, and make the pinhole matrix not match up with the coordinate system of the pinhole entity.</p> <p>The pinhole matrix (the <code>child_from_parent</code> argument) always project along the third (Z) axis, but will be re-oriented to project along the forward axis of the <code>camera_xyz</code> argument.</p> <code>None</code>"},{"location":"common/transforms/#rerun.log_unknown_transform","title":"<code>def rerun.log_unknown_transform(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"common/transforms/#rerun.log_disconnected_space","title":"<code>def rerun.log_disconnected_space(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent.</p> <p>This is useful for specifying that a subgraph is independent of the rest of the scene. If a transform or pinhole is logged on the same path, this component will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"common/transforms/#rerun.log_view_coordinates","title":"<code>def rerun.log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False, recording=None)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space.</p> <p>This is particularly useful for 3D spaces, to set the up-axis.</p> <p>For pinhole entities this will control the direction of the camera frustum. You should use <code>rerun.log_pinhole(\u2026, camera_xyz=\u2026)</code> for this instead, and read the documentation there.</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul> <p>Currently Rerun only supports right-handed coordinate systems.</p>"},{"location":"common/transforms/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera/image\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>bool | None</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"common/viewer_control/","title":"Viewer Control","text":""},{"location":"common/viewer_control/#rerun.save","title":"<code>def rerun.save(path, recording=None)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/","title":"Full Package","text":"<ul> <li>rerun: Top-level User-facing APIs. See also: Common APIs<ul> <li>rerun.log: APIs for logging data</li> <li>rerun.color_conversion: Conversion utilities related to colors</li> <li>rerun.components: Helpers for constructing arrow components</li> </ul> </li> <li>rerun_demo: Utilities related to running rerun demos<ul> <li>rerun_demo.data: Specific helpers for generating data</li> </ul> </li> </ul>"},{"location":"package/rerun/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/__init__/#rerun","title":"<code>rerun</code>","text":"<p>The Rerun Python SDK, which is a wrapper around the re_sdk crate.</p>"},{"location":"package/rerun/__init__/#rerun.RecordingStream","title":"<code>class RecordingStream(inner)</code>","text":"<p>A RecordingStream is used to send data to Rerun.</p> <p>You can instantiate a RecordingStream by calling either <code>rerun.init</code> (to create a global recording) or <code>rerun.new_recording</code> (for more advanced use cases).</p>"},{"location":"package/rerun/__init__/#rerun.RecordingStream--multithreading","title":"Multithreading","text":"<p>A RecordingStream can safely be copied and sent to other threads. You can also set a recording as the global active one for all threads (<code>rerun.set_global_data_recording</code>) or just for the current thread (<code>rerun.set_thread_local_data_recording</code>).</p> <p>Similarly, the <code>with</code> keyword can be used to temporarily set the active recording for the current thread, e.g.: <pre><code>with rec:\n    rr.log_points(...)\n</code></pre></p> <p>See also: <code>rerun.get_data_recording</code>, <code>rerun.get_global_data_recording</code>, <code>rerun.get_thread_local_data_recording</code>.</p>"},{"location":"package/rerun/__init__/#rerun.RecordingStream--available-methods","title":"Available methods","text":"<p>Every function in the Rerun SDK that takes an optional RecordingStream as a parameter can also be called as a method on RecordingStream itself.</p> <p>This includes, but isn't limited to:</p> <ul> <li>Metadata-related functions:     <code>rerun.is_enabled</code>, <code>rerun.get_recording_id</code>, ...</li> <li>Sink-related functions:     <code>rerun.connect</code>, <code>rerun.spawn</code>, ...</li> <li>Time-related functions:     <code>rerun.set_time_seconds</code>, <code>rerun.set_time_sequence</code>, ...</li> <li>Log-related functions:     <code>rerun.log_points</code>, <code>rerun.log_mesh_file</code>, ...</li> </ul> <p>For an exhaustive list, see <code>help(rerun.RecordingStream)</code>.</p>"},{"location":"package/rerun/__init__/#rerun.RecordingStream--micro-batching","title":"Micro-batching","text":"<p>Micro-batching using both space and time triggers (whichever comes first) is done automatically in a dedicated background thread.</p> <p>You can configure the frequency of the batches using the following environment variables:</p> <ul> <li><code>RERUN_FLUSH_TICK_SECS</code>:     Flush frequency in seconds (default: <code>0.05</code> (50ms)).</li> <li><code>RERUN_FLUSH_NUM_BYTES</code>:     Flush threshold in bytes (default: <code>1048576</code> (1MiB)).</li> <li><code>RERUN_FLUSH_NUM_ROWS</code>:     Flush threshold in number of rows (default: <code>18446744073709551615</code> (u64::MAX)).</li> </ul>"},{"location":"package/rerun/__init__/#rerun.Quaternion","title":"<code>class Quaternion(*, xyzw)</code>","text":"<p>3D rotation expressed via a Quaternion.</p>"},{"location":"package/rerun/__init__/#rerun.components.quaternion.Quaternion.xyzw","title":"<code>xyzw: npt.ArrayLike = xyzw</code>  <code>instance-attribute</code>","text":"<p>Quaternion given as a 4-element array of floats in the order (x, y, z, w).</p>"},{"location":"package/rerun/__init__/#rerun.AnnotationInfo","title":"<code>class AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Color | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"package/rerun/__init__/#rerun.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/__init__/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/__init__/#rerun.MeshFormat","title":"<code>class MeshFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Mesh file format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.MeshFormat.GLB","title":"<code>GLB = 'GLB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>glTF binary format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.MeshFormat.OBJ","title":"<code>OBJ = 'OBJ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Wavefront .obj format.</p>"},{"location":"package/rerun/__init__/#rerun.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/__init__/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/__init__/#rerun.LoggingHandler","title":"<code>class LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"package/rerun/__init__/#rerun.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"package/rerun/__init__/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/__init__/#rerun.Transform3D","title":"<code>class Transform3D</code>  <code>dataclass</code>","text":"<p>An affine transform between two 3D spaces, represented in a given direction.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.Transform3D.transform","title":"<code>transform: TranslationAndMat3 | TranslationRotationScale3D</code>  <code>instance-attribute</code>","text":"<p>Representation of a 3D transform.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.Transform3D.from_parent","title":"<code>from_parent: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, the transform maps from the parent space to the child space. Otherwise, the transform maps from the child space to the parent space.</p>"},{"location":"package/rerun/__init__/#rerun.ImageFormat","title":"<code>class ImageFormat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Image file format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.ImageFormat.JPEG","title":"<code>JPEG = 'jpeg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JPEG format.</p>"},{"location":"package/rerun/__init__/#rerun.log.file.ImageFormat.PNG","title":"<code>PNG = 'png'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"package/rerun/__init__/#rerun.TranslationAndMat3","title":"<code>class TranslationAndMat3</code>  <code>dataclass</code>","text":"<p>Representation of a affine transform via a 3x3 translation matrix paired with a translation.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.TranslationAndMat3.translation","title":"<code>translation: npt.ArrayLike | Translation3D | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied after the matrix. Uses (0, 0, 0) if not set.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.TranslationAndMat3.matrix","title":"<code>matrix: npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The row-major 3x3 matrix for scale, rotation &amp; skew matrix. Uses identity if not set.</p>"},{"location":"package/rerun/__init__/#rerun.ClassDescription","title":"<code>class ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.info","title":"<code>info: AnnotationInfoLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Iterable[AnnotationInfoLike] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"package/rerun/__init__/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Iterable[int | tuple[int, int]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"package/rerun/__init__/#rerun.Rigid3D","title":"<code>class Rigid3D</code>  <code>dataclass</code>","text":"<p>Representation of a rigid transform via separate translation &amp; rotation.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.Rigid3D.translation","title":"<code>translation: Translation3D | npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.Rigid3D.rotation","title":"<code>rotation: Quaternion | RotationAxisAngle | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, represented as a quaternion or axis + angle, applied second.</p>"},{"location":"package/rerun/__init__/#rerun.TranslationRotationScale3D","title":"<code>class TranslationRotationScale3D</code>  <code>dataclass</code>","text":"<p>Representation of an affine transform via separate translation, rotation &amp; scale.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.TranslationRotationScale3D.translation","title":"<code>translation: Translation3D | npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.TranslationRotationScale3D.rotation","title":"<code>rotation: Quaternion | RotationAxisAngle | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, represented as a quaternion or axis + angle, applied second.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.TranslationRotationScale3D.scale","title":"<code>scale: Scale3D | npt.ArrayLike | float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D scaling either a 3D vector, scalar or None. Applied first.</p>"},{"location":"package/rerun/__init__/#rerun.Translation3D","title":"<code>class Translation3D</code>  <code>dataclass</code>","text":"<p>3D translation expressed as a vector.</p>"},{"location":"package/rerun/__init__/#rerun.Scale3D","title":"<code>class Scale3D</code>  <code>dataclass</code>","text":"<p>3D scale expressed as either a uniform scale or a vector.</p>"},{"location":"package/rerun/__init__/#rerun.RotationAxisAngle","title":"<code>class RotationAxisAngle</code>  <code>dataclass</code>","text":"<p>3D rotation expressed via a rotation axis and angle.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.RotationAxisAngle.axis","title":"<code>axis: npt.ArrayLike</code>  <code>instance-attribute</code>","text":"<p>Axis to rotate around.</p> <p>This is not required to be normalized. If normalization fails (typically because the vector is length zero), the rotation is silently ignored.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.RotationAxisAngle.degrees","title":"<code>degrees: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation angle in degrees. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.RotationAxisAngle.radians","title":"<code>radians: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation angle in radians. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/__init__/#rerun.Transform3DArray","title":"<code>class Transform3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/__init__/#rerun.components.transform3d.Transform3DArray.from_transform","title":"<code>def from_transform(transform)</code>","text":"<p>Build a <code>Transform3DArray</code> from a single transform.</p>"},{"location":"package/rerun/__init__/#rerun.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False, recording=None)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>recursive:     Should this apply to all entity paths below <code>entity_path</code>?</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/__init__/#rerun.set_time_sequence","title":"<code>def set_time_sequence(timeline, sequence, recording=None)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For example: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.connect","title":"<code>def connect(addr=None, flush_timeout_sec=2.0, recording=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer by typing 'rerun' in a terminal.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str | None</code> <p>The ip:port to connect to</p> <code>None</code> <code>flush_timeout_sec</code> <code>float | None</code> <p>The minimum time the SDK will wait during a flush before potentially dropping data if progress is not being made. Passing <code>None</code> indicates no timeout, and can cause a call to <code>flush</code> to block indefinitely.</p> <code>2.0</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_pinhole","title":"<code>def log_pinhole(entity_path, *, width, height, focal_length_px=None, principal_point_px=None, child_from_parent=None, timeless=False, recording=None, camera_xyz=None)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  focal_length_px = f_len)\n\n# More explicit:\nu_cen = width / 2\nv_cen = height / 2\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  camera_xyz=\"RDF\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>focal_length_px</code> <code>float | npt.ArrayLike | None</code> <p>The focal length of the camera in pixels. This is the diagonal of the projection matrix. Set one value for symmetric cameras, or two values (X=Right, Y=Down) for anamorphic cameras.</p> <code>None</code> <code>principal_point_px</code> <code>npt.ArrayLike | None</code> <p>The center of the camera in pixels. The default is half the width and height. This is the last column of the projection matrix. Expects two values along the dimensions Right and Down</p> <code>None</code> <code>child_from_parent</code> <code>npt.ArrayLike | None</code> <p>Row-major intrinsics matrix for projecting from camera space to image space. The first two axes are X=Right and Y=Down, respectively. Projection is done along the positive third (Z=Forward) axis. This can be specified instead of <code>focal_length_px</code> and <code>principal_point_px</code>.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>camera_xyz</code> <code>str | None</code> <p>Sets the view coordinates for the camera. The default is \"RDF\", i.e. X=Right, Y=Down, Z=Forward, and this is also the recommended setting. This means that the camera frustum will point along the positive Z axis of the parent space, and the cameras \"up\" direction will be along the negative Y axis of the parent space.</p> <p>Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>The camera furstum will point whichever axis is set to <code>F</code> (or the oppositve of <code>B</code>). When logging a depth image under this entity, this is the direction the point cloud will be projected. With XYZ=RDF, the default forward is +Z.</p> <p>The frustum's \"up\" direction will be whichever axis is set to <code>U</code> (or the oppositve of <code>D</code>). This will match the negative Y direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default is up is -Y.</p> <p>The frustum's \"right\" direction will be whichever axis is set to <code>R</code> (or the oppositve of <code>L</code>). This will match the positive X direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default right is +x.</p> <p>Other common formats are \"RUB\" (X=Right, Y=Up, Z=Back) and \"FLU\" (X=Forward, Y=Left, Z=Up).</p> <p>Equivalent to calling <code>rerun.log_view_coordinates(entity, xyz=\u2026)</code>.</p> <p>NOTE: setting this to something else than \"RDF\" (the default) will change the orientation of the camera frustum, and make the pinhole matrix not match up with the coordinate system of the pinhole entity.</p> <p>The pinhole matrix (the <code>child_from_parent</code> argument) always project along the third (Z) axis, but will be re-oriented to project along the forward axis of the <code>camera_xyz</code> argument.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_mesh","title":"<code>def log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False, recording=None)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Any | None</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Any | None</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Any | None</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Colors | None</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_scalar","title":"<code>def log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None, recording=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>str | None</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear gray in the legend.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>bool | None</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>npt.ArrayLike | None</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>npt.ArrayLike | None</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>float | None</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_image","title":"<code>def log_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None, jpeg_quality=None)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/__init__/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8, uint16, uint32, uint64: color components should be in 0-<code>max_uint</code> sRGB gamma space, except for alpha    which should be in 0-<code>max_uint</code> linear space.</li> <li>float16, float32, float64: all color components should be in 0-1 linear space.</li> <li>int8, int16, int32, int64: if all pixels are positive, they are interpreted as their unsigned counterparts.    Otherwise, the image is normalized before display (the pixel with the lowest value is black and the pixel with    the highest value is white).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>jpeg_quality</code> <code>int | None</code> <p>If set, encode the image as a JPEG to save storage space. Higher quality = larger file size. A quality of 95 still saves a lot of space, but is visually very similar. JPEG compression works best for photographs. Only RGB images are supported. Note that compressing to JPEG costs a bit of CPU time, both when logging and later when viewing them.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>npt.ArrayLike | None</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.script_add_args","title":"<code>def script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"package/rerun/__init__/#rerun.log_obb","title":"<code>def log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/__init__/#rerun.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>npt.ArrayLike | None</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>npt.ArrayLike | None</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_point","title":"<code>def log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"package/rerun/__init__/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>int | None</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False, recording=None)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space.</p> <p>This is particularly useful for 3D spaces, to set the up-axis.</p> <p>For pinhole entities this will control the direction of the camera frustum. You should use <code>rerun.log_pinhole(\u2026, camera_xyz=\u2026)</code> for this instead, and read the documentation there.</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul> <p>Currently Rerun only supports right-handed coordinate systems.</p>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera/image\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>bool | None</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.set_time_seconds","title":"<code>def set_time_seconds(timeline, seconds, recording=None)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_seconds</code> or <code>rerun.set_time_nanos</code>.</p> <p>For example: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as seconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.save","title":"<code>def save(path, recording=None)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_tensor","title":"<code>def log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Iterable[str | None] | None</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_line_strip","title":"<code>def log_line_strip(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, *, mesh_bytes=None, mesh_path=None, transform=None, timeless=False, recording=None)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You must pass either <code>mesh_bytes</code> or <code>mesh_path</code>.</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_bytes</code> <code>bytes | None</code> <p>Content of an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>mesh_path</code> <code>Path | None</code> <p>Path to an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>transform</code> <code>npt.ArrayLike | None</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.script_setup","title":"<code>def script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"package/rerun/__init__/#rerun.disconnect","title":"<code>def disconnect(recording=None)</code>","text":"<p>Closes all TCP connections, servers, and files.</p> <p>Closes all TCP connections, servers, and files that have been opened with [<code>rerun.connect</code>], [<code>rerun.serve</code>], [<code>rerun.save</code>] or [<code>rerun.spawn</code>].</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_extension_components","title":"<code>def log_extension_components(entity_path, ext, *, identifiers=None, timeless=False, recording=None)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Sequence[int] | None</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_text_entry","title":"<code>def log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>str | None</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.set_time_nanos","title":"<code>def set_time_nanos(timeline, nanos, recording=None)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>For example: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as nanoseconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True, recording=None)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>ClassDescriptionLike | Iterable[ClassDescriptionLike]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.memory_recording","title":"<code>def memory_recording(recording=None)</code>","text":"<p>Streams all log-data to a memory buffer.</p> <p>This can be used to display the RRD to alternative formats such as html. See: rerun.MemoryRecording.as_html.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>MemoryRecording</code> <p>A memory recording object that can be used to read the data.</p>"},{"location":"package/rerun/__init__/#rerun.script_teardown","title":"<code>def script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"package/rerun/__init__/#rerun.log_meshes","title":"<code>def log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False, recording=None)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Colors | None]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.serve","title":"<code>def serve(open_browser=True, web_port=None, ws_port=None, recording=None)</code>","text":"<p>Serve log-data over WebSockets and serve a Rerun web viewer over HTTP.</p> <p>You can also connect to this server with the native viewer using <code>rerun localhost:9090</code>.</p> <p>WARNING: This is an experimental feature.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>open_browser</code> <code>bool</code> <p>Open the default browser to the viewer.</p> <code>True</code> <code>web_port</code> <code>int | None</code> <p>The port to serve the web viewer on (defaults to 9090).</p> <code>None</code> <code>ws_port</code> <code>int | None</code> <p>The port to serve the WebSocket server on (defaults to 9877)</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.reset_time","title":"<code>def reset_time(recording=None)</code>","text":"<p>Clear all timeline information on this thread.</p> <p>This is the same as calling <code>set_time_*</code> with <code>None</code> for all of the active timelines.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_image_file","title":"<code>def log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False, recording=None)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>Only JPEGs and PNGs are supported right now.</p> <p>JPEGs will be stored compressed, saving memory, whilst PNGs will currently be decoded before they are logged. This may change in the future.</p> <p>If no <code>img_format</code> is specified, rerun will try to guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>bytes | None</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Path | None</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>ImageFormat | None</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.is_enabled","title":"<code>def is_enabled(recording=None)</code>","text":"<p>Is this Rerun recording enabled.</p> <p>If false, all calls to the recording are ignored.</p> <p>The default can be set in <code>rerun.init</code>, but is otherwise <code>True</code>.</p> <p>This can be controlled with the environment variable <code>RERUN</code> (e.g. <code>RERUN=on</code> or <code>RERUN=off</code>).</p>"},{"location":"package/rerun/__init__/#rerun.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>npt.ArrayLike | None</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Sequence[int] | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <pre><code>If true, the rects will be timeless (default: False).\n</code></pre> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, draw_order=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/__init__/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>float16, float32, float64, uint8, uint16, uint32, uint64, int8, int16, int32, int64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.get_application_id","title":"<code>def get_application_id(recording=None)</code>","text":"<p>Get the application ID that this recording is associated with, if any.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The application ID that this recording is associated with.</p>"},{"location":"package/rerun/__init__/#rerun.log_line_strips_2d","title":"<code>def log_line_strips_2d(entity_path, line_strips, *, identifiers=None, stroke_widths=None, colors=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a batch of line strips through 2D space.</p> <p>Each line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>line_strips</code> <code>Iterable[npt.ArrayLike] | None</code> <p>An iterable of Nx2 arrays of points along the path. To log an empty line_strip use <code>np.zeros((0,0,3))</code> or <code>np.zeros((0,0,2))</code></p> required <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the line.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional widths of the line.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the lines. RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/__init__/#rerun.spawn","title":"<code>def spawn(port=9876, connect=True, recording=None)</code>","text":"<p>Spawn a Rerun Viewer, listening on the given port.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>You can also call rerun.init with a <code>spawn=True</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code> <code>connect</code> <code>bool</code> <p>also connect to the viewer and stream logging data to it.</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use if <code>connect = True</code>. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_points","title":"<code>def log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>npt.ArrayLike | None</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_obbs","title":"<code>def log_obbs(entity_path, *, half_sizes, positions=None, rotations_q=None, colors=None, stroke_widths=None, labels=None, class_ids=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/__init__/#rerun.log_obbs--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_sizes</code> <code>npt.ArrayLike | None</code> <p>Nx3 Array. Each row is the [x, y, z] half dimensions of an OBB.</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>Optional Nx3 array. Each row is [x, y, z] positions of an OBB in world space.</p> <code>None</code> <code>rotations_q</code> <code>npt.ArrayLike | None</code> <p>Optional Nx3 array. Each row is quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional Nx3 or Nx4 array. Each row is RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional array of the width of the line edges.</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional array of text labels placed at <code>position</code>.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds | None</code> <p>Optional array of class id for the OBBs.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.get_recording_id","title":"<code>def get_recording_id(recording=None)</code>","text":"<p>Get the recording ID that this recording is logging to, as a UUIDv4, if any.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The recording ID that this recording is logging to.</p>"},{"location":"package/rerun/__init__/#rerun.log_disconnected_space","title":"<code>def log_disconnected_space(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent.</p> <p>This is useful for specifying that a subgraph is independent of the rest of the scene. If a transform or pinhole is logged on the same path, this component will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/__init__/#rerun.init","title":"<code>def init(application_id, recording_id=None, spawn=False, init_logging=True, default_enabled=True, strict=False, exp_init_blueprint=False, exp_add_to_app_default_blueprint=True)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>You must call this function first in order to initialize a global recording. Without an active recording, all methods of the SDK will turn into no-ops.</p> <p>For more advanced use cases, e.g. multiple recordings setups, see <code>rerun.new_recording</code>.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>recording_id</code> <code>Optional[str]</code> <p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <code>None</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can be overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <code>init_logging</code> <code>bool</code> <p>Should we initialize the logging for this application?</p> <code>True</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, an exceptions is raised on use error (wrong parameter types, etc.). If <code>False</code>, errors are logged as warnings instead.</p> <code>False</code> <code>exp_init_blueprint</code> <code>bool</code> <p>(Experimental) Should we initialize the blueprint for this application?</p> <code>False</code> <code>exp_add_to_app_default_blueprint</code> <code>bool</code> <p>(Experimental) Should the blueprint append to the existing app-default blueprint instead of creating a new one.</p> <code>True</code>"},{"location":"package/rerun/__init__/#rerun.get_data_recording","title":"<code>def get_data_recording(recording=None)</code>","text":"<p>Returns the most appropriate recording to log data to, in the current context, if any.</p> <ul> <li>If <code>recording</code> is specified, returns that one;</li> <li>Otherwise, falls back to the currently active thread-local recording, if there is one;</li> <li>Otherwise, falls back to the currently active global recording, if there is one;</li> <li>Otherwise, returns None.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The most appropriate recording to log data to, in the current context, if any.</p>"},{"location":"package/rerun/__init__/#rerun.log_transform3d","title":"<code>def log_transform3d(entity_path, transform, *, from_parent=False, timeless=False, recording=None)</code>","text":"<p>Log an (affine) 3D transform between this entity and the parent.</p> <p>If <code>from_parent</code> is set to <code>True</code>, the transformation is from the parent to the space of the entity_path, otherwise it is from the child to the parent.</p> <p>Note that new transforms replace previous, i.e. if you call this function several times on the same path, each new transform will replace the previous one and does not combine with it.</p> <p>Examples:</p> <pre><code># Log translation only.\nrr.log_transform3d(\"transform_test/translation\", rr.Translation3D((2, 1, 3)))\n\n# Log scale along the x axis only.\nrr.log_transform3d(\"transform_test/x_scaled\", rr.Scale3D((3, 1, 1)))\n\n# Log a rotation around the z axis.\nrr.log_transform3d(\"transform_test/z_rotated_object\", rr.RotationAxisAngle((0, 0, 1), degrees=20))\n\n# Log scale followed by translation along the Y-axis.\nrr.log_transform3d(\n    \"transform_test/scaled_and_translated_object\", rr.TranslationRotationScale3D([0.0, 1.0, 0.0], scale=2)\n)\n\n# Log translation + rotation, also called a rigid transform.\nrr.log_transform3d(\"transform_test/rigid3\", rr.Rigid3D([1, 2, 3], rr.RotationAxisAngle((0, 1, 0), radians=1.57)))\n\n# Log translation, rotation &amp; scale all at once.\nrr.log_transform3d(\n    \"transform_test/transformed\",\n    rr.TranslationRotationScale3D(\n        translation=[0, 1, 5],\n        rotation=rr.RotationAxisAngle((0, 0, 1), degrees=20),\n        scale=2,\n    ),\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>transform</code> <code>TranslationAndMat3 | TranslationRotationScale3D | RotationAxisAngle | Translation3D | Scale3D | Quaternion | Rigid3D</code> <p>Instance of a rerun data class that describes a three dimensional transform. One of: * <code>TranslationAndMat3</code> * <code>TranslationRotationScale3D</code> * <code>Rigid3D</code> * <code>RotationAxisAngle</code> * <code>Translation3D</code> * <code>Quaternion</code> * <code>Scale3D</code></p> required <code>from_parent</code> <code>bool</code> <p>If True, the transform is from the parent to the child, otherwise it is from the child to the parent.</p> <code>False</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.get_global_data_recording","title":"<code>def get_global_data_recording()</code>","text":"<p>Returns the currently active global recording, if any.</p> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The currently active global recording, if any.</p>"},{"location":"package/rerun/__init__/#rerun.set_global_data_recording","title":"<code>def set_global_data_recording(recording)</code>","text":"<p>Replaces the currently active global recording with the specified one.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream</code> <p>The newly active global recording.</p> required"},{"location":"package/rerun/__init__/#rerun.log_line_strips_3d","title":"<code>def log_line_strips_3d(entity_path, line_strips, *, identifiers=None, stroke_widths=None, colors=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a batch of line strips through 3D space.</p> <p>Each line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>line_strips</code> <code>Iterable[npt.ArrayLike] | None</code> <p>An iterable of Nx3 arrays of points along the path. To log an empty line_strip use <code>np.zeros((0,0,3))</code> or <code>np.zeros((0,0,2))</code></p> required <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the line.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional widths of the line.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the lines. RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.get_thread_local_data_recording","title":"<code>def get_thread_local_data_recording()</code>","text":"<p>Returns the currently active thread-local recording, if any.</p> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The currently active thread-local recording, if any.</p>"},{"location":"package/rerun/__init__/#rerun.set_thread_local_data_recording","title":"<code>def set_thread_local_data_recording(recording)</code>","text":"<p>Replaces the currently active thread-local recording with the specified one.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream</code> <p>The newly active thread-local recording.</p> required"},{"location":"package/rerun/__init__/#rerun.new_recording","title":"<code>def new_recording(application_id, recording_id=None, make_default=False, make_thread_default=False, spawn=False, default_enabled=True)</code>","text":"<p>Creates a new recording with a user-chosen application id (name) that can be used to log data.</p> <p>If you only need a single global recording, <code>rerun.init</code> might be simpler.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>recording_id</code> <code>Optional[str]</code> <p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <code>None</code> <code>make_default</code> <code>bool</code> <p>If true (not the default), the newly initialized recording will replace the current active one (if any) in the global scope.</p> <code>False</code> <code>make_thread_default</code> <code>bool</code> <p>If true (not the default), the newly initialized recording will replace the current active one (if any) in the thread-local scope.</p> <code>False</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can be overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>RecordingStream</code> <p>A handle to the <code>rerun.RecordingStream</code>. Use it to log data to Rerun.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False, recording=None)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent (deprecated).</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p> <p>Note: This function is deprecated. Use <code>rerun.log_transform3d</code> instead.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>t = 0.0\ntranslation = [math.sin(t), math.cos(t), 0.0] # circle around origin\nrotation = [0.5, 0.0, 0.0, np.sin(np.pi/3)] # 60 degrees around x-axis\nrerun.log_rigid3(\"sun/planet\", parent_from_child=(translation, rotation))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>tuple[npt.ArrayLike, npt.ArrayLike] | None</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>tuple[npt.ArrayLike, npt.ArrayLike] | None</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.version","title":"<code>def version()</code>","text":"<p>Returns a verbose version string of the Rerun SDK.</p> <p>Example: <code>rerun_py 0.6.0-alpha.0 [rustc 1.69.0 (84c898d65 2023-04-16), LLVM 15.0.7] aarch64-apple-darwin main bd8a072, built 2023-05-11T08:25:17Z</code></p>"},{"location":"package/rerun/__init__/#rerun.shutdown_at_exit","title":"<code>def shutdown_at_exit(func)</code>","text":"<p>Decorator to shutdown Rerun cleanly when this function exits.</p> <p>Normally, Rerun installs an atexit-handler that attempts to shutdown cleanly and flush all outgoing data before terminating. However, some cases, such as forked processes will always skip this at-exit handler. In these cases, you can use this decorator on the entry-point to your subprocess to ensure cleanup happens as expected without losing data.</p>"},{"location":"package/rerun/__init__/#rerun.strict_mode","title":"<code>def strict_mode()</code>","text":"<p>Strict mode enabled.</p> <p>In strict mode, incorrect use of the Rerun API (wrong parameter types etc.) will result in exception being raised. When strict mode is on, such problems are instead logged as warnings.</p> <p>The default is OFF.</p>"},{"location":"package/rerun/__init__/#rerun.set_strict_mode","title":"<code>def set_strict_mode(mode)</code>","text":"<p>Turn strict mode on/off.</p> <p>In strict mode, incorrect use of the Rerun API (wrong parameter types etc.) will result in exception being raised. When strict mode is off, such problems are instead logged as warnings.</p> <p>The default is OFF.</p>"},{"location":"package/rerun/__init__/#rerun.start_web_viewer_server","title":"<code>def start_web_viewer_server(port=0)</code>","text":"<p>Start an HTTP server that hosts the rerun web viewer.</p> <p>This only provides the web-server that makes the viewer available and does not otherwise provide a rerun websocket server or facilitate any routing of data.</p> <p>This is generally only necessary for application such as running a jupyter notebook in a context where app.rerun.io is unavailable, or does not have the matching resources for your build (such as when running from source.)</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve assets on. Defaults to 0 (random port).</p> <code>0</code>"},{"location":"package/rerun/color_conversion/","title":"color_conversion.py","text":""},{"location":"package/rerun/color_conversion/#rerun.color_conversion","title":"<code>rerun.color_conversion</code>","text":"<p>Color conversion utilities.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.u8_array_to_rgba","title":"<code>def u8_array_to_rgba(arr)</code>","text":"<p>Convert an array with inner dimension [R,G,B,A] into packed uint32 values.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>npt.NDArray[np.uint8]</code> <p>Nx3 or Nx4 <code>[[r,g,b,a], ... ]</code> of uint8 values</p> required <p>Returns:</p> Type Description <code>npt.NDArray[np.uint32]</code> <p>Array of uint32 value as 0xRRGGBBAA.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_value","title":"<code>def linear_to_gamma_u8_value(linear)</code>","text":"<p>Transform color values from linear [0.0, 1.0] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype numpy.floating</p> <p>Intended to implement the following per color value: <pre><code>if l &lt;= 0.0 {\n0\n} else if l &lt;= 0.0031308 {\nround(3294.6 * l)\n} else if l &lt;= 1.0 {\nround(269.025 * l.powf(1.0 / 2.4) - 14.025)\n} else {\n255\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[np.float32 | np.float64]</code> <p>The linear color values to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color values.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_pixel","title":"<code>def linear_to_gamma_u8_pixel(linear)</code>","text":"<p>Transform color pixels from linear [0, 1] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype np.float32 or np.float64.</p> <p>The last dimension of the colors array <code>linear</code> is expected to represent a single pixel color. - 3 colors means RGB - 4 colors means RGBA</p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[np.float32 | np.float64]</code> <p>The linear color pixels to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color pixels.</p>"},{"location":"package/rerun/experimental/","title":"experimental.py","text":""},{"location":"package/rerun/experimental/#rerun.experimental","title":"<code>rerun.experimental</code>","text":"<p>Experimental features for Rerun.</p> <p>These features are not yet stable and may change in future releases without going through the normal deprecation cycle.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Points2D","title":"<code>class Points2D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 2D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Points2D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points2D([[0, 0], [1, 1]]))\n\n# Log an extra rect to set the view bounds\nrr.log_rect(\"bounds\", [0, 0, 4, 3], rect_format=rr.RectFormat.XCYCWH)\n</code></pre>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.points","title":"<code>points: components.Point2DArray = field(metadata={'component': 'primary'}, converter=components.Point2DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 2D points that make up the point cloud.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 2D points is 30.0.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points2d.Points2D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Points3D","title":"<code>class Points3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Points3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points3D([[0, 0, 0], [1, 1, 1]]))\n</code></pre>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.points","title":"<code>points: components.Point3DArray = field(metadata={'component': 'primary'}, converter=components.Point3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 3D points that make up the point cloud.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 3D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 3D points is 30.0.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.points3d.Points3D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Transform3D","title":"<code>class Transform3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D transform.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.Transform3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\nfrom rerun.experimental import dt as rrd\n\nrr.init(\"transform\", spawn=True)\n\norigin = [0, 0, 0]\nbase_vector = [0, 1, 0]\n\nrr.log_arrow(\"base\", origin=origin, vector=base_vector)\n\nrr2.log(\"base/translated\", rr2.Transform3D(rrd.TranslationRotationScale3D(translation=[1, 0, 0])))\n\nrr.log_arrow(\"base/translated\", origin=origin, vector=base_vector)\n\nrr2.log(\n   \"base/rotated_scaled\",\n   rrd.TranslationRotationScale3D(\n       rotation=rrd.RotationAxisAngle(axis=[0, 0, 1], radians=3.14 / 4), scale=rrd.Scale3D(2)\n   ),\n)\n\nrr.log_arrow(\"base/rotated_scaled\", origin=origin, vector=base_vector)\n</code></pre>"},{"location":"package/rerun/experimental/#rerun._rerun2.archetypes.transform3d.Transform3D.transform","title":"<code>transform: components.Transform3DArray = field(metadata={'component': 'primary'}, converter=components.Transform3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transform</p>"},{"location":"package/rerun/experimental/#rerun.experimental.new_blueprint","title":"<code>def new_blueprint(application_id, *, blueprint_id=None, make_default=False, make_thread_default=False, spawn=False, add_to_app_default_blueprint=False, default_enabled=True)</code>","text":"<p>Creates a new blueprint with a user-chosen application id (name) to configure the appearance of Rerun.</p> <p>If you only need a single global blueprint, <code>rerun.init</code> might be simpler.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>blueprint_id</code> <code>Optional[str]</code> <p>Set the blueprint ID that this process is logging to, as a UUIDv4.</p> <p>The default blueprint_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default blueprint_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same blueprint), you will need to manually assign them all the same blueprint_id. Any random UUIDv4 will work, or copy the blueprint_id for the parent process.</p> <code>None</code> <code>make_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the global scope.</p> <code>False</code> <code>make_thread_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the thread-local scope.</p> <code>False</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>add_to_app_default_blueprint</code> <code>bool</code> <p>Should the blueprint append to the existing app-default blueprint instead instead of creating a new one.</p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>RecordingStream</code> <p>A handle to the <code>rerun.RecordingStream</code>. Use it to log data to Rerun.</p>"},{"location":"package/rerun/experimental/#rerun.experimental.log_text_box","title":"<code>def log_text_box(entity_path, text, *, ext=None, timeless=False)</code>","text":"<p>Log a textbox.</p> <p>This is intended to be used for multi-line text entries to be displayed in their own view.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text-box should be timeless.</p> <code>False</code>"},{"location":"package/rerun/experimental/#rerun.experimental.add_space_view","title":"<code>def add_space_view(*, origin, name, entity_paths, blueprint=None)</code>","text":"<p>Add a new space view to the blueprint.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>The EntityPath to use as the origin of this space view. All other entities will be transformed to be displayed relative to this origin.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the space view to show in the UI. Will default to the origin if not provided.</p> required <code>entity_paths</code> <code>Optional[List[str]]</code> <p>The entities to be shown in the space view. If not provided, this will default to [origin]</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/experimental/#rerun.experimental.log","title":"<code>def log(entity_path, entity, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the entity in the space hierarchy.</p> required <code>entity</code> <code>Loggable</code> <p>The archetype object representing the entity.</p> required <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the entity will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/experimental/#rerun.experimental.set_panels","title":"<code>def set_panels(*, all_expanded=None, blueprint_view_expanded=None, selection_view_expanded=None, timeline_view_expanded=None, blueprint=None)</code>","text":"<p>Change the visibility of the view panels.</p> <p>Parameters:</p> Name Type Description Default <code>all_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse all panels.</p> <code>None</code> <code>blueprint_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the blueprint view panel.</p> <code>None</code> <code>selection_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the selection view panel.</p> <code>None</code> <code>timeline_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the timeline view panel.</p> <code>None</code> <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/experimental/#rerun.experimental.set_auto_space_views","title":"<code>def set_auto_space_views(enabled, blueprint=None)</code>","text":"<p>Change whether or not the blueprint automatically adds space views for all entities.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>Optional[bool]</code> <p>Whether or not to automatically add space views for all entities.</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/recording/","title":"recording.py","text":""},{"location":"package/rerun/recording/#rerun.recording","title":"<code>rerun.recording</code>","text":"<p>Helper functions for directly working with recordings.</p>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording","title":"<code>class MemoryRecording(storage)</code>","text":""},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.reset_data","title":"<code>def reset_data()</code>","text":"<p>Reset the data in the MemoryRecording.</p>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.reset_blueprint","title":"<code>def reset_blueprint(add_to_app_default_blueprint=False)</code>","text":"<p>Reset the blueprint in the MemoryRecording.</p>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.as_html","title":"<code>def as_html(width=DEFAULT_WIDTH, height=DEFAULT_HEIGHT, app_url=None, timeout_ms=DEFAULT_TIMEOUT, other=None)</code>","text":"<p>Generate an HTML snippet that displays the recording in an IFrame.</p> <p>For use in contexts such as Jupyter notebooks.</p> <p>\u26a0\ufe0f This will do a blocking flush of the current sink before returning!</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the viewer in pixels.</p> <code>DEFAULT_WIDTH</code> <code>height</code> <code>int</code> <p>The height of the viewer in pixels.</p> <code>DEFAULT_HEIGHT</code> <code>app_url</code> <code>str</code> <p>Alternative HTTP url to find the Rerun web viewer. This will default to using https://app.rerun.io or localhost if rerun.start_web_viewer_server has been called.</p> <code>None</code> <code>timeout_ms</code> <code>int</code> <p>The number of milliseconds to wait for the Rerun web viewer to load.</p> <code>DEFAULT_TIMEOUT</code> <code>other</code> <code>MemoryRecording | None</code> <p>An optional MemoryRecording to merge with this one.</p> <code>None</code>"},{"location":"package/rerun/recording/#rerun.recording.MemoryRecording.show","title":"<code>def show(other=None, width=DEFAULT_WIDTH, height=DEFAULT_HEIGHT, app_url=None, timeout_ms=DEFAULT_TIMEOUT)</code>","text":"<p>Output the Rerun viewer using IPython IPython.core.display.HTML.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the viewer in pixels.</p> <code>DEFAULT_WIDTH</code> <code>height</code> <code>int</code> <p>The height of the viewer in pixels.</p> <code>DEFAULT_HEIGHT</code> <code>app_url</code> <code>str</code> <p>Alternative HTTP url to find the Rerun web viewer. This will default to using https://app.rerun.io or localhost if rerun.start_web_viewer_server has been called.</p> <code>None</code> <code>timeout_ms</code> <code>int</code> <p>The number of milliseconds to wait for the Rerun web viewer to load.</p> <code>DEFAULT_TIMEOUT</code> <code>other</code> <code>MemoryRecording | None</code> <p>An optional MemoryRecording to merge with this one.</p> <code>None</code>"},{"location":"package/rerun/recording_stream/","title":"recording_stream.py","text":""},{"location":"package/rerun/recording_stream/#rerun.recording_stream","title":"<code>rerun.recording_stream</code>","text":""},{"location":"package/rerun/recording_stream/#rerun.recording_stream.RecordingStream","title":"<code>class RecordingStream(inner)</code>","text":"<p>A RecordingStream is used to send data to Rerun.</p> <p>You can instantiate a RecordingStream by calling either <code>rerun.init</code> (to create a global recording) or <code>rerun.new_recording</code> (for more advanced use cases).</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.RecordingStream--multithreading","title":"Multithreading","text":"<p>A RecordingStream can safely be copied and sent to other threads. You can also set a recording as the global active one for all threads (<code>rerun.set_global_data_recording</code>) or just for the current thread (<code>rerun.set_thread_local_data_recording</code>).</p> <p>Similarly, the <code>with</code> keyword can be used to temporarily set the active recording for the current thread, e.g.: <pre><code>with rec:\n    rr.log_points(...)\n</code></pre></p> <p>See also: <code>rerun.get_data_recording</code>, <code>rerun.get_global_data_recording</code>, <code>rerun.get_thread_local_data_recording</code>.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.RecordingStream--available-methods","title":"Available methods","text":"<p>Every function in the Rerun SDK that takes an optional RecordingStream as a parameter can also be called as a method on RecordingStream itself.</p> <p>This includes, but isn't limited to:</p> <ul> <li>Metadata-related functions:     <code>rerun.is_enabled</code>, <code>rerun.get_recording_id</code>, ...</li> <li>Sink-related functions:     <code>rerun.connect</code>, <code>rerun.spawn</code>, ...</li> <li>Time-related functions:     <code>rerun.set_time_seconds</code>, <code>rerun.set_time_sequence</code>, ...</li> <li>Log-related functions:     <code>rerun.log_points</code>, <code>rerun.log_mesh_file</code>, ...</li> </ul> <p>For an exhaustive list, see <code>help(rerun.RecordingStream)</code>.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.RecordingStream--micro-batching","title":"Micro-batching","text":"<p>Micro-batching using both space and time triggers (whichever comes first) is done automatically in a dedicated background thread.</p> <p>You can configure the frequency of the batches using the following environment variables:</p> <ul> <li><code>RERUN_FLUSH_TICK_SECS</code>:     Flush frequency in seconds (default: <code>0.05</code> (50ms)).</li> <li><code>RERUN_FLUSH_NUM_BYTES</code>:     Flush threshold in bytes (default: <code>1048576</code> (1MiB)).</li> <li><code>RERUN_FLUSH_NUM_ROWS</code>:     Flush threshold in number of rows (default: <code>18446744073709551615</code> (u64::MAX)).</li> </ul>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.is_enabled","title":"<code>def is_enabled(recording=None)</code>","text":"<p>Is this Rerun recording enabled.</p> <p>If false, all calls to the recording are ignored.</p> <p>The default can be set in <code>rerun.init</code>, but is otherwise <code>True</code>.</p> <p>This can be controlled with the environment variable <code>RERUN</code> (e.g. <code>RERUN=on</code> or <code>RERUN=off</code>).</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.get_application_id","title":"<code>def get_application_id(recording=None)</code>","text":"<p>Get the application ID that this recording is associated with, if any.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The application ID that this recording is associated with.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.get_recording_id","title":"<code>def get_recording_id(recording=None)</code>","text":"<p>Get the recording ID that this recording is logging to, as a UUIDv4, if any.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The recording ID that this recording is logging to.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.get_data_recording","title":"<code>def get_data_recording(recording=None)</code>","text":"<p>Returns the most appropriate recording to log data to, in the current context, if any.</p> <ul> <li>If <code>recording</code> is specified, returns that one;</li> <li>Otherwise, falls back to the currently active thread-local recording, if there is one;</li> <li>Otherwise, falls back to the currently active global recording, if there is one;</li> <li>Otherwise, returns None.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The most appropriate recording to log data to, in the current context, if any.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.get_global_data_recording","title":"<code>def get_global_data_recording()</code>","text":"<p>Returns the currently active global recording, if any.</p> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The currently active global recording, if any.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.set_global_data_recording","title":"<code>def set_global_data_recording(recording)</code>","text":"<p>Replaces the currently active global recording with the specified one.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream</code> <p>The newly active global recording.</p> required"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.get_thread_local_data_recording","title":"<code>def get_thread_local_data_recording()</code>","text":"<p>Returns the currently active thread-local recording, if any.</p> <p>Returns:</p> Type Description <code>Optional[RecordingStream]</code> <p>The currently active thread-local recording, if any.</p>"},{"location":"package/rerun/recording_stream/#rerun.recording_stream.set_thread_local_data_recording","title":"<code>def set_thread_local_data_recording(recording)</code>","text":"<p>Replaces the currently active thread-local recording with the specified one.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream</code> <p>The newly active thread-local recording.</p> required"},{"location":"package/rerun/script_helpers/","title":"script_helpers.py","text":""},{"location":"package/rerun/script_helpers/#rerun.script_helpers","title":"<code>rerun.script_helpers</code>","text":"<p>Helper functions for Rerun scripts.</p> <p>These helper functions can be used to wire up common Rerun features to your script CLi arguments.</p>"},{"location":"package/rerun/script_helpers/#rerun.script_helpers--example","title":"Example","text":"<pre><code>import argparse\nimport rerun as rr\n\nparser = argparse.ArgumentParser()\nrr.script_add_args(parser)\nargs = parser.parse_args()\nrr.script_setup(args, \"my_application\")\n# ... Run your logging code here ...\nrr.script_teardown(args)\n</code></pre>"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_add_args","title":"<code>def script_add_args(parser)</code>","text":"<p>Add common Rerun script arguments to <code>parser</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p>The parser to add arguments to.</p> required"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_setup","title":"<code>def script_setup(args, application_id)</code>","text":"<p>Run common Rerun script setup actions. Connect to the viewer if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required <code>application_id</code> <code>str</code> <p>The application ID to use for the viewer.</p> required"},{"location":"package/rerun/script_helpers/#rerun.script_helpers.script_teardown","title":"<code>def script_teardown(args)</code>","text":"<p>Run common post-actions. Sleep if serving the web viewer.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>The parsed arguments from <code>parser.parse_args()</code>.</p> required"},{"location":"package/rerun/sinks/","title":"sinks.py","text":""},{"location":"package/rerun/sinks/#rerun.sinks","title":"<code>rerun.sinks</code>","text":""},{"location":"package/rerun/sinks/#rerun.sinks.connect","title":"<code>def connect(addr=None, flush_timeout_sec=2.0, recording=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer by typing 'rerun' in a terminal.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str | None</code> <p>The ip:port to connect to</p> <code>None</code> <code>flush_timeout_sec</code> <code>float | None</code> <p>The minimum time the SDK will wait during a flush before potentially dropping data if progress is not being made. Passing <code>None</code> indicates no timeout, and can cause a call to <code>flush</code> to block indefinitely.</p> <code>2.0</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/sinks/#rerun.sinks.save","title":"<code>def save(path, recording=None)</code>","text":"<p>Stream all log-data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/sinks/#rerun.sinks.disconnect","title":"<code>def disconnect(recording=None)</code>","text":"<p>Closes all TCP connections, servers, and files.</p> <p>Closes all TCP connections, servers, and files that have been opened with [<code>rerun.connect</code>], [<code>rerun.serve</code>], [<code>rerun.save</code>] or [<code>rerun.spawn</code>].</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/sinks/#rerun.sinks.memory_recording","title":"<code>def memory_recording(recording=None)</code>","text":"<p>Streams all log-data to a memory buffer.</p> <p>This can be used to display the RRD to alternative formats such as html. See: rerun.MemoryRecording.as_html.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>MemoryRecording</code> <p>A memory recording object that can be used to read the data.</p>"},{"location":"package/rerun/sinks/#rerun.sinks.serve","title":"<code>def serve(open_browser=True, web_port=None, ws_port=None, recording=None)</code>","text":"<p>Serve log-data over WebSockets and serve a Rerun web viewer over HTTP.</p> <p>You can also connect to this server with the native viewer using <code>rerun localhost:9090</code>.</p> <p>WARNING: This is an experimental feature.</p> <p>This function returns immediately.</p> <p>Parameters:</p> Name Type Description Default <code>open_browser</code> <code>bool</code> <p>Open the default browser to the viewer.</p> <code>True</code> <code>web_port</code> <code>int | None</code> <p>The port to serve the web viewer on (defaults to 9090).</p> <code>None</code> <code>ws_port</code> <code>int | None</code> <p>The port to serve the WebSocket server on (defaults to 9877)</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/sinks/#rerun.sinks.spawn","title":"<code>def spawn(port=9876, connect=True, recording=None)</code>","text":"<p>Spawn a Rerun Viewer, listening on the given port.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>You can also call rerun.init with a <code>spawn=True</code> argument.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code> <code>connect</code> <code>bool</code> <p>also connect to the viewer and stream logging data to it.</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use if <code>connect = True</code>. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/time/","title":"time.py","text":""},{"location":"package/rerun/time/#rerun.time","title":"<code>rerun.time</code>","text":""},{"location":"package/rerun/time/#rerun.time.set_time_sequence","title":"<code>def set_time_sequence(timeline, sequence, recording=None)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For example: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/time/#rerun.time.set_time_seconds","title":"<code>def set_time_seconds(timeline, seconds, recording=None)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_seconds</code> or <code>rerun.set_time_nanos</code>.</p> <p>For example: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as seconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/time/#rerun.time.set_time_nanos","title":"<code>def set_time_nanos(timeline, nanos, recording=None)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>For example: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>Very large values will automatically be interpreted as nanoseconds since unix epoch (1970-01-01). Small values (less than a few years) will be interpreted as relative some unknown point in time, and will be shown as e.g. <code>+3.132s</code>.</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monotonicity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/time/#rerun.time.reset_time","title":"<code>def reset_time(recording=None)</code>","text":"<p>Clear all timeline information on this thread.</p> <p>This is the same as calling <code>set_time_*</code> with <code>None</code> for all of the active timelines.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>rerun.set_time_nanos</code> or <code>rerun.set_time_seconds</code>.</p> <p>Parameters:</p> Name Type Description Default <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/_rerun2/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2","title":"<code>rerun._rerun2</code>","text":""},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Points2D","title":"<code>class Points2D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 2D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Points2D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points2D([[0, 0], [1, 1]]))\n\n# Log an extra rect to set the view bounds\nrr.log_rect(\"bounds\", [0, 0, 4, 3], rect_format=rr.RectFormat.XCYCWH)\n</code></pre>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.points","title":"<code>points: components.Point2DArray = field(metadata={'component': 'primary'}, converter=components.Point2DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 2D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 2D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points2d.Points2D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Points3D","title":"<code>class Points3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Points3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points3D([[0, 0, 0], [1, 1, 1]]))\n</code></pre>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.points","title":"<code>points: components.Point3DArray = field(metadata={'component': 'primary'}, converter=components.Point3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 3D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 3D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 3D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.points3d.Points3D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Transform3D","title":"<code>class Transform3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D transform.</p>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.Transform3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\nfrom rerun.experimental import dt as rrd\n\nrr.init(\"transform\", spawn=True)\n\norigin = [0, 0, 0]\nbase_vector = [0, 1, 0]\n\nrr.log_arrow(\"base\", origin=origin, vector=base_vector)\n\nrr2.log(\"base/translated\", rr2.Transform3D(rrd.TranslationRotationScale3D(translation=[1, 0, 0])))\n\nrr.log_arrow(\"base/translated\", origin=origin, vector=base_vector)\n\nrr2.log(\n   \"base/rotated_scaled\",\n   rrd.TranslationRotationScale3D(\n       rotation=rrd.RotationAxisAngle(axis=[0, 0, 1], radians=3.14 / 4), scale=rrd.Scale3D(2)\n   ),\n)\n\nrr.log_arrow(\"base/rotated_scaled\", origin=origin, vector=base_vector)\n</code></pre>"},{"location":"package/rerun/_rerun2/__init__/#rerun._rerun2.archetypes.transform3d.Transform3D.transform","title":"<code>transform: components.Transform3DArray = field(metadata={'component': 'primary'}, converter=components.Transform3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transform</p>"},{"location":"package/rerun/_rerun2/_baseclasses/","title":"_baseclasses.py","text":""},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses","title":"<code>rerun._rerun2._baseclasses</code>","text":""},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.Archetype","title":"<code>class Archetype</code>","text":"<p>Base class for all archetypes.</p>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.BaseExtensionType","title":"<code>class BaseExtensionType</code>","text":"<p>         Bases: <code>pa.ExtensionType</code></p> <p>Extension type for datatypes and non-delegating components.</p>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.NamedExtensionArray","title":"<code>class NamedExtensionArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p> <p>Common base class for any extension array that has a name.</p>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.BaseExtensionArray","title":"<code>class BaseExtensionArray</code>","text":"<p>         Bases: <code>NamedExtensionArray</code>, <code>Generic[T]</code></p> <p>Extension array for datatypes and non-delegating components.</p>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.BaseExtensionArray.from_similar","title":"<code>def from_similar(data)</code>  <code>classmethod</code>","text":"<p>Primary method for creating Arrow arrays for components.</p> <p>This method must flexibly accept native data (which comply with type <code>T</code>). Subclasses must provide a type parameter specifying the type of the native data (this is automatically handled by the code generator).</p> <p>The actual creation of the Arrow array is delegated to the <code>_native_to_pa_array()</code> method, which is not implemented by default.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T | None</code> <p>The data to convert into an Arrow array.</p> required <p>Returns:</p> Type Description <code>The Arrow array encapsulating the data.</code>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.BaseDelegatingExtensionType","title":"<code>class BaseDelegatingExtensionType()</code>","text":"<p>         Bases: <code>pa.ExtensionType</code></p> <p>Extension type for delegating components.</p>"},{"location":"package/rerun/_rerun2/_baseclasses/#rerun._rerun2._baseclasses.BaseDelegatingExtensionArray","title":"<code>class BaseDelegatingExtensionArray</code>","text":"<p>         Bases: <code>BaseExtensionArray[T]</code></p> <p>Extension array for delegating components.</p>"},{"location":"package/rerun/_rerun2/_converters/","title":"_converters.py","text":""},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters","title":"<code>rerun._rerun2._converters</code>","text":"<p>Utility converter functions to make attrs and mypy happy.</p> <p>As of version 1.4.1, mypy (and possibly other tooling) doesn't properly recognize converters passed to attrs fields. For example, consider this class:</p> <pre><code>from attrs import define, field\nimport numpy as np\nimport numpy.typing as npt\n\n@define\nclass ClassA:\n    xy: npt.NDArray[np.float32]= field(converter=CONVERTER)\n</code></pre> <p>mypy is only happy if <code>CONVERTER</code> is a regular, properly-typed function. In particular, it rejects both of these correct and more compact alternatives: - <code>lambda data: np.array(data, dtype=np.float32)</code> - <code>functools.partial(np.array, dtype=np.float32)</code></p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_uint8","title":"<code>def to_np_uint8(data)</code>","text":"<p>Convert some datat to a numpy uint8 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_uint16","title":"<code>def to_np_uint16(data)</code>","text":"<p>Convert some datat to a numpy uint16 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_uint32","title":"<code>def to_np_uint32(data)</code>","text":"<p>Convert some datat to a numpy uint32 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_uint64","title":"<code>def to_np_uint64(data)</code>","text":"<p>Convert some datat to a numpy uint64 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_int8","title":"<code>def to_np_int8(data)</code>","text":"<p>Convert some datat to a numpy int8 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_int16","title":"<code>def to_np_int16(data)</code>","text":"<p>Convert some datat to a numpy int16 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_int32","title":"<code>def to_np_int32(data)</code>","text":"<p>Convert some datat to a numpy int32 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_int64","title":"<code>def to_np_int64(data)</code>","text":"<p>Convert some datat to a numpy int64 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_bool","title":"<code>def to_np_bool(data)</code>","text":"<p>Convert some datat to a numpy bool array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_float16","title":"<code>def to_np_float16(data)</code>","text":"<p>Convert some datat to a numpy float16 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_float32","title":"<code>def to_np_float32(data)</code>","text":"<p>Convert some datat to a numpy float32 array.</p>"},{"location":"package/rerun/_rerun2/_converters/#rerun._rerun2._converters.to_np_float64","title":"<code>def to_np_float64(data)</code>","text":"<p>Convert some datat to a numpy float64 array.</p>"},{"location":"package/rerun/_rerun2/log/","title":"log.py","text":""},{"location":"package/rerun/_rerun2/log/#rerun._rerun2.log","title":"<code>rerun._rerun2.log</code>","text":""},{"location":"package/rerun/_rerun2/log/#rerun._rerun2.log.Loggable","title":"<code>Loggable = Union[Archetype, dt.Transform3DLike]</code>  <code>module-attribute</code>","text":"<p>All the things that <code>rr.log()</code> can accept and log.</p>"},{"location":"package/rerun/_rerun2/log/#rerun._rerun2.log.log","title":"<code>def log(entity_path, entity, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the entity in the space hierarchy.</p> required <code>entity</code> <code>Loggable</code> <p>The archetype object representing the entity.</p> required <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the entity will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/_rerun2/archetypes/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes","title":"<code>rerun._rerun2.archetypes</code>","text":""},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Points2D","title":"<code>class Points2D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 2D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Points2D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points2D([[0, 0], [1, 1]]))\n\n# Log an extra rect to set the view bounds\nrr.log_rect(\"bounds\", [0, 0, 4, 3], rect_format=rr.RectFormat.XCYCWH)\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.points","title":"<code>points: components.Point2DArray = field(metadata={'component': 'primary'}, converter=components.Point2DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 2D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 2D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points2d.Points2D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Points3D","title":"<code>class Points3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Points3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points3D([[0, 0, 0], [1, 1, 1]]))\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.points","title":"<code>points: components.Point3DArray = field(metadata={'component': 'primary'}, converter=components.Point3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 3D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 3D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 3D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.points3d.Points3D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Transform3D","title":"<code>class Transform3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D transform.</p>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.Transform3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\nfrom rerun.experimental import dt as rrd\n\nrr.init(\"transform\", spawn=True)\n\norigin = [0, 0, 0]\nbase_vector = [0, 1, 0]\n\nrr.log_arrow(\"base\", origin=origin, vector=base_vector)\n\nrr2.log(\"base/translated\", rr2.Transform3D(rrd.TranslationRotationScale3D(translation=[1, 0, 0])))\n\nrr.log_arrow(\"base/translated\", origin=origin, vector=base_vector)\n\nrr2.log(\n   \"base/rotated_scaled\",\n   rrd.TranslationRotationScale3D(\n       rotation=rrd.RotationAxisAngle(axis=[0, 0, 1], radians=3.14 / 4), scale=rrd.Scale3D(2)\n   ),\n)\n\nrr.log_arrow(\"base/rotated_scaled\", origin=origin, vector=base_vector)\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/__init__/#rerun._rerun2.archetypes.transform3d.Transform3D.transform","title":"<code>transform: components.Transform3DArray = field(metadata={'component': 'primary'}, converter=components.Transform3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transform</p>"},{"location":"package/rerun/_rerun2/archetypes/fuzzy/","title":"fuzzy.py","text":""},{"location":"package/rerun/_rerun2/archetypes/fuzzy/#rerun._rerun2.archetypes.fuzzy","title":"<code>rerun._rerun2.archetypes.fuzzy</code>","text":""},{"location":"package/rerun/_rerun2/archetypes/points2d/","title":"points2d.py","text":""},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d","title":"<code>rerun._rerun2.archetypes.points2d</code>","text":""},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D","title":"<code>class Points2D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 2D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points2D([[0, 0], [1, 1]]))\n\n# Log an extra rect to set the view bounds\nrr.log_rect(\"bounds\", [0, 0, 4, 3], rect_format=rr.RectFormat.XCYCWH)\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.points","title":"<code>points: components.Point2DArray = field(metadata={'component': 'primary'}, converter=components.Point2DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 2D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 2D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/archetypes/points2d/#rerun._rerun2.archetypes.points2d.Points2D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/","title":"points3d.py","text":""},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d","title":"<code>rerun._rerun2.archetypes.points3d</code>","text":""},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D","title":"<code>class Points3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D point cloud with positions and optional colors, radii, labels, etc.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\n\nrr.init(\"points\", spawn=True)\n\nrr2.log(\"simple\", rr2.Points3D([[0, 0, 0], [1, 1, 1]]))\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.points","title":"<code>points: components.Point3DArray = field(metadata={'component': 'primary'}, converter=components.Point3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All the actual 3D points that make up the point cloud.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.radii","title":"<code>radii: components.RadiusArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.RadiusArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional radii for the points, effectively turning them into circles.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.colors","title":"<code>colors: components.ColorArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ColorArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional colors for the points.</p> <p>The colors are interpreted as RGB or RGBA in sRGB gamma-space, As either 0-1 floats or 0-255 integers, with separate alpha.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.labels","title":"<code>labels: components.LabelArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.LabelArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional text labels for the points.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.draw_order","title":"<code>draw_order: components.DrawOrderArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.DrawOrderArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An optional floating point value that specifies the 3D drawing order. Objects with higher values are drawn on top of those with lower values.</p> <p>The default for 3D points is 30.0.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.class_ids","title":"<code>class_ids: components.ClassIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.ClassIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional class Ids for the points.</p> <p>The class ID provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.keypoint_ids","title":"<code>keypoint_ids: components.KeypointIdArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.KeypointIdArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional keypoint IDs for the points, identifying them within a class.</p> <p>If keypoint IDs are passed in but no class IDs were specified, the class ID will default to 0. This is useful to identify points within a single classification (which is identified with <code>class_id</code>). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</p>"},{"location":"package/rerun/_rerun2/archetypes/points3d/#rerun._rerun2.archetypes.points3d.Points3D.instance_keys","title":"<code>instance_keys: components.InstanceKeyArray | None = field(metadata={'component': 'secondary'}, default=None, converter=components.InstanceKeyArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Unique identifiers for each individual point in the batch.</p>"},{"location":"package/rerun/_rerun2/archetypes/transform3d/","title":"transform3d.py","text":""},{"location":"package/rerun/_rerun2/archetypes/transform3d/#rerun._rerun2.archetypes.transform3d","title":"<code>rerun._rerun2.archetypes.transform3d</code>","text":""},{"location":"package/rerun/_rerun2/archetypes/transform3d/#rerun._rerun2.archetypes.transform3d.Transform3D","title":"<code>class Transform3D</code>","text":"<p>         Bases: <code>Archetype</code></p> <p>A 3D transform.</p>"},{"location":"package/rerun/_rerun2/archetypes/transform3d/#rerun._rerun2.archetypes.transform3d.Transform3D--example","title":"Example","text":"<pre><code>import rerun as rr\nimport rerun.experimental as rr2\nfrom rerun.experimental import dt as rrd\n\nrr.init(\"transform\", spawn=True)\n\norigin = [0, 0, 0]\nbase_vector = [0, 1, 0]\n\nrr.log_arrow(\"base\", origin=origin, vector=base_vector)\n\nrr2.log(\"base/translated\", rr2.Transform3D(rrd.TranslationRotationScale3D(translation=[1, 0, 0])))\n\nrr.log_arrow(\"base/translated\", origin=origin, vector=base_vector)\n\nrr2.log(\n   \"base/rotated_scaled\",\n   rrd.TranslationRotationScale3D(\n       rotation=rrd.RotationAxisAngle(axis=[0, 0, 1], radians=3.14 / 4), scale=rrd.Scale3D(2)\n   ),\n)\n\nrr.log_arrow(\"base/rotated_scaled\", origin=origin, vector=base_vector)\n</code></pre>"},{"location":"package/rerun/_rerun2/archetypes/transform3d/#rerun._rerun2.archetypes.transform3d.Transform3D.transform","title":"<code>transform: components.Transform3DArray = field(metadata={'component': 'primary'}, converter=components.Transform3DArray.from_similar)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transform</p>"},{"location":"package/rerun/_rerun2/archetypes/_overrides/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/archetypes/_overrides/__init__/#rerun._rerun2.archetypes._overrides","title":"<code>rerun._rerun2.archetypes._overrides</code>","text":""},{"location":"package/rerun/_rerun2/components/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components","title":"<code>rerun._rerun2.components</code>","text":""},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.Label","title":"<code>class Label</code>","text":"<p>A String label component.</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.ClassId","title":"<code>class ClassId</code>","text":"<p>A 16-bit ID representing a type of semantic class.</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.Color","title":"<code>class Color</code>","text":"<p>An RGBA color tuple with unmultiplied/separate alpha, in sRGB gamma space with linear alpha.</p> <p>Float colors are assumed to be in 0-1 gamma sRGB space. All other colors are assumed to be in 0-255 gamma sRGB space. If there is an alpha, we assume it is in linear space, and separate (NOT pre-multiplied).</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.DrawOrder","title":"<code>class DrawOrder</code>","text":"<p>Draw order used for the display order of 2D elements.</p> <p>Higher values are drawn on top of lower values. An entity can have only a single draw order component. Within an entity draw order is governed by the order of the components.</p> <p>Draw order for entities with the same draw order is generally undefined.</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.InstanceKey","title":"<code>class InstanceKey</code>","text":"<p>A unique numeric identifier for each individual instance within a batch.</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.KeypointId","title":"<code>class KeypointId</code>","text":"<p>A 16-bit ID representing a type of semantic keypoint within a class.</p> <p><code>KeypointId</code>s are only meaningful within the context of a <code>rerun.components.ClassDescription</code>.</p> <p>Used to look up an <code>rerun.components.AnnotationInfo</code> for a Keypoint within the [<code>rerun.components.AnnotationContext</code>].</p>"},{"location":"package/rerun/_rerun2/components/__init__/#rerun._rerun2.components.Radius","title":"<code>class Radius</code>","text":"<p>A Radius component.</p>"},{"location":"package/rerun/_rerun2/components/class_id/","title":"class_id.py","text":""},{"location":"package/rerun/_rerun2/components/class_id/#rerun._rerun2.components.class_id","title":"<code>rerun._rerun2.components.class_id</code>","text":""},{"location":"package/rerun/_rerun2/components/class_id/#rerun._rerun2.components.class_id.ClassId","title":"<code>class ClassId</code>","text":"<p>A 16-bit ID representing a type of semantic class.</p>"},{"location":"package/rerun/_rerun2/components/color/","title":"color.py","text":""},{"location":"package/rerun/_rerun2/components/color/#rerun._rerun2.components.color","title":"<code>rerun._rerun2.components.color</code>","text":""},{"location":"package/rerun/_rerun2/components/color/#rerun._rerun2.components.color.Color","title":"<code>class Color</code>","text":"<p>An RGBA color tuple with unmultiplied/separate alpha, in sRGB gamma space with linear alpha.</p> <p>Float colors are assumed to be in 0-1 gamma sRGB space. All other colors are assumed to be in 0-255 gamma sRGB space. If there is an alpha, we assume it is in linear space, and separate (NOT pre-multiplied).</p>"},{"location":"package/rerun/_rerun2/components/draw_order/","title":"draw_order.py","text":""},{"location":"package/rerun/_rerun2/components/draw_order/#rerun._rerun2.components.draw_order","title":"<code>rerun._rerun2.components.draw_order</code>","text":""},{"location":"package/rerun/_rerun2/components/draw_order/#rerun._rerun2.components.draw_order.DrawOrder","title":"<code>class DrawOrder</code>","text":"<p>Draw order used for the display order of 2D elements.</p> <p>Higher values are drawn on top of lower values. An entity can have only a single draw order component. Within an entity draw order is governed by the order of the components.</p> <p>Draw order for entities with the same draw order is generally undefined.</p>"},{"location":"package/rerun/_rerun2/components/fuzzy/","title":"fuzzy.py","text":""},{"location":"package/rerun/_rerun2/components/fuzzy/#rerun._rerun2.components.fuzzy","title":"<code>rerun._rerun2.components.fuzzy</code>","text":""},{"location":"package/rerun/_rerun2/components/instance_key/","title":"instance_key.py","text":""},{"location":"package/rerun/_rerun2/components/instance_key/#rerun._rerun2.components.instance_key","title":"<code>rerun._rerun2.components.instance_key</code>","text":""},{"location":"package/rerun/_rerun2/components/instance_key/#rerun._rerun2.components.instance_key.InstanceKey","title":"<code>class InstanceKey</code>","text":"<p>A unique numeric identifier for each individual instance within a batch.</p>"},{"location":"package/rerun/_rerun2/components/keypoint_id/","title":"keypoint_id.py","text":""},{"location":"package/rerun/_rerun2/components/keypoint_id/#rerun._rerun2.components.keypoint_id","title":"<code>rerun._rerun2.components.keypoint_id</code>","text":""},{"location":"package/rerun/_rerun2/components/keypoint_id/#rerun._rerun2.components.keypoint_id.KeypointId","title":"<code>class KeypointId</code>","text":"<p>A 16-bit ID representing a type of semantic keypoint within a class.</p> <p><code>KeypointId</code>s are only meaningful within the context of a <code>rerun.components.ClassDescription</code>.</p> <p>Used to look up an <code>rerun.components.AnnotationInfo</code> for a Keypoint within the [<code>rerun.components.AnnotationContext</code>].</p>"},{"location":"package/rerun/_rerun2/components/label/","title":"label.py","text":""},{"location":"package/rerun/_rerun2/components/label/#rerun._rerun2.components.label","title":"<code>rerun._rerun2.components.label</code>","text":""},{"location":"package/rerun/_rerun2/components/label/#rerun._rerun2.components.label.Label","title":"<code>class Label</code>","text":"<p>A String label component.</p>"},{"location":"package/rerun/_rerun2/components/point2d/","title":"point2d.py","text":""},{"location":"package/rerun/_rerun2/components/point2d/#rerun._rerun2.components.point2d","title":"<code>rerun._rerun2.components.point2d</code>","text":""},{"location":"package/rerun/_rerun2/components/point3d/","title":"point3d.py","text":""},{"location":"package/rerun/_rerun2/components/point3d/#rerun._rerun2.components.point3d","title":"<code>rerun._rerun2.components.point3d</code>","text":""},{"location":"package/rerun/_rerun2/components/radius/","title":"radius.py","text":""},{"location":"package/rerun/_rerun2/components/radius/#rerun._rerun2.components.radius","title":"<code>rerun._rerun2.components.radius</code>","text":""},{"location":"package/rerun/_rerun2/components/radius/#rerun._rerun2.components.radius.Radius","title":"<code>class Radius</code>","text":"<p>A Radius component.</p>"},{"location":"package/rerun/_rerun2/components/transform3d/","title":"transform3d.py","text":""},{"location":"package/rerun/_rerun2/components/transform3d/#rerun._rerun2.components.transform3d","title":"<code>rerun._rerun2.components.transform3d</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/__init__/#rerun._rerun2.components._overrides","title":"<code>rerun._rerun2.components._overrides</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/class_id/","title":"class_id.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/class_id/#rerun._rerun2.components._overrides.class_id","title":"<code>rerun._rerun2.components._overrides.class_id</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/color/","title":"color.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/color/#rerun._rerun2.components._overrides.color","title":"<code>rerun._rerun2.components._overrides.color</code>","text":"<p>Overrides for <code>Color</code> component.</p> <p>Possible input for <code>Color</code>: - Sequence[int]: interpreted as rgb or rgba values in 0-255 range - numpy array: interpreted as rgb or rgba values, range depending on dtype - anything else (int or convertible to int): interpreted as a 32-bit packed rgba value</p> <p>Possible inputs for <code>ColorArray.from_similar()</code>: - a single <code>Color</code> instance - a sequence of <code>Color</code> instances - Nx3 or Nx4 numpy array, range depending on dtype</p>"},{"location":"package/rerun/_rerun2/components/_overrides/draw_order/","title":"draw_order.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/draw_order/#rerun._rerun2.components._overrides.draw_order","title":"<code>rerun._rerun2.components._overrides.draw_order</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/instance_key/","title":"instance_key.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/instance_key/#rerun._rerun2.components._overrides.instance_key","title":"<code>rerun._rerun2.components._overrides.instance_key</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/keypoint_id/","title":"keypoint_id.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/keypoint_id/#rerun._rerun2.components._overrides.keypoint_id","title":"<code>rerun._rerun2.components._overrides.keypoint_id</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/label/","title":"label.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/label/#rerun._rerun2.components._overrides.label","title":"<code>rerun._rerun2.components._overrides.label</code>","text":""},{"location":"package/rerun/_rerun2/components/_overrides/radius/","title":"radius.py","text":""},{"location":"package/rerun/_rerun2/components/_overrides/radius/#rerun._rerun2.components._overrides.radius","title":"<code>rerun._rerun2.components._overrides.radius</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes","title":"<code>rerun._rerun2.datatypes</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Angle","title":"<code>class Angle(*args, **kwargs)</code>","text":"<p>Angle in either radians or degrees.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.angle.Angle.inner","title":"<code>inner: float = field(converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Radians (float):     3D rotation angle in radians. Only one of <code>degrees</code> or <code>radians</code> should be set.</p> <p>Degrees (float):     3D rotation angle in degrees. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Point2D","title":"<code>class Point2D</code>","text":"<p>A point in 2D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Point3D","title":"<code>class Point3D</code>","text":"<p>A point in 3D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Rotation3D","title":"<code>class Rotation3D</code>","text":"<p>A 3D rotation.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.rotation3d.Rotation3D.inner","title":"<code>inner: datatypes.Quaternion | datatypes.RotationAxisAngle = field(converter=rotation3d_inner_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Quaternion (datatypes.Quaternion):     Rotation defined by a quaternion.</p> <p>AxisAngle (datatypes.RotationAxisAngle):     Rotation defined with an axis and an angle.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Scale3D","title":"<code>class Scale3D</code>","text":"<p>3D scaling factor, part of a transform representation.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Scale3D--example","title":"Example","text":"<pre><code># uniform scaling\nscale = rr.dt.Scale3D(3.)\n\n# non-uniform scaling\nscale = rr.dt.Scale3D([1, 1, -1])\nscale = rr.dt.Scale3D(rr.dt.Vec3D([1, 1, -1]))\n</code></pre>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.scale3d.Scale3D.inner","title":"<code>inner: datatypes.Vec3D | float = field(converter=scale3d_inner_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ThreeD (datatypes.Vec3D):     Individual scaling factors for each axis, distorting the original object.</p> <p>Uniform (float):     Uniform scaling factor along all axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Transform3D","title":"<code>class Transform3D</code>","text":"<p>Representation of a 3D affine transform.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.transform3d.Transform3D.inner","title":"<code>inner: datatypes.TranslationAndMat3x3 | datatypes.TranslationRotationScale3D = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TranslationAndMat3x3 (datatypes.TranslationAndMat3x3):</p> <p>TranslationRotationScale (datatypes.TranslationRotationScale3D):</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Mat3x3","title":"<code>class Mat3x3</code>","text":"<p>A 3x3 column-major Matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Mat4x4","title":"<code>class Mat4x4</code>","text":"<p>A 4x4 column-major Matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Quaternion","title":"<code>class Quaternion(*args, **kwargs)</code>","text":"<p>A Quaternion represented by 4 real numbers.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Vec2D","title":"<code>class Vec2D</code>","text":"<p>A vector in 2D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Vec3D","title":"<code>class Vec3D</code>","text":"<p>A vector in 3D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.Vec4D","title":"<code>class Vec4D</code>","text":"<p>A vector in 4D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.RotationAxisAngle","title":"<code>class RotationAxisAngle</code>","text":"<p>3D rotation represented by a rotation around a given axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.rotation_axis_angle.RotationAxisAngle.axis","title":"<code>axis: datatypes.Vec3D = field(converter=_rotationaxisangle_axis_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Axis to rotate around.</p> <p>This is not required to be normalized. If normalization fails (typically because the vector is length zero), the rotation is silently ignored.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.rotation_axis_angle.RotationAxisAngle.angle","title":"<code>angle: datatypes.Angle = field(converter=rotationaxisangle_angle_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How much to rotate around the axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.TranslationAndMat3x3","title":"<code>class TranslationAndMat3x3(*args, **kwargs)</code>","text":"<p>Representation of an affine transform via a 3x3 affine matrix paired with a translation.</p> <p>First applies the matrix, then the translation.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.from_parent","title":"<code>from_parent: bool = field(converter=bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the transform maps from the parent space to the space where the transform was logged. Otherwise, the transform maps from the space to its parent.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.translation","title":"<code>translation: datatypes.Vec3D | None = field(default=None, converter=_translationandmat3x3_translation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation, applied after the matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.matrix","title":"<code>matrix: datatypes.Mat3x3 | None = field(default=None, converter=_translationandmat3x3_matrix_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3x3 matrix for scale, rotation &amp; shear.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.TranslationRotationScale3D","title":"<code>class TranslationRotationScale3D(*args, **kwargs)</code>","text":"<p>Representation of an affine transform via separate translation, rotation &amp; scale.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.from_parent","title":"<code>from_parent: bool = field(converter=bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the transform maps from the parent space to the space where the transform was logged. Otherwise, the transform maps from the space to its parent.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.translation","title":"<code>translation: datatypes.Vec3D | None = field(default=None, converter=_translationrotationscale3d_translation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.rotation","title":"<code>rotation: datatypes.Rotation3D | None = field(default=None, converter=_translationrotationscale3d_rotation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, applied second.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.scale","title":"<code>scale: datatypes.Scale3D | None = field(default=None, converter=_translationrotationscale3d_scale_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D scale, applied first.</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.AffixFuzzer3","title":"<code>class AffixFuzzer3</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer3.inner","title":"<code>inner: float | list[datatypes.AffixFuzzer1] | npt.NDArray[np.float32] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>degrees (float):</p> <p>radians (float):</p> <p>craziness (list[datatypes.AffixFuzzer1]):</p> <p>fixed_size_shenanigans (npt.NDArray[np.float32]):</p>"},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.AffixFuzzer4","title":"<code>class AffixFuzzer4</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/__init__/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer4.inner","title":"<code>inner: datatypes.AffixFuzzer3 | list[datatypes.AffixFuzzer3] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>single_required (datatypes.AffixFuzzer3):</p> <p>many_required (list[datatypes.AffixFuzzer3]):</p> <p>many_optional (list[datatypes.AffixFuzzer3]):</p>"},{"location":"package/rerun/_rerun2/datatypes/angle/","title":"angle.py","text":""},{"location":"package/rerun/_rerun2/datatypes/angle/#rerun._rerun2.datatypes.angle","title":"<code>rerun._rerun2.datatypes.angle</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/angle/#rerun._rerun2.datatypes.angle.Angle","title":"<code>class Angle(*args, **kwargs)</code>","text":"<p>Angle in either radians or degrees.</p>"},{"location":"package/rerun/_rerun2/datatypes/angle/#rerun._rerun2.datatypes.angle.Angle.inner","title":"<code>inner: float = field(converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Radians (float):     3D rotation angle in radians. Only one of <code>degrees</code> or <code>radians</code> should be set.</p> <p>Degrees (float):     3D rotation angle in degrees. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/_rerun2/datatypes/fuzzy/","title":"fuzzy.py","text":""},{"location":"package/rerun/_rerun2/datatypes/fuzzy/#rerun._rerun2.datatypes.fuzzy","title":"<code>rerun._rerun2.datatypes.fuzzy</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/fuzzy/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer3","title":"<code>class AffixFuzzer3</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/fuzzy/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer3.inner","title":"<code>inner: float | list[datatypes.AffixFuzzer1] | npt.NDArray[np.float32] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>degrees (float):</p> <p>radians (float):</p> <p>craziness (list[datatypes.AffixFuzzer1]):</p> <p>fixed_size_shenanigans (npt.NDArray[np.float32]):</p>"},{"location":"package/rerun/_rerun2/datatypes/fuzzy/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer4","title":"<code>class AffixFuzzer4</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/fuzzy/#rerun._rerun2.datatypes.fuzzy.AffixFuzzer4.inner","title":"<code>inner: datatypes.AffixFuzzer3 | list[datatypes.AffixFuzzer3] = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>single_required (datatypes.AffixFuzzer3):</p> <p>many_required (list[datatypes.AffixFuzzer3]):</p> <p>many_optional (list[datatypes.AffixFuzzer3]):</p>"},{"location":"package/rerun/_rerun2/datatypes/mat3x3/","title":"mat3x3.py","text":""},{"location":"package/rerun/_rerun2/datatypes/mat3x3/#rerun._rerun2.datatypes.mat3x3","title":"<code>rerun._rerun2.datatypes.mat3x3</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/mat3x3/#rerun._rerun2.datatypes.mat3x3.Mat3x3","title":"<code>class Mat3x3</code>","text":"<p>A 3x3 column-major Matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/mat4x4/","title":"mat4x4.py","text":""},{"location":"package/rerun/_rerun2/datatypes/mat4x4/#rerun._rerun2.datatypes.mat4x4","title":"<code>rerun._rerun2.datatypes.mat4x4</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/mat4x4/#rerun._rerun2.datatypes.mat4x4.Mat4x4","title":"<code>class Mat4x4</code>","text":"<p>A 4x4 column-major Matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/point2d/","title":"point2d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/point2d/#rerun._rerun2.datatypes.point2d","title":"<code>rerun._rerun2.datatypes.point2d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/point2d/#rerun._rerun2.datatypes.point2d.Point2D","title":"<code>class Point2D</code>","text":"<p>A point in 2D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/point3d/","title":"point3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/point3d/#rerun._rerun2.datatypes.point3d","title":"<code>rerun._rerun2.datatypes.point3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/point3d/#rerun._rerun2.datatypes.point3d.Point3D","title":"<code>class Point3D</code>","text":"<p>A point in 3D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/_rerun2/datatypes/quaternion/#rerun._rerun2.datatypes.quaternion","title":"<code>rerun._rerun2.datatypes.quaternion</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/quaternion/#rerun._rerun2.datatypes.quaternion.Quaternion","title":"<code>class Quaternion(*args, **kwargs)</code>","text":"<p>A Quaternion represented by 4 real numbers.</p>"},{"location":"package/rerun/_rerun2/datatypes/rotation3d/","title":"rotation3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/rotation3d/#rerun._rerun2.datatypes.rotation3d","title":"<code>rerun._rerun2.datatypes.rotation3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/rotation3d/#rerun._rerun2.datatypes.rotation3d.Rotation3D","title":"<code>class Rotation3D</code>","text":"<p>A 3D rotation.</p>"},{"location":"package/rerun/_rerun2/datatypes/rotation3d/#rerun._rerun2.datatypes.rotation3d.Rotation3D.inner","title":"<code>inner: datatypes.Quaternion | datatypes.RotationAxisAngle = field(converter=rotation3d_inner_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Quaternion (datatypes.Quaternion):     Rotation defined by a quaternion.</p> <p>AxisAngle (datatypes.RotationAxisAngle):     Rotation defined with an axis and an angle.</p>"},{"location":"package/rerun/_rerun2/datatypes/rotation_axis_angle/","title":"rotation_axis_angle.py","text":""},{"location":"package/rerun/_rerun2/datatypes/rotation_axis_angle/#rerun._rerun2.datatypes.rotation_axis_angle","title":"<code>rerun._rerun2.datatypes.rotation_axis_angle</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/rotation_axis_angle/#rerun._rerun2.datatypes.rotation_axis_angle.RotationAxisAngle","title":"<code>class RotationAxisAngle</code>","text":"<p>3D rotation represented by a rotation around a given axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/rotation_axis_angle/#rerun._rerun2.datatypes.rotation_axis_angle.RotationAxisAngle.axis","title":"<code>axis: datatypes.Vec3D = field(converter=_rotationaxisangle_axis_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Axis to rotate around.</p> <p>This is not required to be normalized. If normalization fails (typically because the vector is length zero), the rotation is silently ignored.</p>"},{"location":"package/rerun/_rerun2/datatypes/rotation_axis_angle/#rerun._rerun2.datatypes.rotation_axis_angle.RotationAxisAngle.angle","title":"<code>angle: datatypes.Angle = field(converter=rotationaxisangle_angle_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How much to rotate around the axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/scale3d/","title":"scale3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/scale3d/#rerun._rerun2.datatypes.scale3d","title":"<code>rerun._rerun2.datatypes.scale3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/scale3d/#rerun._rerun2.datatypes.scale3d.Scale3D","title":"<code>class Scale3D</code>","text":"<p>3D scaling factor, part of a transform representation.</p>"},{"location":"package/rerun/_rerun2/datatypes/scale3d/#rerun._rerun2.datatypes.scale3d.Scale3D--example","title":"Example","text":"<pre><code># uniform scaling\nscale = rr.dt.Scale3D(3.)\n\n# non-uniform scaling\nscale = rr.dt.Scale3D([1, 1, -1])\nscale = rr.dt.Scale3D(rr.dt.Vec3D([1, 1, -1]))\n</code></pre>"},{"location":"package/rerun/_rerun2/datatypes/scale3d/#rerun._rerun2.datatypes.scale3d.Scale3D.inner","title":"<code>inner: datatypes.Vec3D | float = field(converter=scale3d_inner_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ThreeD (datatypes.Vec3D):     Individual scaling factors for each axis, distorting the original object.</p> <p>Uniform (float):     Uniform scaling factor along all axis.</p>"},{"location":"package/rerun/_rerun2/datatypes/transform3d/","title":"transform3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/transform3d/#rerun._rerun2.datatypes.transform3d","title":"<code>rerun._rerun2.datatypes.transform3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/transform3d/#rerun._rerun2.datatypes.transform3d.Transform3D","title":"<code>class Transform3D</code>","text":"<p>Representation of a 3D affine transform.</p>"},{"location":"package/rerun/_rerun2/datatypes/transform3d/#rerun._rerun2.datatypes.transform3d.Transform3D.inner","title":"<code>inner: datatypes.TranslationAndMat3x3 | datatypes.TranslationRotationScale3D = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TranslationAndMat3x3 (datatypes.TranslationAndMat3x3):</p> <p>TranslationRotationScale (datatypes.TranslationRotationScale3D):</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/","title":"translation_and_mat3x3.py","text":""},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/#rerun._rerun2.datatypes.translation_and_mat3x3","title":"<code>rerun._rerun2.datatypes.translation_and_mat3x3</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3","title":"<code>class TranslationAndMat3x3(*args, **kwargs)</code>","text":"<p>Representation of an affine transform via a 3x3 affine matrix paired with a translation.</p> <p>First applies the matrix, then the translation.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.from_parent","title":"<code>from_parent: bool = field(converter=bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the transform maps from the parent space to the space where the transform was logged. Otherwise, the transform maps from the space to its parent.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.translation","title":"<code>translation: datatypes.Vec3D | None = field(default=None, converter=_translationandmat3x3_translation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation, applied after the matrix.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_and_mat3x3/#rerun._rerun2.datatypes.translation_and_mat3x3.TranslationAndMat3x3.matrix","title":"<code>matrix: datatypes.Mat3x3 | None = field(default=None, converter=_translationandmat3x3_matrix_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3x3 matrix for scale, rotation &amp; shear.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/","title":"translation_rotation_scale3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d","title":"<code>rerun._rerun2.datatypes.translation_rotation_scale3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D","title":"<code>class TranslationRotationScale3D(*args, **kwargs)</code>","text":"<p>Representation of an affine transform via separate translation, rotation &amp; scale.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.from_parent","title":"<code>from_parent: bool = field(converter=bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, the transform maps from the parent space to the space where the transform was logged. Otherwise, the transform maps from the space to its parent.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.translation","title":"<code>translation: datatypes.Vec3D | None = field(default=None, converter=_translationrotationscale3d_translation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.rotation","title":"<code>rotation: datatypes.Rotation3D | None = field(default=None, converter=_translationrotationscale3d_rotation_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, applied second.</p>"},{"location":"package/rerun/_rerun2/datatypes/translation_rotation_scale3d/#rerun._rerun2.datatypes.translation_rotation_scale3d.TranslationRotationScale3D.scale","title":"<code>scale: datatypes.Scale3D | None = field(default=None, converter=_translationrotationscale3d_scale_converter)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D scale, applied first.</p>"},{"location":"package/rerun/_rerun2/datatypes/vec2d/","title":"vec2d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/vec2d/#rerun._rerun2.datatypes.vec2d","title":"<code>rerun._rerun2.datatypes.vec2d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/vec2d/#rerun._rerun2.datatypes.vec2d.Vec2D","title":"<code>class Vec2D</code>","text":"<p>A vector in 2D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/vec3d/","title":"vec3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/vec3d/#rerun._rerun2.datatypes.vec3d","title":"<code>rerun._rerun2.datatypes.vec3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/vec3d/#rerun._rerun2.datatypes.vec3d.Vec3D","title":"<code>class Vec3D</code>","text":"<p>A vector in 3D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/vec4d/","title":"vec4d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/vec4d/#rerun._rerun2.datatypes.vec4d","title":"<code>rerun._rerun2.datatypes.vec4d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/vec4d/#rerun._rerun2.datatypes.vec4d.Vec4D","title":"<code>class Vec4D</code>","text":"<p>A vector in 4D space.</p>"},{"location":"package/rerun/_rerun2/datatypes/_overrides/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/__init__/#rerun._rerun2.datatypes._overrides","title":"<code>rerun._rerun2.datatypes._overrides</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/angle/","title":"angle.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/angle/#rerun._rerun2.datatypes._overrides.angle","title":"<code>rerun._rerun2.datatypes._overrides.angle</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/converters/","title":"converters.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/converters/#rerun._rerun2.datatypes._overrides.converters","title":"<code>rerun._rerun2.datatypes._overrides.converters</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/matnxn/","title":"matnxn.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/matnxn/#rerun._rerun2.datatypes._overrides.matnxn","title":"<code>rerun._rerun2.datatypes._overrides.matnxn</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/point2d/","title":"point2d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/point2d/#rerun._rerun2.datatypes._overrides.point2d","title":"<code>rerun._rerun2.datatypes._overrides.point2d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/point3d/","title":"point3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/point3d/#rerun._rerun2.datatypes._overrides.point3d","title":"<code>rerun._rerun2.datatypes._overrides.point3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/quaternion/#rerun._rerun2.datatypes._overrides.quaternion","title":"<code>rerun._rerun2.datatypes._overrides.quaternion</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/rotation3d/","title":"rotation3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/rotation3d/#rerun._rerun2.datatypes._overrides.rotation3d","title":"<code>rerun._rerun2.datatypes._overrides.rotation3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/rotation_axis_angle/","title":"rotation_axis_angle.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/rotation_axis_angle/#rerun._rerun2.datatypes._overrides.rotation_axis_angle","title":"<code>rerun._rerun2.datatypes._overrides.rotation_axis_angle</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/scale3d/","title":"scale3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/scale3d/#rerun._rerun2.datatypes._overrides.scale3d","title":"<code>rerun._rerun2.datatypes._overrides.scale3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/transform3d/","title":"transform3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/transform3d/#rerun._rerun2.datatypes._overrides.transform3d","title":"<code>rerun._rerun2.datatypes._overrides.transform3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/translation_and_mat3x3/","title":"translation_and_mat3x3.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/translation_and_mat3x3/#rerun._rerun2.datatypes._overrides.translation_and_mat3x3","title":"<code>rerun._rerun2.datatypes._overrides.translation_and_mat3x3</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/translation_rotation_scale3d/","title":"translation_rotation_scale3d.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/translation_rotation_scale3d/#rerun._rerun2.datatypes._overrides.translation_rotation_scale3d","title":"<code>rerun._rerun2.datatypes._overrides.translation_rotation_scale3d</code>","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/vecxd/","title":"vecxd.py","text":""},{"location":"package/rerun/_rerun2/datatypes/_overrides/vecxd/#rerun._rerun2.datatypes._overrides.vecxd","title":"<code>rerun._rerun2.datatypes._overrides.vecxd</code>","text":""},{"location":"package/rerun/components/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/components/__init__/#rerun.components","title":"<code>rerun.components</code>","text":"<p>The components package defines Python wrapper types for common registered Rerun components.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.ComponentTypeFactory","title":"<code>def ComponentTypeFactory(name, array_cls, field)</code>","text":"<p>Build a component type wrapper.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.union_discriminant_type","title":"<code>def union_discriminant_type(data_type, discriminant)</code>","text":"<p>Return the data type of the given discriminant.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.build_dense_union","title":"<code>def build_dense_union(data_type, discriminant, child)</code>","text":"<p>Build a dense UnionArray given the <code>data_type</code>, a discriminant, and the child value array.</p> <p>If the discriminant string doesn't match any possible value, a <code>ValueError</code> is raised.</p> <p>WARNING: Because of #705, each new union component needs to be handled in <code>array_to_rust</code> on the native side.</p>"},{"location":"package/rerun/components/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation","title":"<code>rerun.components.annotation</code>","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray","title":"<code>class ClassIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ClassIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray","title":"<code>class KeypointIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>KeypointIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow","title":"<code>rerun.components.arrow</code>","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray","title":"<code>class Arrow3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray.from_numpy","title":"<code>def from_numpy(origins, vectors)</code>","text":"<p>Build a <code>Arrow3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/box/","title":"box.py","text":""},{"location":"package/rerun/components/box/#rerun.components.box","title":"<code>rerun.components.box</code>","text":""},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray","title":"<code>class Box3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Box3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/color/","title":"color.py","text":""},{"location":"package/rerun/components/color/#rerun.components.color","title":"<code>rerun.components.color</code>","text":""},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray","title":"<code>class ColorRGBAArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ColorRGBAArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/disconnected_space/","title":"disconnected_space.py","text":""},{"location":"package/rerun/components/disconnected_space/#rerun.components.disconnected_space","title":"<code>rerun.components.disconnected_space</code>","text":""},{"location":"package/rerun/components/disconnected_space/#rerun.components.disconnected_space.DisconnectedSpaceArray","title":"<code>class DisconnectedSpaceArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/disconnected_space/#rerun.components.disconnected_space.DisconnectedSpaceArray.single","title":"<code>def single()</code>  <code>classmethod</code>","text":"<p>Build a <code>DisconnectedSpaceArray</code> with a single element.</p>"},{"location":"package/rerun/components/draw_order/","title":"draw_order.py","text":""},{"location":"package/rerun/components/draw_order/#rerun.components.draw_order","title":"<code>rerun.components.draw_order</code>","text":""},{"location":"package/rerun/components/instance/","title":"instance.py","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance","title":"<code>rerun.components.instance</code>","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray","title":"<code>class InstanceArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>InstanceArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/label/","title":"label.py","text":""},{"location":"package/rerun/components/label/#rerun.components.label","title":"<code>rerun.components.label</code>","text":""},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray","title":"<code>class LabelArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray.new","title":"<code>def new(labels)</code>","text":"<p>Build a <code>LabelArray</code> from a sequence of str.</p>"},{"location":"package/rerun/components/linestrip/","title":"linestrip.py","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip","title":"<code>rerun.components.linestrip</code>","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray","title":"<code>class LineStrip2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip2DArray</code> from an array of [Nx2 numpy array].</p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray","title":"<code>class LineStrip3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip3DArray</code> from an array of [Nx3 numpy array].</p>"},{"location":"package/rerun/components/pinhole/","title":"pinhole.py","text":""},{"location":"package/rerun/components/pinhole/#rerun.components.pinhole","title":"<code>rerun.components.pinhole</code>","text":""},{"location":"package/rerun/components/pinhole/#rerun.components.pinhole.Pinhole","title":"<code>class Pinhole</code>  <code>dataclass</code>","text":"<p>Camera perspective projection (a.k.a. intrinsics).</p>"},{"location":"package/rerun/components/pinhole/#rerun.components.pinhole.PinholeArray","title":"<code>class PinholeArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/pinhole/#rerun.components.pinhole.PinholeArray.from_pinhole","title":"<code>def from_pinhole(pinhole)</code>","text":"<p>Build a <code>PinholeArray</code> from a single pinhole.</p>"},{"location":"package/rerun/components/point/","title":"point.py","text":""},{"location":"package/rerun/components/point/#rerun.components.point","title":"<code>rerun.components.point</code>","text":""},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray","title":"<code>class Point2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray","title":"<code>class Point3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion","title":"<code>rerun.components.quaternion</code>","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.Quaternion","title":"<code>class Quaternion(*, xyzw)</code>","text":"<p>3D rotation expressed via a Quaternion.</p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.Quaternion.xyzw","title":"<code>xyzw: npt.ArrayLike = xyzw</code>  <code>instance-attribute</code>","text":"<p>Quaternion given as a 4-element array of floats in the order (x, y, z, w).</p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray","title":"<code>class QuaternionArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>QuaternionArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/radius/","title":"radius.py","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius","title":"<code>rerun.components.radius</code>","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray","title":"<code>class RadiusArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>RadiusArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/rect2d/","title":"rect2d.py","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d","title":"<code>rerun.components.rect2d</code>","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray","title":"<code>class Rect2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray.from_numpy_and_format","title":"<code>def from_numpy_and_format(array, rect_format)</code>","text":"<p>Build a <code>Rect2DArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar","title":"<code>rerun.components.scalar</code>","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray","title":"<code>class ScalarArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ScalarArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray","title":"<code>class ScalarPlotPropsArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray.from_props","title":"<code>def from_props(props)</code>","text":"<p>Build a <code>ScalarPlotPropsArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor","title":"<code>rerun.components.tensor</code>","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray","title":"<code>class TensorArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray.from_numpy","title":"<code>def from_numpy(array, names=None, meaning=None, meter=None)</code>","text":"<p>Build a <code>TensorArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/text_entry/","title":"text_entry.py","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry","title":"<code>rerun.components.text_entry</code>","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray","title":"<code>class TextEntryArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray.from_bodies_and_levels","title":"<code>def from_bodies_and_levels(text_entries)</code>","text":"<p>Build a <code>TextEntryArray</code> from a sequence of text bodies and log levels.</p> <p>log levels recommended to be one of: * \"CRITICAL\" * \"ERROR\" * \"WARN\" * \"INFO\" * \"DEBUG\" * \"TRACE\"</p>"},{"location":"package/rerun/components/transform3d/","title":"transform3d.py","text":""},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d","title":"<code>rerun.components.transform3d</code>","text":""},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Quaternion","title":"<code>class Quaternion(*, xyzw)</code>","text":"<p>3D rotation expressed via a Quaternion.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.quaternion.Quaternion.xyzw","title":"<code>xyzw: npt.ArrayLike = xyzw</code>  <code>instance-attribute</code>","text":"<p>Quaternion given as a 4-element array of floats in the order (x, y, z, w).</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Transform3D","title":"<code>class Transform3D</code>  <code>dataclass</code>","text":"<p>An affine transform between two 3D spaces, represented in a given direction.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Transform3D.transform","title":"<code>transform: TranslationAndMat3 | TranslationRotationScale3D</code>  <code>instance-attribute</code>","text":"<p>Representation of a 3D transform.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Transform3D.from_parent","title":"<code>from_parent: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, the transform maps from the parent space to the child space. Otherwise, the transform maps from the child space to the parent space.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationAndMat3","title":"<code>class TranslationAndMat3</code>  <code>dataclass</code>","text":"<p>Representation of a affine transform via a 3x3 translation matrix paired with a translation.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationAndMat3.translation","title":"<code>translation: npt.ArrayLike | Translation3D | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied after the matrix. Uses (0, 0, 0) if not set.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationAndMat3.matrix","title":"<code>matrix: npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The row-major 3x3 matrix for scale, rotation &amp; skew matrix. Uses identity if not set.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Rigid3D","title":"<code>class Rigid3D</code>  <code>dataclass</code>","text":"<p>Representation of a rigid transform via separate translation &amp; rotation.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Rigid3D.translation","title":"<code>translation: Translation3D | npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Rigid3D.rotation","title":"<code>rotation: Quaternion | RotationAxisAngle | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, represented as a quaternion or axis + angle, applied second.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationRotationScale3D","title":"<code>class TranslationRotationScale3D</code>  <code>dataclass</code>","text":"<p>Representation of an affine transform via separate translation, rotation &amp; scale.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationRotationScale3D.translation","title":"<code>translation: Translation3D | npt.ArrayLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D translation vector, applied last.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationRotationScale3D.rotation","title":"<code>rotation: Quaternion | RotationAxisAngle | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation, represented as a quaternion or axis + angle, applied second.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.TranslationRotationScale3D.scale","title":"<code>scale: Scale3D | npt.ArrayLike | float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D scaling either a 3D vector, scalar or None. Applied first.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Translation3D","title":"<code>class Translation3D</code>  <code>dataclass</code>","text":"<p>3D translation expressed as a vector.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Scale3D","title":"<code>class Scale3D</code>  <code>dataclass</code>","text":"<p>3D scale expressed as either a uniform scale or a vector.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.RotationAxisAngle","title":"<code>class RotationAxisAngle</code>  <code>dataclass</code>","text":"<p>3D rotation expressed via a rotation axis and angle.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.RotationAxisAngle.axis","title":"<code>axis: npt.ArrayLike</code>  <code>instance-attribute</code>","text":"<p>Axis to rotate around.</p> <p>This is not required to be normalized. If normalization fails (typically because the vector is length zero), the rotation is silently ignored.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.RotationAxisAngle.degrees","title":"<code>degrees: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation angle in degrees. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.RotationAxisAngle.radians","title":"<code>radians: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>3D rotation angle in radians. Only one of <code>degrees</code> or <code>radians</code> should be set.</p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Transform3DArray","title":"<code>class Transform3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/transform3d/#rerun.components.transform3d.Transform3DArray.from_transform","title":"<code>def from_transform(transform)</code>","text":"<p>Build a <code>Transform3DArray</code> from a single transform.</p>"},{"location":"package/rerun/components/vec/","title":"vec.py","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec","title":"<code>rerun.components.vec</code>","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray","title":"<code>class Vec2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray","title":"<code>class Vec3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/experimental/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/components/experimental/__init__/#rerun.components.experimental","title":"<code>rerun.components.experimental</code>","text":""},{"location":"package/rerun/components/experimental/text_box/","title":"text_box.py","text":""},{"location":"package/rerun/components/experimental/text_box/#rerun.components.experimental.text_box","title":"<code>rerun.components.experimental.text_box</code>","text":""},{"location":"package/rerun/components/experimental/text_box/#rerun.components.experimental.text_box.TextBoxArray","title":"<code>class TextBoxArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/experimental/text_box/#rerun.components.experimental.text_box.TextBoxArray.from_bodies","title":"<code>def from_bodies(text_entries)</code>","text":"<p>Build a <code>TextboxArray</code> from a sequence of text bodies.</p>"},{"location":"package/rerun/log/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/log/__init__/#rerun.log","title":"<code>rerun.log</code>","text":""},{"location":"package/rerun/log/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation","title":"<code>rerun.log.annotation</code>","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfoLike","title":"<code>AnnotationInfoLike = Union[Tuple[int, str], Tuple[int, str, Color], AnnotationInfo]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify an AnnotationInfo</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescriptionLike","title":"<code>ClassDescriptionLike = Union[AnnotationInfoLike, ClassDescription]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify a ClassDescription</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo","title":"<code>class AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Color | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription","title":"<code>class ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.info","title":"<code>info: AnnotationInfoLike | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Iterable[AnnotationInfoLike] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Iterable[int | tuple[int, int]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True, recording=None)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 gamma space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as: <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre></p> <p>Or using short-hand tuples. <pre><code>[(23, 'bar'), ...]\n</code></pre></p> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>ClassDescriptionLike | Iterable[ClassDescriptionLike]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow","title":"<code>rerun.log.arrow</code>","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>npt.ArrayLike | None</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>npt.ArrayLike | None</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>float | None</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/bounding_box/","title":"bounding_box.py","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box","title":"<code>rerun.log.bounding_box</code>","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb","title":"<code>def log_obb(entity_path, *, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>npt.ArrayLike | None</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Optional array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>npt.ArrayLike | None</code> <p>Optional array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line edges.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obbs","title":"<code>def log_obbs(entity_path, *, half_sizes, positions=None, rotations_q=None, colors=None, stroke_widths=None, labels=None, class_ids=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 3D Oriented Bounding Box, or OBB.</p>"},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obbs--example","title":"Example:","text":"<pre><code>rr.log_obb(\"my_obb\", half_size=[1.0, 2.0, 3.0], position=[0, 0, 0], rotation_q=[0, 0, 0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_sizes</code> <code>npt.ArrayLike | None</code> <p>Nx3 Array. Each row is the [x, y, z] half dimensions of an OBB.</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>Optional Nx3 array. Each row is [x, y, z] positions of an OBB in world space.</p> <code>None</code> <code>rotations_q</code> <code>npt.ArrayLike | None</code> <p>Optional Nx3 array. Each row is quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional Nx3 or Nx4 array. Each row is RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional array of the width of the line edges.</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional array of text labels placed at <code>position</code>.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds | None</code> <p>Optional array of class id for the OBBs.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/camera/","title":"camera.py","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera","title":"<code>rerun.log.camera</code>","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole","title":"<code>def log_pinhole(entity_path, *, width, height, focal_length_px=None, principal_point_px=None, child_from_parent=None, timeless=False, recording=None, camera_xyz=None)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that: <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre></p> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole--example","title":"Example","text":"<pre><code>width = 640\nheight = 480\nf_len = (height * width) ** 0.5\n\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  focal_length_px = f_len)\n\n# More explicit:\nu_cen = width / 2\nv_cen = height / 2\nrerun.log_pinhole(\"world/camera/image\",\n                  width = width,\n                  height = height,\n                  child_from_parent = [[f_len, 0,     u_cen],\n                                       [0,     f_len, v_cen],\n                                       [0,     0,     1  ]],\n                  camera_xyz=\"RDF\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>focal_length_px</code> <code>float | npt.ArrayLike | None</code> <p>The focal length of the camera in pixels. This is the diagonal of the projection matrix. Set one value for symmetric cameras, or two values (X=Right, Y=Down) for anamorphic cameras.</p> <code>None</code> <code>principal_point_px</code> <code>npt.ArrayLike | None</code> <p>The center of the camera in pixels. The default is half the width and height. This is the last column of the projection matrix. Expects two values along the dimensions Right and Down</p> <code>None</code> <code>child_from_parent</code> <code>npt.ArrayLike | None</code> <p>Row-major intrinsics matrix for projecting from camera space to image space. The first two axes are X=Right and Y=Down, respectively. Projection is done along the positive third (Z=Forward) axis. This can be specified instead of <code>focal_length_px</code> and <code>principal_point_px</code>.</p> <code>None</code> <code>width</code> <code>int</code> <p>Width of the image in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the image in pixels.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>camera_xyz</code> <code>str | None</code> <p>Sets the view coordinates for the camera. The default is \"RDF\", i.e. X=Right, Y=Down, Z=Forward, and this is also the recommended setting. This means that the camera frustum will point along the positive Z axis of the parent space, and the cameras \"up\" direction will be along the negative Y axis of the parent space.</p> <p>Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>The camera furstum will point whichever axis is set to <code>F</code> (or the oppositve of <code>B</code>). When logging a depth image under this entity, this is the direction the point cloud will be projected. With XYZ=RDF, the default forward is +Z.</p> <p>The frustum's \"up\" direction will be whichever axis is set to <code>U</code> (or the oppositve of <code>D</code>). This will match the negative Y direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default is up is -Y.</p> <p>The frustum's \"right\" direction will be whichever axis is set to <code>R</code> (or the oppositve of <code>L</code>). This will match the positive X direction of pixel space (all images are assumed to have xyz=RDF). With RDF, the default right is +x.</p> <p>Other common formats are \"RUB\" (X=Right, Y=Up, Z=Back) and \"FLU\" (X=Forward, Y=Left, Z=Up).</p> <p>Equivalent to calling <code>rerun.log_view_coordinates(entity, xyz=\u2026)</code>.</p> <p>NOTE: setting this to something else than \"RDF\" (the default) will change the orientation of the camera frustum, and make the pinhole matrix not match up with the coordinate system of the pinhole entity.</p> <p>The pinhole matrix (the <code>child_from_parent</code> argument) always project along the third (Z) axis, but will be re-oriented to project along the forward axis of the <code>camera_xyz</code> argument.</p> <code>None</code>"},{"location":"package/rerun/log/clear/","title":"clear.py","text":""},{"location":"package/rerun/log/clear/#rerun.log.clear","title":"<code>rerun.log.clear</code>","text":""},{"location":"package/rerun/log/clear/#rerun.log.clear.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False, recording=None)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>recursive:     Should this apply to all entity paths below <code>entity_path</code>?</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/log/error_utils/","title":"error_utils.py","text":""},{"location":"package/rerun/log/error_utils/#rerun.log.error_utils","title":"<code>rerun.log.error_utils</code>","text":""},{"location":"package/rerun/log/extension_components/","title":"extension_components.py","text":""},{"location":"package/rerun/log/extension_components/#rerun.log.extension_components","title":"<code>rerun.log.extension_components</code>","text":""},{"location":"package/rerun/log/extension_components/#rerun.log.extension_components.log_extension_components","title":"<code>def log_extension_components(entity_path, ext, *, identifiers=None, timeless=False, recording=None)</code>","text":"<p>Log an arbitrary collection of extension components.</p> <p>Each item in <code>ext</code> will be logged as a separate component.</p> <ul> <li>The key will be used as the name of the component</li> <li>The value must be able to be converted to an array of arrow types. In general, if    you can pass it to pyarrow.array,    you can log it as a extension component.</li> </ul> <p>All values must either have the same length, or be singular in which case they will be treated as a splat.</p> <p>Extension components will be prefixed with \"ext.\" to avoid collisions with rerun native components. You do not need to include this prefix; it will be added for you.</p> <p>Note: rerun requires that a given component only take on a single type. The first type logged will be the type that is used for all future logs of that component. The API will make a best effort to do type conversion if supported by numpy and arrow. Any components that can't be converted will be dropped.</p> <p>If you are want to inspect how your component will be converted to the underlying arrow code, the following snippet is what is happening internally: <pre><code>np_value = np.atleast_1d(np.array(value, copy=False))\npa_value = pa.array(value)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the extension components in the space hierarchy.</p> required <code>ext</code> <code>dict[str, Any]</code> <p>A dictionary of extension components.</p> required <code>identifiers</code> <code>Sequence[int] | None</code> <p>Optional identifiers for each component. If provided, must be the same length as the components.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the components will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/file/","title":"file.py","text":""},{"location":"package/rerun/log/file/#rerun.log.file","title":"<code>rerun.log.file</code>","text":""},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat","title":"<code>class MeshFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Mesh file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.GLB","title":"<code>GLB = 'GLB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>glTF binary format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.OBJ","title":"<code>OBJ = 'OBJ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Wavefront .obj format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat","title":"<code>class ImageFormat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Image file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat.JPEG","title":"<code>JPEG = 'jpeg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>JPEG format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat.PNG","title":"<code>PNG = 'png'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, *, mesh_bytes=None, mesh_path=None, transform=None, timeless=False, recording=None)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p>You must pass either <code>mesh_bytes</code> or <code>mesh_path</code>.</p> <p>You can also use [<code>rerun.log_mesh</code>] to log raw mesh data.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_bytes</code> <code>bytes | None</code> <p>Content of an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>mesh_path</code> <code>Path | None</code> <p>Path to an mesh file, e.g. a <code>.glb</code>.</p> <code>None</code> <code>transform</code> <code>npt.ArrayLike | None</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/file/#rerun.log.file.log_image_file","title":"<code>def log_image_file(entity_path, *, img_bytes=None, img_path=None, img_format=None, timeless=False, recording=None)</code>","text":"<p>Log an image file given its contents or path on disk.</p> <p>You must pass either <code>img_bytes</code> or <code>img_path</code>.</p> <p>Only JPEGs and PNGs are supported right now.</p> <p>JPEGs will be stored compressed, saving memory, whilst PNGs will currently be decoded before they are logged. This may change in the future.</p> <p>If no <code>img_format</code> is specified, rerun will try to guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_bytes</code> <code>bytes | None</code> <p>Content of an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_path</code> <code>Path | None</code> <p>Path to an image file, e.g. a <code>.jpg</code>.</p> <code>None</code> <code>img_format</code> <code>ImageFormat | None</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/image/","title":"image.py","text":""},{"location":"package/rerun/log/image/#rerun.log.image","title":"<code>rerun.log.image</code>","text":""},{"location":"package/rerun/log/image/#rerun.log.image.log_image","title":"<code>def log_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None, jpeg_quality=None)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8, uint16, uint32, uint64: color components should be in 0-<code>max_uint</code> sRGB gamma space, except for alpha    which should be in 0-<code>max_uint</code> linear space.</li> <li>float16, float32, float64: all color components should be in 0-1 linear space.</li> <li>int8, int16, int32, int64: if all pixels are positive, they are interpreted as their unsigned counterparts.    Otherwise, the image is normalized before display (the pixel with the lowest value is black and the pixel with    the highest value is white).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code> <code>jpeg_quality</code> <code>int | None</code> <p>If set, encode the image as a JPEG to save storage space. Higher quality = larger file size. A quality of 95 still saves a lot of space, but is visually very similar. JPEG compression works best for photographs. Only RGB images are supported. Note that compressing to JPEG costs a bit of CPU time, both when logging and later when viewing them.</p> <code>None</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, draw_order=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>float16, float32, float64, uint8, uint16, uint32, uint64, int8, int16, int32, int64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for images is -10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/lines/","title":"lines.py","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines","title":"<code>rerun.log.lines</code>","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_strip","title":"<code>def log_line_strip(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a line strip through 2D or 3D space.</p> <p>A line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>An Nx2 or Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_strips_2d","title":"<code>def log_line_strips_2d(entity_path, line_strips, *, identifiers=None, stroke_widths=None, colors=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a batch of line strips through 2D space.</p> <p>Each line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>line_strips</code> <code>Iterable[npt.ArrayLike] | None</code> <p>An iterable of Nx2 arrays of points along the path. To log an empty line_strip use <code>np.zeros((0,0,3))</code> or <code>np.zeros((0,0,2))</code></p> required <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the line.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional widths of the line.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the lines. RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_strips_3d","title":"<code>def log_line_strips_3d(entity_path, line_strips, *, identifiers=None, stroke_widths=None, colors=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a batch of line strips through 3D space.</p> <p>Each line strip is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so: <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>line_strips</code> <code>Iterable[npt.ArrayLike] | None</code> <p>An iterable of Nx3 arrays of points along the path. To log an empty line_strip use <code>np.zeros((0,0,3))</code> or <code>np.zeros((0,0,2))</code></p> required <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the line.</p> <code>None</code> <code>stroke_widths</code> <code>npt.ArrayLike | None</code> <p>Optional widths of the line.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the lines. RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An Nx2 or Nx3 array of points. Even-odd pairs will be connected as segments.</p> required <code>stroke_width</code> <code>float | None</code> <p>Optional width of the line.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for lines is 20.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/log_decorator/","title":"log_decorator.py","text":""},{"location":"package/rerun/log/log_decorator/#rerun.log.log_decorator","title":"<code>rerun.log.log_decorator</code>","text":""},{"location":"package/rerun/log/log_decorator/#rerun.log.log_decorator.RerunWarning","title":"<code>class RerunWarning</code>","text":"<p>         Bases: <code>Warning</code></p> <p>A custom warning class that we use to identify warnings that are emitted by the Rerun SDK itself.</p>"},{"location":"package/rerun/log/log_decorator/#rerun.log.log_decorator.log_decorator","title":"<code>def log_decorator(func)</code>","text":"<p>A decorator we add to all our logging function.</p> <p>It does two things: * It early-outs if logging is disabled * It catches any exceptions and logs them</p> <p>The latter is important in order not to crash the users application just because they misused the Rerun API (or because we have a bug!).</p>"},{"location":"package/rerun/log/mesh/","title":"mesh.py","text":""},{"location":"package/rerun/log/mesh/#rerun.log.mesh","title":"<code>rerun.log.mesh</code>","text":""},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_mesh","title":"<code>def log_mesh(entity_path, positions, *, indices=None, normals=None, albedo_factor=None, vertex_colors=None, timeless=False, recording=None)</code>","text":"<p>Log a raw 3D mesh by specifying its vertex positions, and optionally indices, normals and albedo factor.</p> <p>You can also use [<code>rerun.log_mesh_file</code>] to log .gltf, .glb, .obj, etc.</p>"},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_mesh--example","title":"Example:","text":"<pre><code># A simple red triangle:\nrerun.log_mesh(\n    \"world/mesh\",\n    positions = [\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0]\n    ],\n    indices = [0, 1, 2],\n    normals = [\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, 1.0]\n    ],\n    albedo_factor = [1.0, 0.0, 0.0],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>positions</code> <code>Any</code> <p>An array of 3D points. If no <code>indices</code> are specified, then each triplet of positions is interpreted as a triangle.</p> required <code>indices</code> <code>Any | None</code> <p>If specified, is a flattened array of indices that describe the mesh's triangles, i.e. its length must be divisible by 3.</p> <code>None</code> <code>normals</code> <code>Any | None</code> <p>If specified, is a (potentially flattened) array of 3D vectors that describe the normal for each vertex, i.e. the total number of elements must be divisible by 3 and more importantly, <code>len(normals)</code> should be equal to <code>len(positions)</code>.</p> <code>None</code> <code>albedo_factor</code> <code>Any | None</code> <p>Optional color multiplier of the mesh using RGB or unmuliplied RGBA in linear 0-1 space.</p> <code>None</code> <code>vertex_colors</code> <code>Colors | None</code> <p>Optional array of RGB(A) vertex colors, in sRGB gamma space, either as 0-1 floats or 0-255 integers. If specified, the alpha is considered separate (unmultiplied).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/mesh/#rerun.log.mesh.log_meshes","title":"<code>def log_meshes(entity_path, position_buffers, *, vertex_color_buffers, index_buffers, normal_buffers, albedo_factors, timeless=False, recording=None)</code>","text":"<p>Log multiple raw 3D meshes by specifying their different buffers and albedo factors.</p> <p>To learn more about how the data within these buffers is interpreted and laid out, refer to the documentation for [<code>rerun.log_mesh</code>].</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>position_buffers</code> <code>Sequence[npt.ArrayLike]</code> <p>A sequence of position buffers, one for each mesh.</p> required <code>vertex_color_buffers</code> <code>Sequence[Colors | None]</code> <p>An optional sequence of vertex color buffers, one for each mesh.</p> required <code>index_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of index buffers, one for each mesh.</p> required <code>normal_buffers</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of normal buffers, one for each mesh.</p> required <code>albedo_factors</code> <code>Sequence[npt.ArrayLike | None]</code> <p>An optional sequence of albedo factors, one for each mesh.</p> required <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/points/","title":"points.py","text":""},{"location":"package/rerun/log/points/#rerun.log.points","title":"<code>rerun.log.points</code>","text":""},{"location":"package/rerun/log/points/#rerun.log.points.log_point","title":"<code>def log_point(entity_path, position=None, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D or 3D point, with a position and optional color, radii, label, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA represented as a 2-element or 3-element sequence.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>npt.ArrayLike | None</code> <p>Any 2-element or 3-element array-like.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>int | None</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points","title":"<code>def log_points(entity_path, positions=None, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log 2D or 3D points, with positions and optional colors, radii, labels, etc.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>npt.ArrayLike | None</code> <p>Nx2 or Nx3 array</p> <code>None</code> <code>identifiers</code> <code>npt.ArrayLike | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional colors of the points. The colors are interpreted as RGB or RGBA in sRGB gamma-space, as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>radii</code> <code>npt.ArrayLike | None</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for 2D points is 30.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/rects/","title":"rects.py","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects","title":"<code>rerun.log.rects</code>","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>npt.ArrayLike | None</code> <p>the rectangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>int | None</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, draw_order=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>npt.ArrayLike | None</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Sequence[int] | None</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Color | Colors | None</code> <p>Optional per-rectangle gamma-space RGB or RGBA as 0-1 floats or 0-255 integers.</p> <code>None</code> <code>labels</code> <code>Sequence[str] | None</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>draw_order</code> <code>float | None</code> <p>An optional floating point value that specifies the 2D drawing order. Objects with higher values are drawn on top of those with lower values. The default for rects is 10.0.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <pre><code>If true, the rects will be timeless (default: False).\n</code></pre> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar","title":"<code>rerun.log.scalar</code>","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar","title":"<code>def log_scalar(entity_path, scalar, *, label=None, color=None, radius=None, scattered=None, ext=None, recording=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See here for a larger example.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following: <pre><code>t=1.0\nrerun.log_scalar(\"trig/sin\", math.sin(t), label=\"sin(t)\", color=[255, 0, 0])\nrerun.log_scalar(\"trig/cos\", math.cos(t), label=\"cos(t)\", color=[0, 0, 255])\n</code></pre> will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>str | None</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points TODO(https://github.com/rerun-io/rerun/issues/1289). If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear gray in the legend.</p> <code>None</code> <code>radius</code> <code>float | None</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>bool | None</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor","title":"<code>rerun.log.tensor</code>","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor.Tensor","title":"<code>Tensor = Union[npt.ArrayLike, TorchTensorLike]</code>  <code>module-attribute</code>","text":"<p>Type helper for a tensor-like object that can be logged to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.TorchTensorLike","title":"<code>class TorchTensorLike</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Describes what is need from a Torch Tensor to be loggable to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.log_tensor","title":"<code>def log_tensor(entity_path, tensor, *, names=None, meter=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log an n-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor object.</p> required <code>names</code> <code>Iterable[str | None] | None</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>float | None</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/text/","title":"text.py","text":""},{"location":"package/rerun/log/text/#rerun.log.text","title":"<code>rerun.log.text</code>","text":""},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler","title":"<code>class LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.log_text_entry","title":"<code>def log_text_entry(entity_path, text, *, level=LogLevel.INFO, color=None, ext=None, timeless=False, recording=None)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>str | None</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/text_internal/","title":"text_internal.py","text":""},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal","title":"<code>rerun.log.text_internal</code>","text":""},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/log/text_internal/#rerun.log.text_internal.log_text_entry_internal","title":"<code>def log_text_entry_internal(entity_path, text, *, level=LogLevel.INFO, color=None, timeless=False, recording=None)</code>","text":"<p>Internal API to log a text entry, with optional level.</p> <p>This implementation doesn't support extension components, or the exception-capturing decorator and is intended to be used from inside the other rerun log functions.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>str | None</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Color | None</code> <p>Optional RGB or RGBA in sRGB gamma-space as either 0-1 floats or 0-255 integers, with separate alpha.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/transform/","title":"transform.py","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform","title":"<code>rerun.log.transform</code>","text":"<p>Methods for logging transforms on entity paths.</p> <p>Learn more about transforms in the manual</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False, recording=None)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space.</p> <p>This is particularly useful for 3D spaces, to set the up-axis.</p> <p>For pinhole entities this will control the direction of the camera frustum. You should use <code>rerun.log_pinhole(\u2026, camera_xyz=\u2026)</code> for this instead, and read the documentation there.</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul> <p>Currently Rerun only supports right-handed coordinate systems.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera/image\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often convenient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>bool | None</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_disconnected_space","title":"<code>def log_disconnected_space(entity_path, timeless=False, recording=None)</code>","text":"<p>Log that this entity is NOT in the same space as the parent.</p> <p>This is useful for specifying that a subgraph is independent of the rest of the scene. If a transform or pinhole is logged on the same path, this component will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path of the affected entity.</p> required <p>timeless:     Log the data as timeless.</p> <p>recording:     Specifies the <code>rerun.RecordingStream</code> to use.     If left unspecified, defaults to the current active data recording, if there is one.     See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_transform3d","title":"<code>def log_transform3d(entity_path, transform, *, from_parent=False, timeless=False, recording=None)</code>","text":"<p>Log an (affine) 3D transform between this entity and the parent.</p> <p>If <code>from_parent</code> is set to <code>True</code>, the transformation is from the parent to the space of the entity_path, otherwise it is from the child to the parent.</p> <p>Note that new transforms replace previous, i.e. if you call this function several times on the same path, each new transform will replace the previous one and does not combine with it.</p> <p>Examples:</p> <pre><code># Log translation only.\nrr.log_transform3d(\"transform_test/translation\", rr.Translation3D((2, 1, 3)))\n\n# Log scale along the x axis only.\nrr.log_transform3d(\"transform_test/x_scaled\", rr.Scale3D((3, 1, 1)))\n\n# Log a rotation around the z axis.\nrr.log_transform3d(\"transform_test/z_rotated_object\", rr.RotationAxisAngle((0, 0, 1), degrees=20))\n\n# Log scale followed by translation along the Y-axis.\nrr.log_transform3d(\n    \"transform_test/scaled_and_translated_object\", rr.TranslationRotationScale3D([0.0, 1.0, 0.0], scale=2)\n)\n\n# Log translation + rotation, also called a rigid transform.\nrr.log_transform3d(\"transform_test/rigid3\", rr.Rigid3D([1, 2, 3], rr.RotationAxisAngle((0, 1, 0), radians=1.57)))\n\n# Log translation, rotation &amp; scale all at once.\nrr.log_transform3d(\n    \"transform_test/transformed\",\n    rr.TranslationRotationScale3D(\n        translation=[0, 1, 5],\n        rotation=rr.RotationAxisAngle((0, 0, 1), degrees=20),\n        scale=2,\n    ),\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>transform</code> <code>TranslationAndMat3 | TranslationRotationScale3D | RotationAxisAngle | Translation3D | Scale3D | Quaternion | Rigid3D</code> <p>Instance of a rerun data class that describes a three dimensional transform. One of: * <code>TranslationAndMat3</code> * <code>TranslationRotationScale3D</code> * <code>Rigid3D</code> * <code>RotationAxisAngle</code> * <code>Translation3D</code> * <code>Quaternion</code> * <code>Scale3D</code></p> required <code>from_parent</code> <code>bool</code> <p>If True, the transform is from the parent to the child, otherwise it is from the child to the parent.</p> <code>False</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False, recording=None)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent (deprecated).</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p> <p>Note: This function is deprecated. Use <code>rerun.log_transform3d</code> instead.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--example","title":"Example","text":"<pre><code>t = 0.0\ntranslation = [math.sin(t), math.cos(t), 0.0] # circle around origin\nrotation = [0.5, 0.0, 0.0, np.sin(np.pi/3)] # 60 degrees around x-axis\nrerun.log_rigid3(\"sun/planet\", parent_from_child=(translation, rotation))\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>tuple[npt.ArrayLike, npt.ArrayLike] | None</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>tuple[npt.ArrayLike, npt.ArrayLike] | None</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code> <code>recording</code> <code>RecordingStream | None</code> <p>Specifies the <code>rerun.RecordingStream</code> to use. If left unspecified, defaults to the current active data recording, if there is one. See also: <code>rerun.init</code>, <code>rerun.set_global_data_recording</code>.</p> <code>None</code>"},{"location":"package/rerun/log/experimental/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/log/experimental/__init__/#rerun.log.experimental","title":"<code>rerun.log.experimental</code>","text":""},{"location":"package/rerun/log/experimental/blueprint/","title":"blueprint.py","text":""},{"location":"package/rerun/log/experimental/blueprint/#rerun.log.experimental.blueprint","title":"<code>rerun.log.experimental.blueprint</code>","text":""},{"location":"package/rerun/log/experimental/blueprint/#rerun.log.experimental.blueprint.new_blueprint","title":"<code>def new_blueprint(application_id, *, blueprint_id=None, make_default=False, make_thread_default=False, spawn=False, add_to_app_default_blueprint=False, default_enabled=True)</code>","text":"<p>Creates a new blueprint with a user-chosen application id (name) to configure the appearance of Rerun.</p> <p>If you only need a single global blueprint, <code>rerun.init</code> might be simpler.</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For example, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>blueprint_id</code> <code>Optional[str]</code> <p>Set the blueprint ID that this process is logging to, as a UUIDv4.</p> <p>The default blueprint_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default blueprint_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same blueprint), you will need to manually assign them all the same blueprint_id. Any random UUIDv4 will work, or copy the blueprint_id for the parent process.</p> <code>None</code> <code>make_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the global scope.</p> <code>False</code> <code>make_thread_default</code> <code>bool</code> <p>If true (not the default), the newly initialized blueprint will replace the current active one (if any) in the thread-local scope.</p> <code>False</code> <code>spawn</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code> <code>add_to_app_default_blueprint</code> <code>bool</code> <p>Should the blueprint append to the existing app-default blueprint instead instead of creating a new one.</p> <code>False</code> <code>default_enabled</code> <code>bool</code> <p>Should Rerun logging be on by default? Can overridden with the RERUN env-var, e.g. <code>RERUN=on</code> or <code>RERUN=off</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>RecordingStream</code> <p>A handle to the <code>rerun.RecordingStream</code>. Use it to log data to Rerun.</p>"},{"location":"package/rerun/log/experimental/blueprint/#rerun.log.experimental.blueprint.add_space_view","title":"<code>def add_space_view(*, origin, name, entity_paths, blueprint=None)</code>","text":"<p>Add a new space view to the blueprint.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>str</code> <p>The EntityPath to use as the origin of this space view. All other entities will be transformed to be displayed relative to this origin.</p> required <code>name</code> <code>Optional[str]</code> <p>The name of the space view to show in the UI. Will default to the origin if not provided.</p> required <code>entity_paths</code> <code>Optional[List[str]]</code> <p>The entities to be shown in the space view. If not provided, this will default to [origin]</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/log/experimental/blueprint/#rerun.log.experimental.blueprint.set_panels","title":"<code>def set_panels(*, all_expanded=None, blueprint_view_expanded=None, selection_view_expanded=None, timeline_view_expanded=None, blueprint=None)</code>","text":"<p>Change the visibility of the view panels.</p> <p>Parameters:</p> Name Type Description Default <code>all_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse all panels.</p> <code>None</code> <code>blueprint_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the blueprint view panel.</p> <code>None</code> <code>selection_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the selection view panel.</p> <code>None</code> <code>timeline_view_expanded</code> <code>Optional[bool]</code> <p>Expand or collapse the timeline view panel.</p> <code>None</code> <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/log/experimental/blueprint/#rerun.log.experimental.blueprint.set_auto_space_views","title":"<code>def set_auto_space_views(enabled, blueprint=None)</code>","text":"<p>Change whether or not the blueprint automatically adds space views for all entities.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>Optional[bool]</code> <p>Whether or not to automatically add space views for all entities.</p> required <code>blueprint</code> <code>Optional[RecordingStream]</code> <p>The blueprint to add the space view to. If None, the default global blueprint is used.</p> <code>None</code>"},{"location":"package/rerun/log/experimental/text/","title":"text.py","text":""},{"location":"package/rerun/log/experimental/text/#rerun.log.experimental.text","title":"<code>rerun.log.experimental.text</code>","text":""},{"location":"package/rerun/log/experimental/text/#rerun.log.experimental.text.log_text_box","title":"<code>def log_text_box(entity_path, text, *, ext=None, timeless=False)</code>","text":"<p>Log a textbox.</p> <p>This is intended to be used for multi-line text entries to be displayed in their own view.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>ext</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of extension components. See rerun.log_extension_components</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text-box should be timeless.</p> <code>False</code>"},{"location":"package/rerun_demo/__init__/","title":"__init__.py","text":""},{"location":"package/rerun_demo/__init__/#rerun_demo","title":"<code>rerun_demo</code>","text":"<p>The <code>rerun_demo</code> package contains utilities for easily demonstrating rerun features.</p> <p>main.py is a program which tries to load a pre-baked .rrd file into the viewer</p> <p>The <code>data</code> module contains a collection of reference objects and helpers that can be easily logged with a few lines of code, but still produce visually interesting content.</p> <p>As an example, consider: <pre><code>import rerun as rr\nfrom rerun_demo.data import color_grid\n\nrr.init(\"log_points\", True)\n\nrr.log_points(\"my_points\", color_grid.positions, colors=color_grid.colors)\n</code></pre></p> <p>Note that because this package is shipped with the rerun-sdk pypi package, it cannot carry any dependencies beyond those of rerun itself. This generally limits demos to only using the standard library and numpy for data generation.</p>"},{"location":"package/rerun_demo/data/","title":"data.py","text":""},{"location":"package/rerun_demo/data/#rerun_demo.data","title":"<code>rerun_demo.data</code>","text":"<p>Simple data to be used for Rerun demos.</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.color_grid","title":"<code>color_grid = build_color_grid()</code>  <code>module-attribute</code>","text":"<p>Default color grid</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.rect_pyramid","title":"<code>rect_pyramid = build_rect_pyramid()</code>  <code>module-attribute</code>","text":"<p>Default rect pyramid data</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.color_spiral","title":"<code>color_spiral = build_color_spiral()</code>  <code>module-attribute</code>","text":"<p>Default color spiral</p>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_color_grid","title":"<code>def build_color_grid(x_count=10, y_count=10, z_count=10, twist=0)</code>","text":"<p>Create a cube of points with colors.</p> <p>The total point cloud will have x_count * y_count * z_count points.</p> <p>Parameters:</p> Name Type Description Default <code>x_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>y_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>z_count</code> <p>Number of points in each dimension.</p> <code>10</code> <code>twist</code> <p>Angle to twist from bottom to top of the cube</p> <code>0</code>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_rect_pyramid","title":"<code>def build_rect_pyramid(count=20, width=100, height=100)</code>","text":"<p>Create a stack of N colored rectangles.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <p>Number of rectangles to create.</p> <code>20</code> <code>width</code> <p>Width of the base of the pyramid.</p> <code>100</code> <code>height</code> <p>Height of the pyramid.</p> <code>100</code>"},{"location":"package/rerun_demo/data/#rerun_demo.data.build_color_spiral","title":"<code>def build_color_spiral(num_points=100, radius=2, angular_step=0.02, angular_offset=0, z_step=0.1)</code>","text":"<p>Create a spiral of points with colors along the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>num_points</code> <p>Total number of points.</p> <code>100</code> <code>radius</code> <p>The radius of the spiral.</p> <code>2</code> <code>angular_step</code> <p>The factor applied between each step along the trigonemetric circle.</p> <code>0.02</code> <code>angular_offset</code> <p>Offsets the starting position on the trigonemetric circle.</p> <code>0</code> <code>z_step</code> <p>The factor applied between between each step along the Z axis.</p> <code>0.1</code>"},{"location":"package/rerun_demo/turbo/","title":"turbo.py","text":""},{"location":"package/rerun_demo/turbo/#rerun_demo.turbo","title":"<code>rerun_demo.turbo</code>","text":""},{"location":"package/rerun_demo/util/","title":"util.py","text":""},{"location":"package/rerun_demo/util/#rerun_demo.util","title":"<code>rerun_demo.util</code>","text":"<p>Simpe utilities to be used for Rerun demos.</p>"},{"location":"package/rerun_demo/util/#rerun_demo.util.bounce_lerp","title":"<code>def bounce_lerp(a, b, t)</code>","text":"<p>A linear interpolator that bounces between <code>a</code> and <code>b</code> as <code>t</code> goes above <code>1.0</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>Start value (t == 0).</p> required <code>b</code> <p>End value (t == 1).</p> required <code>t</code> <p>Interpolation coefficient.</p> required"},{"location":"package/rerun_demo/util/#rerun_demo.util.interleave","title":"<code>def interleave(arr1, arr2)</code>","text":"<p>Interleaves two numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>arr1</code> <p>A numpy array of arbitrary shape and length.</p> required <code>arr2</code> <p>A numpy array with the same shape and length as <code>arr1</code>.</p> required"}]}