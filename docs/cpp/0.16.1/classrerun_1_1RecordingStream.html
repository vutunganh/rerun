<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.7" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rerun C++ SDK: rerun::RecordingStream Class Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">Rerun C++ SDK
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrerun_1_1RecordingStream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrerun_1_1RecordingStream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rerun::RecordingStream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> handles everything related to logging data into Rerun.  
 <a href="classrerun_1_1RecordingStream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="recording__stream_8hpp_source.html">rerun/recording_stream.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abda6202900fa439fe5c27f7aa0d1105a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#abda6202900fa439fe5c27f7aa0d1105a">RecordingStream</a> (std::string_view app_id, std::string_view recording_id=std::string_view(), StoreKind store_kind=StoreKind::Recording)</td></tr>
<tr class="memdesc:abda6202900fa439fe5c27f7aa0d1105a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new recording stream to log to.  <br /></td></tr>
<tr class="separator:abda6202900fa439fe5c27f7aa0d1105a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Properties</div></td></tr>
<tr class="memitem:a72bced7e99acd1fee20e1502ee5cf2da"><td class="memItemLeft" align="right" valign="top"><a id="a72bced7e99acd1fee20e1502ee5cf2da" name="a72bced7e99acd1fee20e1502ee5cf2da"></a>
StoreKind&#160;</td><td class="memItemRight" valign="bottom"><b>kind</b> () const</td></tr>
<tr class="memdesc:a72bced7e99acd1fee20e1502ee5cf2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the store kind as passed during construction. <br /></td></tr>
<tr class="separator:a72bced7e99acd1fee20e1502ee5cf2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307d5cd9178a130f5c9c3322f2fd4d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a2307d5cd9178a130f5c9c3322f2fd4d7">is_enabled</a> () const</td></tr>
<tr class="memdesc:a2307d5cd9178a130f5c9c3322f2fd4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the recording stream is enabled.  <br /></td></tr>
<tr class="separator:a2307d5cd9178a130f5c9c3322f2fd4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directing the recording stream.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Either of these needs to be called, otherwise the stream will buffer up indefinitely. </p>
</div></td></tr>
<tr class="memitem:aef3377ffaa2441b906d2bac94dd8fc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#aef3377ffaa2441b906d2bac94dd8fc64">connect</a> (std::string_view tcp_addr=&quot;127.0.0.1:9876&quot;, float flush_timeout_sec=2.0) const</td></tr>
<tr class="memdesc:aef3377ffaa2441b906d2bac94dd8fc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote Rerun Viewer on the given ip:port.  <br /></td></tr>
<tr class="separator:aef3377ffaa2441b906d2bac94dd8fc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f0b0d64b03a9d408e75967ddad339e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a04f0b0d64b03a9d408e75967ddad339e">spawn</a> (const <a class="el" href="structrerun_1_1SpawnOptions.html">SpawnOptions</a> &amp;options={}, float flush_timeout_sec=2.0) const</td></tr>
<tr class="memdesc:a04f0b0d64b03a9d408e75967ddad339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new Rerun Viewer process from an executable available in PATH, then connects to it over TCP.  <br /></td></tr>
<tr class="separator:a04f0b0d64b03a9d408e75967ddad339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb19b28a74ffc5ba0cb9d43d0d52660"><td class="memTemplParams" colspan="2">template&lt;typename TRep , typename TPeriod &gt; </td></tr>
<tr class="memitem:a7fb19b28a74ffc5ba0cb9d43d0d52660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a7fb19b28a74ffc5ba0cb9d43d0d52660">spawn</a> (const <a class="el" href="structrerun_1_1SpawnOptions.html">SpawnOptions</a> &amp;options={}, std::chrono::duration&lt; TRep, TPeriod &gt; flush_timeout=std::chrono::seconds(2)) const</td></tr>
<tr class="separator:a7fb19b28a74ffc5ba0cb9d43d0d52660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555a7940a076c93d951de5b139d14918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a555a7940a076c93d951de5b139d14918">save</a> (std::string_view path) const</td></tr>
<tr class="memdesc:a555a7940a076c93d951de5b139d14918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream all log-data to a given <code>.rrd</code> file.  <br /></td></tr>
<tr class="separator:a555a7940a076c93d951de5b139d14918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481df1f540f92586034793aa0bc5e87a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a481df1f540f92586034793aa0bc5e87a">to_stdout</a> () const</td></tr>
<tr class="memdesc:a481df1f540f92586034793aa0bc5e87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream all log-data to standard output.  <br /></td></tr>
<tr class="separator:a481df1f540f92586034793aa0bc5e87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5a8387a4e2779ca6b9b3f37a5d5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a9ab5a8387a4e2779ca6b9b3f37a5d5b0">flush_blocking</a> () const</td></tr>
<tr class="memdesc:a9ab5a8387a4e2779ca6b9b3f37a5d5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a flush the batching pipeline and waits for it to propagate.  <br /></td></tr>
<tr class="separator:a9ab5a8387a4e2779ca6b9b3f37a5d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Controlling log time.</div></td></tr>
<tr class="memitem:afb7984ede28f5b53d04a1d33ebb8b36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f">set_time_sequence</a> (std::string_view timeline_name, int64_t sequence_nr) const</td></tr>
<tr class="memdesc:afb7984ede28f5b53d04a1d33ebb8b36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:afb7984ede28f5b53d04a1d33ebb8b36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e545fd9b3b51fea85d2427b9536552"><td class="memTemplParams" colspan="2">template&lt;typename TClock &gt; </td></tr>
<tr class="memitem:ac6e545fd9b3b51fea85d2427b9536552"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#ac6e545fd9b3b51fea85d2427b9536552">set_time</a> (std::string_view timeline_name, std::chrono::time_point&lt; TClock &gt; time) const</td></tr>
<tr class="memdesc:ac6e545fd9b3b51fea85d2427b9536552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:ac6e545fd9b3b51fea85d2427b9536552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa411c69361e169529daac832914fea4b"><td class="memTemplParams" colspan="2">template&lt;typename TRep , typename TPeriod &gt; </td></tr>
<tr class="memitem:aa411c69361e169529daac832914fea4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#aa411c69361e169529daac832914fea4b">set_time</a> (std::string_view timeline_name, std::chrono::duration&lt; TRep, TPeriod &gt; time) const</td></tr>
<tr class="memdesc:aa411c69361e169529daac832914fea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:aa411c69361e169529daac832914fea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad735156502aea8eecd0a5eb2f6678d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55">set_time_seconds</a> (std::string_view timeline_name, double seconds) const</td></tr>
<tr class="memdesc:ad735156502aea8eecd0a5eb2f6678d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:ad735156502aea8eecd0a5eb2f6678d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39bd4985d930a9c878187d50058a2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6">set_time_nanos</a> (std::string_view timeline_name, int64_t nanos) const</td></tr>
<tr class="memdesc:aa39bd4985d930a9c878187d50058a2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:aa39bd4985d930a9c878187d50058a2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e94ef74d259599e14cb5c823a33531c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c">disable_timeline</a> (std::string_view timeline_name) const</td></tr>
<tr class="memdesc:a3e94ef74d259599e14cb5c823a33531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops logging to the specified timeline for subsequent log calls.  <br /></td></tr>
<tr class="separator:a3e94ef74d259599e14cb5c823a33531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f907e40ee2281ed40cd8b212560aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2">reset_time</a> () const</td></tr>
<tr class="memdesc:a44f907e40ee2281ed40cd8b212560aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears out the current time of the recording, for the current calling thread.  <br /></td></tr>
<tr class="separator:a44f907e40ee2281ed40cd8b212560aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logging</div></td></tr>
<tr class="memitem:a7badac918d44d66e04e948f38818ff11"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7badac918d44d66e04e948f38818ff11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11">log</a> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:a7badac918d44d66e04e948f38818ff11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches.  <br /></td></tr>
<tr class="separator:a7badac918d44d66e04e948f38818ff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875ccce692438807f00ab0d685d67dc"><td class="memTemplParams" colspan="2"><a id="a3875ccce692438807f00ab0d685d67dc" name="a3875ccce692438807f00ab0d685d67dc"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a3875ccce692438807f00ab0d685d67dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log_timeless</b> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="separator:a3875ccce692438807f00ab0d685d67dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81101fe821143a1388d1797cd40caac"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aa81101fe821143a1388d1797cd40caac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac">log_static</a> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:aa81101fe821143a1388d1797cd40caac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches as static data.  <br /></td></tr>
<tr class="separator:aa81101fe821143a1388d1797cd40caac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934d8c4aef75b6e65f4d50858ca50a77"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a934d8c4aef75b6e65f4d50858ca50a77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77">try_log</a> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:a934d8c4aef75b6e65f4d50858ca50a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches.  <br /></td></tr>
<tr class="separator:a934d8c4aef75b6e65f4d50858ca50a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf65e486c60d4af769354eda4bae49fe"><td class="memTemplParams" colspan="2"><a id="abf65e486c60d4af769354eda4bae49fe" name="abf65e486c60d4af769354eda4bae49fe"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:abf65e486c60d4af769354eda4bae49fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_log_timeless</b> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="separator:abf65e486c60d4af769354eda4bae49fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92279ac1810188133d6129ec62e350"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2b92279ac1810188133d6129ec62e350"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350">try_log_static</a> (std::string_view entity_path, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:a2b92279ac1810188133d6129ec62e350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches as static data, returning an error.  <br /></td></tr>
<tr class="separator:a2b92279ac1810188133d6129ec62e350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dfbc49a91fe64b6468d21f62563bd0"><td class="memTemplParams" colspan="2"><a id="ad8dfbc49a91fe64b6468d21f62563bd0" name="ad8dfbc49a91fe64b6468d21f62563bd0"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad8dfbc49a91fe64b6468d21f62563bd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log_with_timeless</b> (std::string_view entity_path, bool timeless, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="separator:ad8dfbc49a91fe64b6468d21f62563bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d30f2c4f6db919bf20ce4f6e2a31af6"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a5d30f2c4f6db919bf20ce4f6e2a31af6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a5d30f2c4f6db919bf20ce4f6e2a31af6">log_with_static</a> (std::string_view entity_path, bool static_, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:a5d30f2c4f6db919bf20ce4f6e2a31af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches optionally static, returning an error.  <br /></td></tr>
<tr class="separator:a5d30f2c4f6db919bf20ce4f6e2a31af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42c52108f3b3cb7c73cdafd10045fcb"><td class="memTemplParams" colspan="2"><a id="ab42c52108f3b3cb7c73cdafd10045fcb" name="ab42c52108f3b3cb7c73cdafd10045fcb"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab42c52108f3b3cb7c73cdafd10045fcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_log_with_timeless</b> (std::string_view entity_path, bool static_, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="separator:ab42c52108f3b3cb7c73cdafd10045fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bbd6768189ee4efc93a55c2aed71be"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad9bbd6768189ee4efc93a55c2aed71be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be">try_log_with_static</a> (std::string_view entity_path, bool static_, const Ts &amp;... archetypes_or_collections) const</td></tr>
<tr class="memdesc:ad9bbd6768189ee4efc93a55c2aed71be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs one or more archetype and/or component batches optionally static, returning an error.  <br /></td></tr>
<tr class="separator:ad9bbd6768189ee4efc93a55c2aed71be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a9488921178fc182a14be6406e4fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a45a9488921178fc182a14be6406e4fc4">try_log_serialized_batches</a> (std::string_view entity_path, bool static_, std::vector&lt; <a class="el" href="structrerun_1_1DataCell.html">DataCell</a> &gt; batches) const</td></tr>
<tr class="memdesc:a45a9488921178fc182a14be6406e4fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs several serialized batches batches, returning an error on failure.  <br /></td></tr>
<tr class="separator:a45a9488921178fc182a14be6406e4fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116d19da4653f4b584225fa4d9b4358e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a116d19da4653f4b584225fa4d9b4358e">try_log_data_row</a> (std::string_view entity_path, size_t num_data_cells, const <a class="el" href="structrerun_1_1DataCell.html">DataCell</a> *data_cells, bool inject_time) const</td></tr>
<tr class="memdesc:a116d19da4653f4b584225fa4d9b4358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bottom level API that logs raw data cells to the recording stream.  <br /></td></tr>
<tr class="separator:a116d19da4653f4b584225fa4d9b4358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20798d7ea74cce5c8174e5cacd0a2c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a20798d7ea74cce5c8174e5cacd0a2c47">log_file_from_path</a> (const std::filesystem::path &amp;filepath, std::string_view entity_path_prefix=std::string_view(), bool static_=false) const</td></tr>
<tr class="memdesc:a20798d7ea74cce5c8174e5cacd0a2c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the file at the given <code>path</code> using all <code>DataLoader</code>s available.  <br /></td></tr>
<tr class="separator:a20798d7ea74cce5c8174e5cacd0a2c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fad856c89909271e411cc711185b03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a4fad856c89909271e411cc711185b03b">try_log_file_from_path</a> (const std::filesystem::path &amp;filepath, std::string_view entity_path_prefix=std::string_view(), bool static_=false) const</td></tr>
<tr class="memdesc:a4fad856c89909271e411cc711185b03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the file at the given <code>path</code> using all <code>DataLoader</code>s available.  <br /></td></tr>
<tr class="separator:a4fad856c89909271e411cc711185b03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f253422a7adc2a19b89d1538c05bcac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#a8f253422a7adc2a19b89d1538c05bcac">log_file_from_contents</a> (const std::filesystem::path &amp;filepath, const std::byte *contents, size_t contents_size, std::string_view entity_path_prefix=std::string_view(), bool static_=false) const</td></tr>
<tr class="memdesc:a8f253422a7adc2a19b89d1538c05bcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the given <code>contents</code> using all <code>DataLoader</code>s available.  <br /></td></tr>
<tr class="separator:a8f253422a7adc2a19b89d1538c05bcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34190dd8becde6fb08dd5e13ca82677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#ae34190dd8becde6fb08dd5e13ca82677">try_log_file_from_contents</a> (const std::filesystem::path &amp;filepath, const std::byte *contents, size_t contents_size, std::string_view entity_path_prefix=std::string_view(), bool static_=false) const</td></tr>
<tr class="memdesc:ae34190dd8becde6fb08dd5e13ca82677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs the given <code>contents</code> using all <code>DataLoader</code>s available.  <br /></td></tr>
<tr class="separator:ae34190dd8becde6fb08dd5e13ca82677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Controlling globally available instances of RecordingStream.</h2></td></tr>
<tr class="memitem:aed57a5ae9232a50a82f7f4569745ed63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#aed57a5ae9232a50a82f7f4569745ed63">set_global</a> () const</td></tr>
<tr class="memdesc:aed57a5ae9232a50a82f7f4569745ed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the currently active recording for this stream's store kind in the global scope with this one.  <br /></td></tr>
<tr class="separator:aed57a5ae9232a50a82f7f4569745ed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff91e7f42c568ac5f50a45eb7141126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#abff91e7f42c568ac5f50a45eb7141126">set_thread_local</a> () const</td></tr>
<tr class="memdesc:abff91e7f42c568ac5f50a45eb7141126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the currently active recording for this stream's store kind in the thread-local scope with this one.  <br /></td></tr>
<tr class="separator:abff91e7f42c568ac5f50a45eb7141126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82260398f7b03892714edbb68f330b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1RecordingStream.html">RecordingStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1RecordingStream.html#ab82260398f7b03892714edbb68f330b9">current</a> (StoreKind store_kind=StoreKind::Recording)</td></tr>
<tr class="memdesc:ab82260398f7b03892714edbb68f330b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the most appropriate globally available recording stream for the given kind.  <br /></td></tr>
<tr class="separator:ab82260398f7b03892714edbb68f330b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> handles everything related to logging data into Rerun. </p>
<h2><a class="anchor" id="autotoc_md87"></a>
Multithreading and ordering</h2>
<p>A <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> is thread-safe.</p>
<p>Internally, all operations are linearized into a pipeline:</p><ul>
<li>All operations sent by a given thread will take effect in the same exact order as that thread originally sent them in, from its point of view.</li>
<li>There isn't any well defined global order across multiple threads.</li>
</ul>
<p>This means that e.g. flushing the pipeline (<code>flush_blocking</code>) guarantees that all previous data sent by the calling thread has been recorded; no more, no less. (e.g. it does not mean that all file caches are flushed)</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Shutdown</h2>
<p>The <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> can only be shutdown by dropping all instances of it, at which point it will automatically take care of flushing any pending data that might remain in the pipeline.</p>
<p>TODO(andreas): The only way of having two instances of a <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> is currently to set it as a the global.</p>
<p>Shutting down cannot ever block.</p>
<h2><a class="anchor" id="autotoc_md89"></a>
Logging</h2>
<p>Internally, the stream will automatically micro-batch multiple log calls to optimize transport. See <a href="https://www.rerun.io/docs/reference/sdk-micro-batching">SDK Micro Batching</a> for more information.</p>
<p>The data will be timestamped automatically based on the <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code>'s internal clock. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abda6202900fa439fe5c27f7aa0d1105a" name="abda6202900fa439fe5c27f7aa0d1105a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda6202900fa439fe5c27f7aa0d1105a">&#9670;&#160;</a></span>RecordingStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rerun::RecordingStream::RecordingStream </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>app_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>recording_id</em> = <code>std::string_view()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreKind&#160;</td>
          <td class="paramname"><em>store_kind</em> = <code>StoreKind::Recording</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new recording stream to log to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app_id</td><td>The user-chosen name of the application doing the logging. </td></tr>
    <tr><td class="paramname">recording_id</td><td>The user-chosen name of the recording being logged to. </td></tr>
    <tr><td class="paramname">store_kind</td><td>Whether to log to the recording store or the blueprint store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2307d5cd9178a130f5c9c3322f2fd4d7" name="a2307d5cd9178a130f5c9c3322f2fd4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2307d5cd9178a130f5c9c3322f2fd4d7">&#9670;&#160;</a></span>is_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool rerun::RecordingStream::is_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the recording stream is enabled. </p>
<p>All log functions early out if a recording stream is disabled. Naturally, logging functions that take unserialized data will skip the serialization step as well. </p>

</div>
</div>
<a id="aed57a5ae9232a50a82f7f4569745ed63" name="aed57a5ae9232a50a82f7f4569745ed63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed57a5ae9232a50a82f7f4569745ed63">&#9670;&#160;</a></span>set_global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_global </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the currently active recording for this stream's store kind in the global scope with this one. </p>
<p>Afterwards, destroying this recording stream will <em>not</em> change the global recording stream, as it increases an internal ref-count. </p>

</div>
</div>
<a id="abff91e7f42c568ac5f50a45eb7141126" name="abff91e7f42c568ac5f50a45eb7141126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff91e7f42c568ac5f50a45eb7141126">&#9670;&#160;</a></span>set_thread_local()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_thread_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the currently active recording for this stream's store kind in the thread-local scope with this one. </p>
<p>Afterwards, destroying this recording stream will <em>not</em> change the thread local recording stream, as it increases an internal ref-count. </p>

</div>
</div>
<a id="ab82260398f7b03892714edbb68f330b9" name="ab82260398f7b03892714edbb68f330b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82260398f7b03892714edbb68f330b9">&#9670;&#160;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1RecordingStream.html">RecordingStream</a> &amp; rerun::RecordingStream::current </td>
          <td>(</td>
          <td class="paramtype">StoreKind&#160;</td>
          <td class="paramname"><em>store_kind</em> = <code>StoreKind::Recording</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the most appropriate globally available recording stream for the given kind. </p>
<p>I.e. thread-local first, then global. If neither was set, any operations on the returned stream will be no-ops. </p>

</div>
</div>
<a id="aef3377ffaa2441b906d2bac94dd8fc64" name="aef3377ffaa2441b906d2bac94dd8fc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3377ffaa2441b906d2bac94dd8fc64">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::connect </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>tcp_addr</em> = <code>&quot;127.0.0.1:9876&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>flush_timeout_sec</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote Rerun Viewer on the given ip:port. </p>
<p>Requires that you first start a Rerun Viewer by typing 'rerun' in a terminal.</p>
<p>flush_timeout_sec: The minimum time the SDK will wait during a flush before potentially dropping data if progress is not being made. Passing a negative value indicates no timeout, and can cause a call to <code>flush</code> to block indefinitely.</p>
<p>This function returns immediately. </p>

</div>
</div>
<a id="a04f0b0d64b03a9d408e75967ddad339e" name="a04f0b0d64b03a9d408e75967ddad339e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f0b0d64b03a9d408e75967ddad339e">&#9670;&#160;</a></span>spawn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::spawn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrerun_1_1SpawnOptions.html">SpawnOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>flush_timeout_sec</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawns a new Rerun Viewer process from an executable available in PATH, then connects to it over TCP. </p>
<p>If a Rerun Viewer is already listening on this TCP port, the stream will be redirected to that viewer instead of starting a new one.</p>
<h2><a class="anchor" id="autotoc_md90"></a>
Parameters</h2>
<p>options: See <code><a class="el" href="structrerun_1_1SpawnOptions.html" title="Options to control the behavior of spawn.">rerun::SpawnOptions</a></code> for more information.</p>
<p>flush_timeout_sec: The minimum time the SDK will wait during a flush before potentially dropping data if progress is not being made. Passing a negative value indicates no timeout, and can cause a call to <code>flush</code> to block indefinitely. </p>

</div>
</div>
<a id="a7fb19b28a74ffc5ba0cb9d43d0d52660" name="a7fb19b28a74ffc5ba0cb9d43d0d52660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb19b28a74ffc5ba0cb9d43d0d52660">&#9670;&#160;</a></span>spawn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRep , typename TPeriod &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::spawn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrerun_1_1SpawnOptions.html">SpawnOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; TRep, TPeriod &gt;&#160;</td>
          <td class="paramname"><em>flush_timeout</em> = <code>std::chrono::seconds(2)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a04f0b0d64b03a9d408e75967ddad339e" title="Spawns a new Rerun Viewer process from an executable available in PATH, then connects to it over TCP.">RecordingStream::spawn</a> </dd></dl>

</div>
</div>
<a id="a555a7940a076c93d951de5b139d14918" name="a555a7940a076c93d951de5b139d14918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555a7940a076c93d951de5b139d14918">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::save </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream all log-data to a given <code>.rrd</code> file. </p>
<p>This function returns immediately. </p>

</div>
</div>
<a id="a481df1f540f92586034793aa0bc5e87a" name="a481df1f540f92586034793aa0bc5e87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481df1f540f92586034793aa0bc5e87a">&#9670;&#160;</a></span>to_stdout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::to_stdout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream all log-data to standard output. </p>
<p>Pipe the result into the Rerun Viewer to visualize it.</p>
<p>If there isn't any listener at the other end of the pipe, the <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> will default back to <code>buffered</code> mode, in order not to break the user's terminal.</p>
<p>This function returns immediately. </p>

</div>
</div>
<a id="a9ab5a8387a4e2779ca6b9b3f37a5d5b0" name="a9ab5a8387a4e2779ca6b9b3f37a5d5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5a8387a4e2779ca6b9b3f37a5d5b0">&#9670;&#160;</a></span>flush_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::flush_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a flush the batching pipeline and waits for it to propagate. </p>
<p>See <code><a class="el" href="classrerun_1_1RecordingStream.html" title="A RecordingStream handles everything related to logging data into Rerun.">RecordingStream</a></code> docs for ordering semantics and multithreading guarantees. </p>

</div>
</div>
<a id="afb7984ede28f5b53d04a1d33ebb8b36f" name="afb7984ede28f5b53d04a1d33ebb8b36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7984ede28f5b53d04a1d33ebb8b36f">&#9670;&#160;</a></span>set_time_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_time_sequence </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>sequence_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.set_time_sequence("frame_nr", frame_nr)</code>.</p>
<p>You can remove a timeline from subsequent log calls again using <code>rec.disable_timeline</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6" title="Set the current time of the recording, for the current calling thread.">set_time_nanos</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ac6e545fd9b3b51fea85d2427b9536552" title="Set the current time of the recording, for the current calling thread.">set_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="ac6e545fd9b3b51fea85d2427b9536552" name="ac6e545fd9b3b51fea85d2427b9536552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e545fd9b3b51fea85d2427b9536552">&#9670;&#160;</a></span>set_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TClock &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_time </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; TClock &gt;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.set_time("sim_time", sim_time_secs)</code>.</p>
<p>You can remove a timeline from subsequent log calls again using <code>rec.disable_timeline</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6" title="Set the current time of the recording, for the current calling thread.">set_time_nanos</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="aa411c69361e169529daac832914fea4b" name="aa411c69361e169529daac832914fea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa411c69361e169529daac832914fea4b">&#9670;&#160;</a></span>set_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRep , typename TPeriod &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_time </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; TRep, TPeriod &gt;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.set_time("sim_time", sim_time_secs)</code>.</p>
<p>You can remove a timeline from subsequent log calls again using <code>rec.disable_timeline</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6" title="Set the current time of the recording, for the current calling thread.">set_time_nanos</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="ad735156502aea8eecd0a5eb2f6678d55" name="ad735156502aea8eecd0a5eb2f6678d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad735156502aea8eecd0a5eb2f6678d55">&#9670;&#160;</a></span>set_time_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_time_seconds </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.set_time_seconds("sim_time", sim_time_secs)</code>.</p>
<p>You can remove a timeline from subsequent log calls again using <code>rec.disable_timeline</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6" title="Set the current time of the recording, for the current calling thread.">set_time_nanos</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ac6e545fd9b3b51fea85d2427b9536552" title="Set the current time of the recording, for the current calling thread.">set_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="aa39bd4985d930a9c878187d50058a2b6" name="aa39bd4985d930a9c878187d50058a2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39bd4985d930a9c878187d50058a2b6">&#9670;&#160;</a></span>set_time_nanos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::set_time_nanos </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nanos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.set_time_nanos("sim_time", sim_time_nanos)</code>.</p>
<p>You can remove a timeline from subsequent log calls again using <code>rec.disable_timeline</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ac6e545fd9b3b51fea85d2427b9536552" title="Set the current time of the recording, for the current calling thread.">set_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="a3e94ef74d259599e14cb5c823a33531c" name="a3e94ef74d259599e14cb5c823a33531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e94ef74d259599e14cb5c823a33531c">&#9670;&#160;</a></span>disable_timeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::disable_timeline </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>timeline_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops logging to the specified timeline for subsequent log calls. </p>
<p>The timeline is still there, but will not be updated with any new data.</p>
<p>No-op if the timeline doesn't exist.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ac6e545fd9b3b51fea85d2427b9536552" title="Set the current time of the recording, for the current calling thread.">set_time</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a44f907e40ee2281ed40cd8b212560aa2" title="Clears out the current time of the recording, for the current calling thread.">reset_time</a> </dd></dl>

</div>
</div>
<a id="a44f907e40ee2281ed40cd8b212560aa2" name="a44f907e40ee2281ed40cd8b212560aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f907e40ee2281ed40cd8b212560aa2">&#9670;&#160;</a></span>reset_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::reset_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears out the current time of the recording, for the current calling thread. </p>
<p>Used for all subsequent logging performed from this same thread, until the next call to one of the time setting methods.</p>
<p>For example: <code>rec.reset_time()</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#afb7984ede28f5b53d04a1d33ebb8b36f" title="Set the current time of the recording, for the current calling thread.">set_time_sequence</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad735156502aea8eecd0a5eb2f6678d55" title="Set the current time of the recording, for the current calling thread.">set_time_seconds</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa39bd4985d930a9c878187d50058a2b6" title="Set the current time of the recording, for the current calling thread.">set_time_nanos</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a3e94ef74d259599e14cb5c823a33531c" title="Stops logging to the specified timeline for subsequent log calls.">disable_timeline</a> </dd></dl>

</div>
</div>
<a id="a7badac918d44d66e04e948f38818ff11" name="a7badac918d44d66e04e948f38818ff11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7badac918d44d66e04e948f38818ff11">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::log </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches. </p>
<p>This is the main entry point for logging data to rerun. It can be used to log anything that implements the <code>AsComponents&lt;T&gt;</code> trait.</p>
<p>When logging data, you must always provide an <a href="https://www.rerun.io/docs/concepts/entity-path">entity_path</a> for identifying the data. Note that the path prefix "rerun/" is considered reserved for use by the Rerun SDK itself and should not be used for logging user data. This is where Rerun will log additional information such as warnings.</p>
<p>The most common way to log is with one of the rerun archetypes, all of which implement the <code>AsComponents</code> trait.</p>
<p>For example, to log two 3D points: </p><div class="fragment"><div class="line">rec.log(<span class="stringliteral">&quot;my/point&quot;</span>, <a class="code hl_struct" href="structrerun_1_1archetypes_1_1Points3D.html">rerun::Points3D</a>({{0.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}}));</div>
<div class="ttc" id="astructrerun_1_1archetypes_1_1Points3D_html"><div class="ttname"><a href="structrerun_1_1archetypes_1_1Points3D.html">rerun::archetypes::Points3D</a></div><div class="ttdoc">Archetype: A 3D point cloud with positions and optional colors, radii, labels, etc.</div><div class="ttdef"><b>Definition</b> points3d.hpp:66</div></div>
</div><!-- fragment --><p>The <code>log</code> function can flexibly accept an arbitrary number of additional objects which will be merged into the first entity so long as they don't expose conflicting components, for instance: </p><div class="fragment"><div class="line"><span class="comment">// Log three points with arrows sticking out of them:</span></div>
<div class="line">rec.log(</div>
<div class="line">    <span class="stringliteral">&quot;my/points&quot;</span>,</div>
<div class="line">    <a class="code hl_struct" href="structrerun_1_1archetypes_1_1Points3D.html">rerun::Points3D</a>({{0.2f, 0.5f, 0.3f}, {0.9f, 1.2f, 0.1f}, {1.0f, 4.2f, 0.3f}})</div>
<div class="line">            .with_radii({0.1, 0.2, 0.3}),</div>
<div class="line">    rerun::Arrows3D::from_vectors({{0.3f, 2.1f, 0.2f}, {0.9f, -1.1, 2.3f}, {-0.4f, 0.5f, 2.9f}})</div>
<div class="line">);</div>
</div><!-- fragment --><p>Any failures that may occur during serialization are handled with <code><a class="el" href="classrerun_1_1Error.html#a0419e00a9d421e449b50fb2a8dc6cd4a" title="Handle this error based on the set log handler.">Error::handle</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77" title="Logs one or more archetype and/or component batches.">try_log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac" title="Logs one or more archetype and/or component batches as static data.">log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be" title="Logs one or more archetype and/or component batches optionally static, returning an error.">try_log_with_static</a> </dd></dl>

</div>
</div>
<a id="aa81101fe821143a1388d1797cd40caac" name="aa81101fe821143a1388d1797cd40caac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81101fe821143a1388d1797cd40caac">&#9670;&#160;</a></span>log_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::log_static </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches as static data. </p>
<p>Like <code>log</code> but logs the data as static: Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type.</p>
<p>Failures are handled with <code><a class="el" href="classrerun_1_1Error.html#a0419e00a9d421e449b50fb2a8dc6cd4a" title="Handle this error based on the set log handler.">Error::handle</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11" title="Logs one or more archetype and/or component batches.">log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350" title="Logs one or more archetype and/or component batches as static data, returning an error.">try_log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be" title="Logs one or more archetype and/or component batches optionally static, returning an error.">try_log_with_static</a> </dd></dl>

</div>
</div>
<a id="a934d8c4aef75b6e65f4d50858ca50a77" name="a934d8c4aef75b6e65f4d50858ca50a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934d8c4aef75b6e65f4d50858ca50a77">&#9670;&#160;</a></span>try_log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches. </p>
<p>See <code>log</code> for more information. Unlike <code>log</code> this method returns an error if an error occurs during serialization or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11" title="Logs one or more archetype and/or component batches.">log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350" title="Logs one or more archetype and/or component batches as static data, returning an error.">try_log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be" title="Logs one or more archetype and/or component batches optionally static, returning an error.">try_log_with_static</a> </dd></dl>

</div>
</div>
<a id="a2b92279ac1810188133d6129ec62e350" name="a2b92279ac1810188133d6129ec62e350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b92279ac1810188133d6129ec62e350">&#9670;&#160;</a></span>try_log_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_static </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches as static data, returning an error. </p>
<p>See <code>log</code>/<code>log_static</code> for more information. Unlike <code>log_static</code> this method returns if an error occurs during serialization or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error if an error occurs during serialization or logging.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac" title="Logs one or more archetype and/or component batches as static data.">log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77" title="Logs one or more archetype and/or component batches.">try_log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be" title="Logs one or more archetype and/or component batches optionally static, returning an error.">try_log_with_static</a> </dd></dl>

</div>
</div>
<a id="a5d30f2c4f6db919bf20ce4f6e2a31af6" name="a5d30f2c4f6db919bf20ce4f6e2a31af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d30f2c4f6db919bf20ce4f6e2a31af6">&#9670;&#160;</a></span>log_with_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::log_with_static </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches optionally static, returning an error. </p>
<p>See <code>log</code>/<code>log_static</code> for more information. Returns an error if an error occurs during serialization or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11" title="Logs one or more archetype and/or component batches.">log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77" title="Logs one or more archetype and/or component batches.">try_log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac" title="Logs one or more archetype and/or component batches as static data.">log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350" title="Logs one or more archetype and/or component batches as static data, returning an error.">try_log_static</a> </dd></dl>

</div>
</div>
<a id="ad9bbd6768189ee4efc93a55c2aed71be" name="ad9bbd6768189ee4efc93a55c2aed71be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bbd6768189ee4efc93a55c2aed71be">&#9670;&#160;</a></span>try_log_with_static()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_with_static </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>archetypes_or_collections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs one or more archetype and/or component batches optionally static, returning an error. </p>
<p>See <code>log</code>/<code>log_static</code> for more information. Returns an error if an error occurs during serialization or logging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included. </td></tr>
    <tr><td class="paramname">archetypes_or_collections</td><td>Any type for which the <code>AsComponents&lt;T&gt;</code> trait is implemented. This is the case for any archetype or <code>std::vector</code>/<code>std::array</code>/C-array of components implements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error if an error occurs during serialization or logging.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11" title="Logs one or more archetype and/or component batches.">log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77" title="Logs one or more archetype and/or component batches.">try_log</a>, <a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac" title="Logs one or more archetype and/or component batches as static data.">log_static</a>, <a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350" title="Logs one or more archetype and/or component batches as static data, returning an error.">try_log_static</a> </dd></dl>

</div>
</div>
<a id="a45a9488921178fc182a14be6406e4fc4" name="a45a9488921178fc182a14be6406e4fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a9488921178fc182a14be6406e4fc4">&#9670;&#160;</a></span>try_log_serialized_batches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_serialized_batches </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structrerun_1_1DataCell.html">DataCell</a> &gt;&#160;</td>
          <td class="paramname"><em>batches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs several serialized batches batches, returning an error on failure. </p>
<p>This is a more low-level API than <code>log</code>/`log_static\ and requires you to already serialize the data ahead of time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included. </td></tr>
    <tr><td class="paramname">batches</td><td>The serialized batches to log.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#a7badac918d44d66e04e948f38818ff11" title="Logs one or more archetype and/or component batches.">log</a></code>, <code><a class="el" href="classrerun_1_1RecordingStream.html#a934d8c4aef75b6e65f4d50858ca50a77" title="Logs one or more archetype and/or component batches.">try_log</a></code>, <code><a class="el" href="classrerun_1_1RecordingStream.html#aa81101fe821143a1388d1797cd40caac" title="Logs one or more archetype and/or component batches as static data.">log_static</a></code>, <code><a class="el" href="classrerun_1_1RecordingStream.html#a2b92279ac1810188133d6129ec62e350" title="Logs one or more archetype and/or component batches as static data, returning an error.">try_log_static</a></code>, <code><a class="el" href="classrerun_1_1RecordingStream.html#ad9bbd6768189ee4efc93a55c2aed71be" title="Logs one or more archetype and/or component batches optionally static, returning an error.">try_log_with_static</a></code> </dd></dl>

</div>
</div>
<a id="a116d19da4653f4b584225fa4d9b4358e" name="a116d19da4653f4b584225fa4d9b4358e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116d19da4653f4b584225fa4d9b4358e">&#9670;&#160;</a></span>try_log_data_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_data_row </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_data_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrerun_1_1DataCell.html">DataCell</a> *&#160;</td>
          <td class="paramname"><em>data_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inject_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bottom level API that logs raw data cells to the recording stream. </p>
<p>In order to use this you need to pass serialized Arrow data cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity_path</td><td>Path to the entity in the space hierarchy. </td></tr>
    <tr><td class="paramname">num_data_cells</td><td>Number of data cells passed in. </td></tr>
    <tr><td class="paramname">data_cells</td><td>The data cells to log. </td></tr>
    <tr><td class="paramname">inject_time</td><td>If set to <code>true</code>, the row's timestamp data will be overridden using the recording streams internal clock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#a45a9488921178fc182a14be6406e4fc4" title="Logs several serialized batches batches, returning an error on failure.">try_log_serialized_batches</a></code> </dd></dl>

</div>
</div>
<a id="a20798d7ea74cce5c8174e5cacd0a2c47" name="a20798d7ea74cce5c8174e5cacd0a2c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20798d7ea74cce5c8174e5cacd0a2c47">&#9670;&#160;</a></span>log_file_from_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::log_file_from_path </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path_prefix</em> = <code>std::string_view()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs the file at the given <code>path</code> using all <code>DataLoader</code>s available. </p>
<p>A single <code>path</code> might be handled by more than one loader.</p>
<p>This method blocks until either at least one <code>DataLoader</code> starts streaming data in or all of them fail.</p>
<p>See <a href="https://www.rerun.io/docs/reference/data-loaders/overview">https://www.rerun.io/docs/reference/data-loaders/overview</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file to be logged. </td></tr>
    <tr><td class="paramname">entity_path_prefix</td><td>What should the logged entity paths be prefixed with? </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#a4fad856c89909271e411cc711185b03b" title="Logs the file at the given path using all DataLoaders available.">try_log_file_from_path</a></code> </dd></dl>

</div>
</div>
<a id="a4fad856c89909271e411cc711185b03b" name="a4fad856c89909271e411cc711185b03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fad856c89909271e411cc711185b03b">&#9670;&#160;</a></span>try_log_file_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_file_from_path </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path_prefix</em> = <code>std::string_view()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs the file at the given <code>path</code> using all <code>DataLoader</code>s available. </p>
<p>A single <code>path</code> might be handled by more than one loader.</p>
<p>This method blocks until either at least one <code>DataLoader</code> starts streaming data in or all of them fail.</p>
<p>See <a href="https://www.rerun.io/docs/reference/data-loaders/overview">https://www.rerun.io/docs/reference/data-loaders/overview</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file to be logged. </td></tr>
    <tr><td class="paramname">entity_path_prefix</td><td>What should the logged entity paths be prefixed with? </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#a20798d7ea74cce5c8174e5cacd0a2c47" title="Logs the file at the given path using all DataLoaders available.">log_file_from_path</a></code> </dd></dl>

</div>
</div>
<a id="a8f253422a7adc2a19b89d1538c05bcac" name="a8f253422a7adc2a19b89d1538c05bcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f253422a7adc2a19b89d1538c05bcac">&#9670;&#160;</a></span>log_file_from_contents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rerun::RecordingStream::log_file_from_contents </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>contents_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path_prefix</em> = <code>std::string_view()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs the given <code>contents</code> using all <code>DataLoader</code>s available. </p>
<p>A single <code>path</code> might be handled by more than one loader.</p>
<p>This method blocks until either at least one <code>DataLoader</code> starts streaming data in or all of them fail.</p>
<p>See <a href="https://www.rerun.io/docs/reference/data-loaders/overview">https://www.rerun.io/docs/reference/data-loaders/overview</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file that the <code>contents</code> belong to. </td></tr>
    <tr><td class="paramname">contents</td><td>Contents to be logged. </td></tr>
    <tr><td class="paramname">contents_size</td><td>Size in bytes of the <code>contents</code>. </td></tr>
    <tr><td class="paramname">entity_path_prefix</td><td>What should the logged entity paths be prefixed with? </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#ae34190dd8becde6fb08dd5e13ca82677" title="Logs the given contents using all DataLoaders available.">try_log_file_from_contents</a></code> </dd></dl>

</div>
</div>
<a id="ae34190dd8becde6fb08dd5e13ca82677" name="ae34190dd8becde6fb08dd5e13ca82677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34190dd8becde6fb08dd5e13ca82677">&#9670;&#160;</a></span>try_log_file_from_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::RecordingStream::try_log_file_from_contents </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>contents_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>entity_path_prefix</em> = <code>std::string_view()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>static_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs the given <code>contents</code> using all <code>DataLoader</code>s available. </p>
<p>A single <code>path</code> might be handled by more than one loader.</p>
<p>This method blocks until either at least one <code>DataLoader</code> starts streaming data in or all of them fail.</p>
<p>See <a href="https://www.rerun.io/docs/reference/data-loaders/overview">https://www.rerun.io/docs/reference/data-loaders/overview</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file that the <code>contents</code> belong to. </td></tr>
    <tr><td class="paramname">contents</td><td>Contents to be logged. </td></tr>
    <tr><td class="paramname">contents_size</td><td>Size in bytes of the <code>contents</code>. </td></tr>
    <tr><td class="paramname">entity_path_prefix</td><td>What should the logged entity paths be prefixed with? </td></tr>
    <tr><td class="paramname">static_</td><td>If true, the logged components will be static. Static data has no time associated with it, exists on all timelines, and unconditionally shadows any temporal data of the same type. Otherwise, the data will be timestamped automatically with <code>log_time</code> and <code>log_tick</code>. Additional timelines set by <code>set_time_sequence</code> or <code>set_time</code> will also be included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#a8f253422a7adc2a19b89d1538c05bcac" title="Logs the given contents using all DataLoaders available.">log_file_from_contents</a></code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rerun/<a class="el" href="recording__stream_8hpp_source.html">recording_stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacererun.html">rerun</a></li><li class="navelem"><a class="el" href="classrerun_1_1RecordingStream.html">RecordingStream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
