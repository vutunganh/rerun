<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.7" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rerun C++ SDK: rerun::ComponentColumn Struct Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">Rerun C++ SDK
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structrerun_1_1ComponentColumn.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structrerun_1_1ComponentColumn-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rerun::ComponentColumn Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Arrow-encoded data of a column of components.  
 <a href="structrerun_1_1ComponentColumn.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="component__column_8hpp_source.html">rerun/component_column.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeede60ca85c8b829e1e89ed221dc02fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrerun_1_1Error.html">Error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#aeede60ca85c8b829e1e89ed221dc02fb">to_c_ffi_struct</a> (rr_component_column &amp;out_component_batch) const</td></tr>
<tr class="memdesc:aeede60ca85c8b829e1e89ed221dc02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">To rerun C API component batch.  <br /></td></tr>
<tr class="separator:aeede60ca85c8b829e1e89ed221dc02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3f16d7386a6525b6f4ab32d6b104afd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3f16d7386a6525b6f4ab32d6b104afd"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#ab3f16d7386a6525b6f4ab32d6b104afd">from_loggable_with_lengths</a> (const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; T &gt; &amp;components, const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt; &amp;lengths)</td></tr>
<tr class="memdesc:ab3f16d7386a6525b6f4ab32d6b104afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new component column from a collection of component instances.  <br /></td></tr>
<tr class="separator:ab3f16d7386a6525b6f4ab32d6b104afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3870d5fe90b6b0cf4b1ca55a1c674c88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3870d5fe90b6b0cf4b1ca55a1c674c88"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#a3870d5fe90b6b0cf4b1ca55a1c674c88">from_loggable</a> (const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; T &gt; &amp;components)</td></tr>
<tr class="memdesc:a3870d5fe90b6b0cf4b1ca55a1c674c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new component column from a collection of component instances where each run has a length of one.  <br /></td></tr>
<tr class="separator:a3870d5fe90b6b0cf4b1ca55a1c674c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5efb5d54f10e1b1dca43ca9ab6d967"><td class="memTemplParams" colspan="2"><a id="afb5efb5d54f10e1b1dca43ca9ab6d967" name="afb5efb5d54f10e1b1dca43ca9ab6d967"></a>
template&lt;typename Archetype &gt; </td></tr>
<tr class="memitem:afb5efb5d54f10e1b1dca43ca9ab6d967"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_indicators</b> (uint32_t num_indicators)</td></tr>
<tr class="memdesc:afb5efb5d54f10e1b1dca43ca9ab6d967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new component column with a given number of archetype indicators for a given archetype type. <br /></td></tr>
<tr class="separator:afb5efb5d54f10e1b1dca43ca9ab6d967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa026e8626098ab9c39ab4d207b93b87f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#aa026e8626098ab9c39ab4d207b93b87f">from_batch_with_lengths</a> (<a class="el" href="structrerun_1_1ComponentBatch.html">ComponentBatch</a> batch, const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt; &amp;lengths, std::shared_ptr&lt; arrow::DataType &gt; list_array_type)</td></tr>
<tr class="memdesc:aa026e8626098ab9c39ab4d207b93b87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new component batch partition from a batch and a collection of run lengths.  <br /></td></tr>
<tr class="separator:aa026e8626098ab9c39ab4d207b93b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6e6b2d63aae8b445672d0dc596ecdf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#a8d6e6b2d63aae8b445672d0dc596ecdf">from_batch_with_offsets</a> (<a class="el" href="structrerun_1_1ComponentBatch.html">ComponentBatch</a> batch, <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt; offsets, std::shared_ptr&lt; arrow::DataType &gt; list_array_type)</td></tr>
<tr class="memdesc:a8d6e6b2d63aae8b445672d0dc596ecdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new component batch partition from a batch and a collection of component offsets.  <br /></td></tr>
<tr class="separator:a8d6e6b2d63aae8b445672d0dc596ecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53da5f1f8cacbf4ef361f4d9ffd27ab1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53da5f1f8cacbf4ef361f4d9ffd27ab1"><td class="memTemplItemLeft" align="right" valign="top">static const std::shared_ptr&lt; arrow::DataType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#a53da5f1f8cacbf4ef361f4d9ffd27ab1">list_array_type_for</a> ()</td></tr>
<tr class="memdesc:a53da5f1f8cacbf4ef361f4d9ffd27ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list array type for the given loggable type.  <br /></td></tr>
<tr class="separator:a53da5f1f8cacbf4ef361f4d9ffd27ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88c2fc67e1acf64447afd98fc3b09ba"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; arrow::DataType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrerun_1_1ComponentColumn.html#aa88c2fc67e1acf64447afd98fc3b09ba">list_array_type_for</a> (std::shared_ptr&lt; arrow::DataType &gt; inner_type)</td></tr>
<tr class="memdesc:aa88c2fc67e1acf64447afd98fc3b09ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new arrow::Datatype for an underlying type.  <br /></td></tr>
<tr class="separator:aa88c2fc67e1acf64447afd98fc3b09ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9250846feeb80b12621ae67157e43eaa"><td class="memItemLeft" align="right" valign="top"><a id="a9250846feeb80b12621ae67157e43eaa" name="a9250846feeb80b12621ae67157e43eaa"></a>
std::shared_ptr&lt; arrow::Array &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array</b></td></tr>
<tr class="memdesc:a9250846feeb80b12621ae67157e43eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrow-encoded list array of component batches. <br /></td></tr>
<tr class="separator:a9250846feeb80b12621ae67157e43eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d14c6aeeba42bca08e9b822231b87a2"><td class="memItemLeft" align="right" valign="top"><a id="a6d14c6aeeba42bca08e9b822231b87a2" name="a6d14c6aeeba42bca08e9b822231b87a2"></a>
<a class="el" href="namespacererun.html#ad07a56cc925ff9702699d7419e54b02f">ComponentTypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>component_type</b></td></tr>
<tr class="memdesc:a6d14c6aeeba42bca08e9b822231b87a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the component instances in array. <br /></td></tr>
<tr class="separator:a6d14c6aeeba42bca08e9b822231b87a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Arrow-encoded data of a column of components. </p>
<p>This is essentially an array of <code><a class="el" href="structrerun_1_1ComponentBatch.html" title="Arrow-encoded data of a single batch components for a single entity.">rerun::ComponentBatch</a></code> with all batches continuously in a single array.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classrerun_1_1RecordingStream.html#ad17571d51185ce2fc2fc2f5c3070ad65" title="Directly log a columns of data to Rerun.">rerun::RecordingStream::send_columns</a></code> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3f16d7386a6525b6f4ab32d6b104afd" name="ab3f16d7386a6525b6f4ab32d6b104afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f16d7386a6525b6f4ab32d6b104afd">&#9670;&#160;</a></span>from_loggable_with_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt; rerun::ComponentColumn::from_loggable_with_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new component column from a collection of component instances. </p>
<p>Automatically registers the component type the first time this type is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">components</td><td>Continuous collection of components which is about to be partitioned. </td></tr>
    <tr><td class="paramname">lengths</td><td>The number of components in each run. for <code><a class="el" href="classrerun_1_1RecordingStream.html#ad17571d51185ce2fc2fc2f5c3070ad65" title="Directly log a columns of data to Rerun.">rerun::RecordingStream::send_columns</a></code>, this specifies the number of components at each time point. The sum of the lengths must be equal to the number of components in the batch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3870d5fe90b6b0cf4b1ca55a1c674c88" name="a3870d5fe90b6b0cf4b1ca55a1c674c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3870d5fe90b6b0cf4b1ca55a1c674c88">&#9670;&#160;</a></span>from_loggable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt; rerun::ComponentColumn::from_loggable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new component column from a collection of component instances where each run has a length of one. </p>
<p>When used with <code><a class="el" href="classrerun_1_1RecordingStream.html#ad17571d51185ce2fc2fc2f5c3070ad65" title="Directly log a columns of data to Rerun.">rerun::RecordingStream::send_columns</a></code>, this is equivalent to <code>from_loggable(components, std::vector{1, 1, ...})</code>. I.e. there's a single component for each time point.</p>
<p>Automatically registers the component type the first time this type is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">components</td><td>Continuous collection of components which is about to be partitioned into runs of length one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa026e8626098ab9c39ab4d207b93b87f" name="aa026e8626098ab9c39ab4d207b93b87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa026e8626098ab9c39ab4d207b93b87f">&#9670;&#160;</a></span>from_batch_with_lengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt; rerun::ComponentColumn::from_batch_with_lengths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrerun_1_1ComponentBatch.html">ComponentBatch</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; arrow::DataType &gt;&#160;</td>
          <td class="paramname"><em>list_array_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new component batch partition from a batch and a collection of run lengths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>A batch of components which is about to be partitioned. </td></tr>
    <tr><td class="paramname">lengths</td><td>The number of components in each run. for <code><a class="el" href="classrerun_1_1RecordingStream.html#ad17571d51185ce2fc2fc2f5c3070ad65" title="Directly log a columns of data to Rerun.">rerun::RecordingStream::send_columns</a></code>, this specifies the number of components at each time point. The sum of the lengths must be equal to the number of components in the batch. </td></tr>
    <tr><td class="paramname">list_array_type</td><td>The type of the list array to use for the component column. Can be retrieved using <code>list_array_type_for&lt;T&gt;()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d6e6b2d63aae8b445672d0dc596ecdf" name="a8d6e6b2d63aae8b445672d0dc596ecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6e6b2d63aae8b445672d0dc596ecdf">&#9670;&#160;</a></span>from_batch_with_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Result.html">Result</a>&lt; <a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a> &gt; rerun::ComponentColumn::from_batch_with_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrerun_1_1ComponentBatch.html">ComponentBatch</a>&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; uint32_t &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; arrow::DataType &gt;&#160;</td>
          <td class="paramname"><em>list_array_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new component batch partition from a batch and a collection of component offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>A batch of components which is about to be partitioned. </td></tr>
    <tr><td class="paramname">offsets</td><td>An offset within <code>batch</code> for each array of components. The last offset is the total number of components in the batch. Meaning that this array has to be one element longer than the number of component runs. E.g. a <code>ParitionedComponentBatch</code> with a single component would have an offset array of <code>[0, 1]</code>. A <code><a class="el" href="structrerun_1_1ComponentColumn.html" title="Arrow-encoded data of a column of components.">ComponentColumn</a></code> with 5 components divided into runs of length 2 and 3 </td></tr>
    <tr><td class="paramname">list_array_type</td><td>The type of the list array to use for the component column. Can be retrieved using <code>list_array_type_for&lt;T&gt;()</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53da5f1f8cacbf4ef361f4d9ffd27ab1" name="a53da5f1f8cacbf4ef361f4d9ffd27ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53da5f1f8cacbf4ef361f4d9ffd27ab1">&#9670;&#160;</a></span>list_array_type_for() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::shared_ptr&lt; arrow::DataType &gt; &amp; rerun::ComponentColumn::list_array_type_for </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list array type for the given loggable type. </p>
<p>Lazily creates the type on first call and then returns a reference to it. </p>

</div>
</div>
<a id="aa88c2fc67e1acf64447afd98fc3b09ba" name="aa88c2fc67e1acf64447afd98fc3b09ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88c2fc67e1acf64447afd98fc3b09ba">&#9670;&#160;</a></span>list_array_type_for() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; arrow::DataType &gt; rerun::ComponentColumn::list_array_type_for </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; arrow::DataType &gt;&#160;</td>
          <td class="paramname"><em>inner_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new arrow::Datatype for an underlying type. </p>
<p>To avoid repeated allocation, use the templated version of this method. </p>

</div>
</div>
<a id="aeede60ca85c8b829e1e89ed221dc02fb" name="aeede60ca85c8b829e1e89ed221dc02fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeede60ca85c8b829e1e89ed221dc02fb">&#9670;&#160;</a></span>to_c_ffi_struct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Error.html">Error</a> rerun::ComponentColumn::to_c_ffi_struct </td>
          <td>(</td>
          <td class="paramtype">rr_component_column &amp;&#160;</td>
          <td class="paramname"><em>out_component_batch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To rerun C API component batch. </p>
<p>The resulting <code>rr_component_column</code> keeps the <code>arrow::Array</code> alive until it is released. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>rerun/<a class="el" href="component__column_8hpp_source.html">component_column.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacererun.html">rerun</a></li><li class="navelem"><a class="el" href="structrerun_1_1ComponentColumn.html">ComponentColumn</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
