<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.7" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rerun C++ SDK: rerun::Collection&lt; TElement &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
  <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">Rerun C++ SDK
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrerun_1_1Collection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classrerun_1_1Collection-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rerun::Collection&lt; TElement &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic collection of elements that are roughly contiguous in memory.  
 <a href="classrerun_1_1Collection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="collection_8hpp_source.html">rerun/collection.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a925dfe9a1c265715c6dc7719757d80cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a925dfe9a1c265715c6dc7719757d80cf">value_type</a> = TElement</td></tr>
<tr class="memdesc:a925dfe9a1c265715c6dc7719757d80cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the elements in the collection.  <br /></td></tr>
<tr class="separator:a925dfe9a1c265715c6dc7719757d80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fac05b926ac8a99a703bcadf2e0f43c"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a0fac05b926ac8a99a703bcadf2e0f43c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a0fac05b926ac8a99a703bcadf2e0f43c">Adapter</a> = <a class="el" href="structrerun_1_1CollectionAdapter.html">CollectionAdapter</a>&lt; TElement, std::remove_cv_t&lt; std::remove_reference_t&lt; TContainer &gt; &gt;, std::enable_if_t&lt; true &gt; &gt;</td></tr>
<tr class="memdesc:a0fac05b926ac8a99a703bcadf2e0f43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an adapter given an input container type.  <br /></td></tr>
<tr class="separator:a0fac05b926ac8a99a703bcadf2e0f43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4fd53cfdbace57cd1409c55610820c83"><td class="memItemLeft" align="right" valign="top"><a id="a4fd53cfdbace57cd1409c55610820c83" name="a4fd53cfdbace57cd1409c55610820c83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Collection</b> ()</td></tr>
<tr class="memdesc:a4fd53cfdbace57cd1409c55610820c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty collection. <br /></td></tr>
<tr class="separator:a4fd53cfdbace57cd1409c55610820c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5787576235bed9439b3b9af65c0eab4"><td class="memTemplParams" colspan="2"><a id="ab5787576235bed9439b3b9af65c0eab4" name="ab5787576235bed9439b3b9af65c0eab4"></a>
template&lt;typename TContainer , typename  = std::enable_if_t&lt;                !std::is_same_v&lt;std::remove_reference_t&lt;TContainer&gt;, Collection&lt;TElement&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:ab5787576235bed9439b3b9af65c0eab4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Collection</b> (TContainer &amp;&amp;input)</td></tr>
<tr class="memdesc:ab5787576235bed9439b3b9af65c0eab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using a <code><a class="el" href="structrerun_1_1CollectionAdapter.html" title="The rerun::CollectionAdapter trait is responsible for mapping an input argument to a rerun::Collectio...">CollectionAdapter</a></code> for the given input type. <br /></td></tr>
<tr class="separator:ab5787576235bed9439b3b9af65c0eab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfdd313aa1b293057a662a5c6acdc67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#accfdd313aa1b293057a662a5c6acdc67">Collection</a> (const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;other)</td></tr>
<tr class="memdesc:accfdd313aa1b293057a662a5c6acdc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:accfdd313aa1b293057a662a5c6acdc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f7b9965aef85fc850b375bd834b495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a64f7b9965aef85fc850b375bd834b495">operator=</a> (const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;other)</td></tr>
<tr class="memdesc:a64f7b9965aef85fc850b375bd834b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <br /></td></tr>
<tr class="separator:a64f7b9965aef85fc850b375bd834b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0fcea06c095883c3703dea6211a17e"><td class="memItemLeft" align="right" valign="top"><a id="a3a0fcea06c095883c3703dea6211a17e" name="a3a0fcea06c095883c3703dea6211a17e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Collection</b> (<a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a3a0fcea06c095883c3703dea6211a17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3a0fcea06c095883c3703dea6211a17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6f5f42bfc793c94d80edc0d4d0eb9f"><td class="memItemLeft" align="right" valign="top"><a id="aac6f5f42bfc793c94d80edc0d4d0eb9f" name="aac6f5f42bfc793c94d80edc0d4d0eb9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:aac6f5f42bfc793c94d80edc0d4d0eb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:aac6f5f42bfc793c94d80edc0d4d0eb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1f575e7fde2e7f10d1b5ed5d9c7096"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#acd1f575e7fde2e7f10d1b5ed5d9c7096">Collection</a> (std::initializer_list&lt; TElement &gt; <a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a>)</td></tr>
<tr class="memdesc:acd1f575e7fde2e7f10d1b5ed5d9c7096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a initializer list of elements that are compatible with TElement.  <br /></td></tr>
<tr class="separator:acd1f575e7fde2e7f10d1b5ed5d9c7096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8020866ed10f8a7114bf81fc6e7bb55a"><td class="memItemLeft" align="right" valign="top"><a id="a8020866ed10f8a7114bf81fc6e7bb55a" name="a8020866ed10f8a7114bf81fc6e7bb55a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;other)</td></tr>
<tr class="memdesc:a8020866ed10f8a7114bf81fc6e7bb55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of this collection with another. <br /></td></tr>
<tr class="separator:a8020866ed10f8a7114bf81fc6e7bb55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df0738a42ff236c6473b5d41be370e0"><td class="memItemLeft" align="right" valign="top"><a id="a9df0738a42ff236c6473b5d41be370e0" name="a9df0738a42ff236c6473b5d41be370e0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a9df0738a42ff236c6473b5d41be370e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of instances in this collection. <br /></td></tr>
<tr class="separator:a9df0738a42ff236c6473b5d41be370e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354dc4a470ac8cabbd1606d389b388c7"><td class="memItemLeft" align="right" valign="top"><a id="a354dc4a470ac8cabbd1606d389b388c7" name="a354dc4a470ac8cabbd1606d389b388c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a354dc4a470ac8cabbd1606d389b388c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the collection is empty. <br /></td></tr>
<tr class="separator:a354dc4a470ac8cabbd1606d389b388c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba0a668d959b1393252219c87e9c8f7"><td class="memItemLeft" align="right" valign="top">const TElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a> () const</td></tr>
<tr class="memdesc:afba0a668d959b1393252219c87e9c8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the underlying data.  <br /></td></tr>
<tr class="separator:afba0a668d959b1393252219c87e9c8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684161df6931bead0262424c9c5bcd74"><td class="memItemLeft" align="right" valign="top"><a id="a684161df6931bead0262424c9c5bcd74" name="a684161df6931bead0262424c9c5bcd74"></a>
const TElement *&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="memdesc:a684161df6931bead0262424c9c5bcd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(andreas): Return proper iterator. <br /></td></tr>
<tr class="separator:a684161df6931bead0262424c9c5bcd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61349c662a586cea52fe388a940c51d0"><td class="memItemLeft" align="right" valign="top"><a id="a61349c662a586cea52fe388a940c51d0" name="a61349c662a586cea52fe388a940c51d0"></a>
const TElement *&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memdesc:a61349c662a586cea52fe388a940c51d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO(andreas): Return proper iterator. <br /></td></tr>
<tr class="separator:a61349c662a586cea52fe388a940c51d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f37b90e3c3ea772b27f45cba2089c2"><td class="memItemLeft" align="right" valign="top"><a id="a00f37b90e3c3ea772b27f45cba2089c2" name="a00f37b90e3c3ea772b27f45cba2089c2"></a>
const TElement &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i) const</td></tr>
<tr class="memdesc:a00f37b90e3c3ea772b27f45cba2089c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random read access to the underlying data. <br /></td></tr>
<tr class="separator:a00f37b90e3c3ea772b27f45cba2089c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e1461c701fc6de1d1f287341c81a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacererun.html#acdf7f503c6ab7a113a9d4d7f5191141f">CollectionOwnership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a55e1461c701fc6de1d1f287341c81a98">get_ownership</a> () const</td></tr>
<tr class="memdesc:a55e1461c701fc6de1d1f287341c81a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data ownership of collection.  <br /></td></tr>
<tr class="separator:a55e1461c701fc6de1d1f287341c81a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef01fd3c2d8661e4095f134c630e2c6e"><td class="memItemLeft" align="right" valign="top"><a id="aef01fd3c2d8661e4095f134c630e2c6e" name="aef01fd3c2d8661e4095f134c630e2c6e"></a>
std::vector&lt; TElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>to_vector</b> () const</td></tr>
<tr class="memdesc:aef01fd3c2d8661e4095f134c630e2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data into a new <code>std::vector</code>. <br /></td></tr>
<tr class="separator:aef01fd3c2d8661e4095f134c630e2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79f02f9d8498b458bcfae242fffd20b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79f02f9d8498b458bcfae242fffd20b3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a79f02f9d8498b458bcfae242fffd20b3">borrow</a> (const T *<a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a>, size_t num_instances)</td></tr>
<tr class="memdesc:a79f02f9d8498b458bcfae242fffd20b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrows binary compatible data into the collection.  <br /></td></tr>
<tr class="separator:a79f02f9d8498b458bcfae242fffd20b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6661918873d8c564daea7193efdcbacc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a6661918873d8c564daea7193efdcbacc">borrow</a> (const void *<a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a>, size_t num_instances)</td></tr>
<tr class="memdesc:a6661918873d8c564daea7193efdcbacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrows binary compatible data into the collection.  <br /></td></tr>
<tr class="separator:a6661918873d8c564daea7193efdcbacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2005ec0bd8a4927f3f6b3e405e4ddabc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrerun_1_1Collection.html#a2005ec0bd8a4927f3f6b3e405e4ddabc">take_ownership</a> (std::vector&lt; TElement &gt; &amp;&amp;<a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a>)</td></tr>
<tr class="memdesc:a2005ec0bd8a4927f3f6b3e405e4ddabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of a temporary <code>std::vector</code>, moving it into the collection.  <br /></td></tr>
<tr class="separator:a2005ec0bd8a4927f3f6b3e405e4ddabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b991db6aad590a25aa92f3810ccaa04"><td class="memItemLeft" align="right" valign="top"><a id="a0b991db6aad590a25aa92f3810ccaa04" name="a0b991db6aad590a25aa92f3810ccaa04"></a>
static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>take_ownership</b> (TElement &amp;&amp;<a class="el" href="classrerun_1_1Collection.html#afba0a668d959b1393252219c87e9c8f7">data</a>)</td></tr>
<tr class="memdesc:a0b991db6aad590a25aa92f3810ccaa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of a single element, moving it into the collection. <br /></td></tr>
<tr class="separator:a0b991db6aad590a25aa92f3810ccaa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TElement&gt;<br />
class rerun::Collection&lt; TElement &gt;</div><p>Generic collection of elements that are roughly contiguous in memory. </p>
<p>The most notable feature of the <code><a class="el" href="classrerun_1_1Collection.html" title="Generic collection of elements that are roughly contiguous in memory.">rerun::Collection</a></code> is that its data may be either <b>owned</b> or <b>borrowed</b>:</p><ul>
<li>Borrowed: If data is borrowed it <em>must</em> outlive its source (in particular, the pointer to the source mustn't invalidate)</li>
<li>Owned: Owned data is copied into an internal std::vector</li>
</ul>
<p>Collections are either filled explicitly using <code><a class="el" href="classrerun_1_1Collection.html#a79f02f9d8498b458bcfae242fffd20b3" title="Borrows binary compatible data into the collection.">Collection::borrow</a></code> &amp;<code><a class="el" href="classrerun_1_1Collection.html#a2005ec0bd8a4927f3f6b3e405e4ddabc" title="Takes ownership of a temporary std::vector, moving it into the collection.">Collection::take_ownership</a></code> or (most commonly in user code) implicitly using the <code><a class="el" href="structrerun_1_1CollectionAdapter.html" title="The rerun::CollectionAdapter trait is responsible for mapping an input argument to a rerun::Collectio...">CollectionAdapter</a></code> trait (see documentation for <code><a class="el" href="structrerun_1_1CollectionAdapter.html" title="The rerun::CollectionAdapter trait is responsible for mapping an input argument to a rerun::Collectio...">CollectionAdapter</a></code> for more information on how data can be adapted).</p>
<p>Other than being assignable, collections are generally immutable: there is no mutable data access in order to not violate the contract with the data lender and changes in size are not possible.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Implementation notes:</h2>
<p>Does intentionally not implement copy construction since this for the owned case this may be expensive. Typically, there should be no need to copy rerun collections, so this more than likely indicates a bug inside the Rerun SDK. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a925dfe9a1c265715c6dc7719757d80cf" name="a925dfe9a1c265715c6dc7719757d80cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925dfe9a1c265715c6dc7719757d80cf">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::value_type =  TElement</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the elements in the collection. </p>
<p>Note that calling this <code>value_type</code> makes it compatible with the STL. </p>

</div>
</div>
<a id="a0fac05b926ac8a99a703bcadf2e0f43c" name="a0fac05b926ac8a99a703bcadf2e0f43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fac05b926ac8a99a703bcadf2e0f43c">&#9670;&#160;</a></span>Adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::Adapter =  <a class="el" href="structrerun_1_1CollectionAdapter.html">CollectionAdapter</a>&lt; TElement, std::remove_cv_t&lt;std::remove_reference_t&lt;TContainer&gt; &gt;, std::enable_if_t&lt;true&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of an adapter given an input container type. </p>
<p>Note that the "container" passed may also be a single element of something. The only thing relevant is that there's an Adapter for it. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="accfdd313aa1b293057a662a5c6acdc67" name="accfdd313aa1b293057a662a5c6acdc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfdd313aa1b293057a662a5c6acdc67">&#9670;&#160;</a></span>Collection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::Collection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>If the data is owned, this will copy the data. If the data is borrowed, this will copy the borrow, meaning there's now (at least) two collections borrowing the same data. </p>

</div>
</div>
<a id="acd1f575e7fde2e7f10d1b5ed5d9c7096" name="acd1f575e7fde2e7f10d1b5ed5d9c7096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1f575e7fde2e7f10d1b5ed5d9c7096">&#9670;&#160;</a></span>Collection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::Collection </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; TElement &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a initializer list of elements that are compatible with TElement. </p>
<p>Takes ownership of the passed elements. If you want to avoid an allocation, you have to manually keep the data on the stack (e.g. as <code>std::array</code>) and construct the collection from this instead.</p>
<p>This is not done as a <code><a class="el" href="structrerun_1_1CollectionAdapter.html" title="The rerun::CollectionAdapter trait is responsible for mapping an input argument to a rerun::Collectio...">CollectionAdapter</a></code> since it tends to cause deduction issues (since there's special rules for overload resolution for initializer lists) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64f7b9965aef85fc850b375bd834b495" name="a64f7b9965aef85fc850b375bd834b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f7b9965aef85fc850b375bd834b495">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<p>If the data is owned, this will copy the data. If the data is borrowed, this will copy the borrow, meaning there's now (at least) two collections borrowing the same data. </p>

</div>
</div>
<a id="a79f02f9d8498b458bcfae242fffd20b3" name="a79f02f9d8498b458bcfae242fffd20b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f02f9d8498b458bcfae242fffd20b3">&#9670;&#160;</a></span>borrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::borrow </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borrows binary compatible data into the collection. </p>
<p>Borrowed data must outlive the collection! (If the pointer passed is into an std::vector or similar, this std::vector mustn't be resized.) The passed type must be binary compatible with the collection type.</p>
<p>Since <code><a class="el" href="classrerun_1_1Collection.html" title="Generic collection of elements that are roughly contiguous in memory.">rerun::Collection</a></code> does not provide write access, data is guaranteed to be unchanged by any function or operation taking on a <code><a class="el" href="classrerun_1_1Collection.html" title="Generic collection of elements that are roughly contiguous in memory.">Collection</a></code>. </p>

</div>
</div>
<a id="a6661918873d8c564daea7193efdcbacc" name="a6661918873d8c564daea7193efdcbacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6661918873d8c564daea7193efdcbacc">&#9670;&#160;</a></span>borrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Collection.html">Collection</a> <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::borrow </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borrows binary compatible data into the collection. </p>
<p>Version of <code>borrow</code> that takes a void pointer, omitting any checks.</p>
<p>Borrowed data must outlive the collection! (If the pointer passed is into an std::vector or similar, this std::vector mustn't be resized.)</p>
<p>Since <code><a class="el" href="classrerun_1_1Collection.html" title="Generic collection of elements that are roughly contiguous in memory.">rerun::Collection</a></code> does not provide write access, data is guaranteed to be unchanged by any function or operation taking on a <code><a class="el" href="classrerun_1_1Collection.html" title="Generic collection of elements that are roughly contiguous in memory.">rerun::Collection</a></code>. </p>

</div>
</div>
<a id="a2005ec0bd8a4927f3f6b3e405e4ddabc" name="a2005ec0bd8a4927f3f6b3e405e4ddabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2005ec0bd8a4927f3f6b3e405e4ddabc">&#9670;&#160;</a></span>take_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrerun_1_1Collection.html">Collection</a>&lt; TElement &gt; <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::take_ownership </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; TElement &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of a temporary <code>std::vector</code>, moving it into the collection. </p>
<p>Takes ownership of the data and moves it into the collection. </p>

</div>
</div>
<a id="afba0a668d959b1393252219c87e9c8f7" name="afba0a668d959b1393252219c87e9c8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba0a668d959b1393252219c87e9c8f7">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TElement * <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the underlying data. </p>
<p>Do not use this if the data is not continuous in memory! TODO(#4257): So far it always is continuous, but in the future we want to support strides!</p>
<p>The pointer is only valid as long as backing storage is alive which is either until the collection is destroyed the borrowed source is destroyed/moved. </p>

</div>
</div>
<a id="a55e1461c701fc6de1d1f287341c81a98" name="a55e1461c701fc6de1d1f287341c81a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e1461c701fc6de1d1f287341c81a98">&#9670;&#160;</a></span>get_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacererun.html#acdf7f503c6ab7a113a9d4d7f5191141f">CollectionOwnership</a> <a class="el" href="classrerun_1_1Collection.html">rerun::Collection</a>&lt; TElement &gt;::get_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data ownership of collection. </p>
<p>This is usually only needed for debugging and testing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>rerun/<a class="el" href="collection_8hpp_source.html">collection.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacererun.html">rerun</a></li><li class="navelem"><a class="el" href="classrerun_1_1Collection.html">Collection</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
