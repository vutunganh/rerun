searchState.loadedDescShard("re_int_histogram", 0, "A histogram with <code>i64</code> keys and <code>u32</code> counts, supporting both …\nA histogram, mapping <code>i64</code> key to a <code>u64</code> count optimizing for …\nAn iterator over an <code>Int64Histogram</code>.\nAn inclusive range.\nAn inclusive range.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ninclusive\ninclusive\ninclusive\ninclusive\nThe histogram is implemented as a trie.\nWe use <code>u64</code> keys in the internal structures, because it is …\nAn inner node, addressed by the next few bits of the …\nOptimization for dense histograms (entries at …\nA histogram, mapping <code>i64</code> key to a <code>u64</code> count optimizing for …\nAn iterator over an <code>Int64Histogram</code>.\nHow high up in the tree we are (where root is highest). …\nWhen a <code>SparseLeaf</code> goes over this, it becomes a <code>BranchNode</code>.\nA list of <code>(key, count)</code> pairs.\nTwo vectors of equal lengths, making up (addr, count) …\nThe index is the next few bits of the key\nThe count may never be zero.\nThe last bits of the address, mapped to their counts\nYou can stop recursing when you’ve reached this size\nDecrement the count for the given key.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nThe default node for a certain level.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncrement the count for the given key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalled on overflow\nIs the total count zero?\nHighest key with a non-zero count.\nLowest key with a non-zero count.\nIterate over a certain range, returning ranges that are at …\nOnly returns things in this range\nWhat is the count of all the buckets in the given range?\nRemove all data in the given range.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nReturns how much the total count decreased by.\nTotal count of all the buckets.\nVery important optimization\nThe level used for <code>DenseLeaf</code>.\nHow many bits we progress in each <code>BranchNode</code>\nNumber of children in <code>DenseLeaf</code>.\nThe level used for <code>DenseLeaf</code>.\nHow many bits we progress in each <code>BranchNode</code>\nNumber of children in <code>DenseLeaf</code>.")