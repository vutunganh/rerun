<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Build a set of expressions used as indices, to cache in temporary variables when emitted."><title>find_checked_indexes in rerun::external::eframe::egui_wgpu::wgpu::core::naga::proc::index - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../" data-static-root-path="../../../../../../../../../static.files/" data-current-crate="rerun" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0 (9fc6b4312 2025-01-07)" data-channel="1.84.0" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../../../../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../../../../../rerun/index.html">rerun</a><span class="version">0.23.0-alpha.3+dev</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In rerun::<wbr>external::<wbr>eframe::<wbr>egui_<wbr>wgpu::<wbr>wgpu::<wbr>core::<wbr>naga::<wbr>proc::<wbr>index</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../../../../../../index.html">rerun</a>::<wbr><a href="../../../../../../../index.html">external</a>::<wbr><a href="../../../../../../index.html">eframe</a>::<wbr><a href="../../../../../index.html">egui_wgpu</a>::<wbr><a href="../../../../index.html">wgpu</a>::<wbr><a href="../../../index.html">core</a>::<wbr><a href="../../index.html">naga</a>::<wbr><a href="../index.html">proc</a>::<wbr><a href="index.html">index</a></span><h1>Function <span class="fn">find_checked_indexes</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub fn find_checked_indexes(
    module: &amp;<a class="struct" href="../../struct.Module.html" title="struct rerun::external::eframe::egui_wgpu::wgpu::core::naga::Module">Module</a>,
    function: &amp;<a class="struct" href="../../struct.Function.html" title="struct rerun::external::eframe::egui_wgpu::wgpu::core::naga::Function">Function</a>,
    info: &amp;<a class="struct" href="../../valid/struct.FunctionInfo.html" title="struct rerun::external::eframe::egui_wgpu::wgpu::core::naga::valid::FunctionInfo">FunctionInfo</a>,
    policies: <a class="struct" href="../struct.BoundsCheckPolicies.html" title="struct rerun::external::eframe::egui_wgpu::wgpu::core::naga::proc::BoundsCheckPolicies">BoundsCheckPolicies</a>,
) -&gt; HandleSet&lt;<a class="enum" href="../../enum.Expression.html" title="enum rerun::external::eframe::egui_wgpu::wgpu::core::naga::Expression">Expression</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Build a set of expressions used as indices, to cache in temporary variables when
emitted.</p>
<p>Given the bounds-check policies <code>policies</code>, construct a <code>HandleSet</code> containing the handle
indices of all the expressions in <code>function</code> that are ever used as guarded indices
under the <a href="../enum.BoundsCheckPolicy.html#variant.ReadZeroSkipWrite" title="variant rerun::external::eframe::egui_wgpu::wgpu::core::naga::proc::BoundsCheckPolicy::ReadZeroSkipWrite"><code>ReadZeroSkipWrite</code></a> policy. The <code>module</code> argument must be the module to
which <code>function</code> belongs, and <code>info</code> should be that function’s analysis results.</p>
<p>Such index expressions will be used twice in the generated code: first for the
comparison to see if the index is in bounds, and then for the access itself, should
the comparison succeed. To avoid computing the expressions twice, the generated code
should cache them in temporary variables.</p>
<p>Why do we need to build such a set in advance, instead of just processing access
expressions as we encounter them? Whether an expression needs to be cached depends on
whether it appears as something like the <a href="../../enum.Expression.html#variant.Access.field.index" title="field rerun::external::eframe::egui_wgpu::wgpu::core::naga::Expression::index"><code>index</code></a> operand of an <a href="../../enum.Expression.html#variant.Access" title="variant rerun::external::eframe::egui_wgpu::wgpu::core::naga::Expression::Access"><code>Access</code></a> expression
or the <a href="../../enum.Expression.html#variant.ImageLoad.field.level" title="field rerun::external::eframe::egui_wgpu::wgpu::core::naga::Expression::level"><code>level</code></a> operand of an <a href="../../enum.Expression.html#variant.ImageLoad" title="variant rerun::external::eframe::egui_wgpu::wgpu::core::naga::Expression::ImageLoad"><code>ImageLoad</code></a> expression, and on the index bounds check
policies that apply to those accesses. But <a href="../../enum.Statement.html#variant.Emit" title="variant rerun::external::eframe::egui_wgpu::wgpu::core::naga::Statement::Emit"><code>Emit</code></a> statements just identify a range
of expressions by index; there’s no good way to tell what an expression is used
for. The only way to do it is to just iterate over all the expressions looking for
relevant <code>Access</code> expressions — which is what this function does.</p>
<p>Simple expressions like variable loads and constants don’t make sense to cache: it’s
no better than just re-evaluating them. But constants are not covered by <code>Emit</code>
statements, and <code>Load</code>s are always cached to ensure they occur at the right time, so
we don’t bother filtering them out from this set.</p>
<p>Fortunately, we don’t need to deal with <a href="../../enum.Statement.html#variant.ImageStore" title="variant rerun::external::eframe::egui_wgpu::wgpu::core::naga::Statement::ImageStore"><code>ImageStore</code></a> statements here. When we emit
code for a statement, the writer isn’t in the middle of an expression, so we can just
emit declarations for temporaries, initialized appropriately.</p>
<p>None of these concerns apply for SPIR-V output, since it’s easy to just reuse an
instruction ID in two places; that has the same semantics as a temporary variable, and
it’s inherent in the design of SPIR-V. This function is more useful for text-based
back ends.</p>
</div></details></section></div></main></body></html>