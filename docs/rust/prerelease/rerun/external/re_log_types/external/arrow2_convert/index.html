<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="arrow2_convert"><title>rerun::external::re_log_types::external::arrow2_convert - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="rerun" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../../../../../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../../../../../crates.js"></script><script defer src="../../../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../../rerun/index.html"><img class="rust-logo" src="../../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../../rerun/index.html"><img class="rust-logo" src="../../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate arrow2_convert</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.9.0-alpha.9</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../../../index.html">rerun</a>::<wbr><a href="../../../index.html">external</a>::<wbr><a href="../../index.html">re_log_types</a>::<wbr><a href="../index.html">external</a>::<wbr><a class="mod" href="#">arrow2_convert</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="arrow2_convert"><a href="#arrow2_convert">arrow2_convert</a></h2>
<p>Provides an API on top of <a href="https://github.com/jorgecarleitao/arrow2"><code>arrow2</code></a> to convert between rust types and Arrow.</p>
<p>The Arrow ecosystem provides many ways to convert between Arrow and other popular formats across several languages. This project aims to serve the need for rust-centric data pipelines to easily convert to/from Arrow with strong typing and arbitrary nesting.</p>
<h3 id="example"><a href="#example">Example</a></h3>
<p>The example below performs a round trip conversion of a struct with a single field. </p>
<p>Please see the <a href="./arrow2_convert/tests/complex_example.rs">complex_example.rs</a> for usage of the full functionality.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Simple example

</span><span class="kw">use </span>arrow2::array::Array;
<span class="kw">use </span>arrow2_convert::{deserialize::TryIntoCollection, serialize::TryIntoArrow, ArrowField, ArrowSerialize, ArrowDeserialize};

<span class="attr">#[derive(Debug, Clone, PartialEq, ArrowField, ArrowSerialize, ArrowDeserialize)]
</span><span class="kw">pub struct </span>Foo {
    name: String,
}

<span class="kw">fn </span>main() {
    <span class="comment">// an item
    </span><span class="kw">let </span>original_array = [
        Foo { name: <span class="string">&quot;hello&quot;</span>.to_string() },
        Foo { name: <span class="string">&quot;one more&quot;</span>.to_string() },
        Foo { name: <span class="string">&quot;good bye&quot;</span>.to_string() },
    ];

    <span class="comment">// serialize to an arrow array. try_into_arrow() is enabled by the TryIntoArrow trait
    </span><span class="kw">let </span>arrow_array: Box&lt;<span class="kw">dyn </span>Array&gt; = original_array.try_into_arrow().unwrap();

    <span class="comment">// which can be cast to an Arrow StructArray and be used for all kinds of IPC, FFI, etc.
    // supported by `arrow2`
    </span><span class="kw">let </span>struct_array= arrow_array.as_any().downcast_ref::&lt;arrow2::array::StructArray&gt;().unwrap();
    <span class="macro">assert_eq!</span>(struct_array.len(), <span class="number">3</span>);

    <span class="comment">// deserialize back to our original vector via TryIntoCollection trait.
    </span><span class="kw">let </span>round_trip_array: Vec&lt;Foo&gt; = arrow_array.try_into_collection().unwrap();
    <span class="macro">assert_eq!</span>(round_trip_array, original_array);
}</code></pre></div>
<h3 id="api"><a href="#api">API</a></h3>
<p>Types that implement the <code>ArrowField</code>, <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> traits can be converted to/from Arrow via the <code>try_into_arrow</code> and the <code>try_into_collection</code> methods. </p>
<p>The <code>ArrowField</code>, <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> derive macros can be used to generate implementations of these traits for structs and enums. Custom implementations can also be defined for any type that needs to convert to/from Arrow by manually implementing the traits.</p>
<p>For serializing to arrow, <code>TryIntoArrow::try_into_arrow</code> can be used to serialize any iterable into an <code>arrow2::Array</code> or a <code>arrow2::Chunk</code>.  <code>arrow2::Array</code> represents the in-memory Arrow layout. <code>arrow2::Chunk</code> represents a column group and can be used with <code>arrow2</code> API for other functionality such converting to parquet and arrow flight RPC.</p>
<p>For deserializing from arrow, the <code>TryIntoCollection::try_into_collection</code> can be used to deserialize from an <code>arrow2::Array</code> representation into any container that implements <code>FromIterator</code>.</p>
<h4 id="default-implementations"><a href="#default-implementations">Default implementations</a></h4>
<p>Default implementations of the above traits are provided for the following:</p>
<ul>
<li>Numeric types
<ul>
<li><a href="https://doc.rust-lang.org/1.72.1/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.u16.html" title="primitive u16"><code>u16</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.u32.html" title="primitive u32"><code>u32</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.u64.html" title="primitive u64"><code>u64</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.i8.html" title="primitive i8"><code>i8</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.i16.html" title="primitive i16"><code>i16</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.i32.html" title="primitive i32"><code>i32</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.i64.html" title="primitive i64"><code>i64</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.f32.html" title="primitive f32"><code>f32</code></a>, <a href="https://doc.rust-lang.org/1.72.1/std/primitive.f64.html" title="primitive f64"><code>f64</code></a></li>
<li><a href="https://doc.rust-lang.org/1.72.1/std/primitive.i128.html" title="primitive i128"><code>i128</code></a> is supported via the <code>type</code> attribute. Please see the <a href="#i128">i128 section</a> for more details.</li>
</ul>
</li>
<li>Other types: 
<ul>
<li><a href="https://doc.rust-lang.org/1.72.1/std/primitive.bool.html" title="primitive bool"><code>bool</code></a>, <a href="https://doc.rust-lang.org/1.72.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, [<code>Binary</code>]</li>
</ul>
</li>
<li>Temporal types: 
<ul>
<li><a href="https://docs.rs/chrono/latest/chrono/naive/date/struct.NaiveDate.html" title="struct chrono::naive::date::NaiveDate"><code>chrono::NaiveDate</code></a>, <a href="https://docs.rs/chrono/latest/chrono/naive/datetime/struct.NaiveDateTime.html" title="struct chrono::naive::datetime::NaiveDateTime"><code>chrono::NaiveDateTime</code></a></li>
</ul>
</li>
<li>Option<T> if T implements <code>ArrowField</code></li>
<li>Vec<T> if T implements <code>ArrowField</code></li>
<li>Large Arrow types [<code>LargeBinary</code>], [<code>LargeString</code>], [<code>LargeList</code>] are supported via the <code>type</code> attribute. Please see the <a href="./arrow2_convert/tests/complex_example.rs">complex_example.rs</a> for usage.</li>
<li>Fixed size types [<code>FixedSizeBinary</code>], [<code>FixedSizeList</code>] are supported via the <code>FixedSizeVec</code> type override.
<ul>
<li>Note: nesting of [<code>FixedSizeList</code>] is not supported.</li>
</ul>
</li>
</ul>
<h4 id="enums"><a href="#enums">Enums</a></h4>
<p>Enums are still an experimental feature and need to be integrated tested. Rust enum arrays are converted to a <code>Arrow::UnionArray</code>. Some additional notes on enums:</p>
<ul>
<li>Rust unit variants are represented using as the <code>bool</code> data type.</li>
</ul>
<h4 id="i128"><a href="#i128">i128</a></h4>
<p>i128 represents a decimal number and requires the precision and scale to be specified to be used as an Arrow data type. The precision and scale can be specified by using a type override via the <code>I128</code> type. </p>
<p>For example to use <code>i128</code> as a field in a struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>arrow2_convert::field::I128;
<span class="kw">use </span>arrow2_convert::ArrowField;

<span class="attr">#[derive(Debug, ArrowField)]
</span><span class="kw">struct </span>S {
    <span class="attr">#[arrow_field(<span class="kw">type </span>= <span class="string">&quot;I128&lt;32, 32&gt;&quot;</span>)]
    </span>field: i128,
}</code></pre></div>
<p>A <code>vec&lt;i128&gt;</code> can be converted. to/from arrow by using the <code>arrow_serialize_to_mutable_array</code> and <code>arrow_array_deserialize_iterator_as_type</code> methods. </p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>arrow2::array::{Array, MutableArray};
<span class="kw">use </span>arrow2_convert::serialize::arrow_serialize_to_mutable_array;
<span class="kw">use </span>arrow2_convert::deserialize::arrow_array_deserialize_iterator_as_type;
<span class="kw">use </span>arrow2_convert::field::I128;
<span class="kw">use </span>std::borrow::Borrow;

<span class="kw">fn </span>convert_i128() {
    <span class="kw">let </span>original_array = <span class="macro">vec!</span>[<span class="number">1 </span><span class="kw">as </span>i128, <span class="number">2</span>, <span class="number">3</span>];
    <span class="kw">let </span>b: Box&lt;<span class="kw">dyn </span>Array&gt; = arrow_serialize_to_mutable_array::&lt;<span class="kw">_</span>, I128&lt;<span class="number">32</span>,<span class="number">32</span>&gt;, <span class="kw">_</span>&gt;(
        <span class="kw-2">&amp;</span>original_array).unwrap().as_box();
    <span class="kw">let </span>round_trip: Vec&lt;i128&gt; = arrow_array_deserialize_iterator_as_type::&lt;<span class="kw">_</span>, I128&lt;<span class="number">32</span>,<span class="number">32</span>&gt;&gt;(
        b.borrow()).unwrap().collect();
    <span class="macro">assert_eq!</span>(original_array, round_trip);
}
</code></pre></div>
<h4 id="nested-option-types"><a href="#nested-option-types">Nested Option Types</a></h4>
<p>Since the Arrow format only supports one level of validity, nested option types such as <code>Option&lt;Option&lt;T&gt;&gt;</code>, after serialization to Arrow, will lose any intermediate nesting of None values. For example, <code>Some(None)</code> will be serialized to <code>None</code>, </p>
<h4 id="missing-features"><a href="#missing-features">Missing Features</a></h4>
<ul>
<li>Support for generics, slices and reference is currently missing.</li>
</ul>
<p>This is not an exhaustive list. Please open an issue if you need a feature.</p>
<h3 id="memory"><a href="#memory">Memory</a></h3>
<p>Pass-thru conversions perform a single memory copy. Deserialization performs a copy from arrow2 to the destination. Serialization performs a copy from the source to arrow2. In-place deserialization is theoretically possible but currently not supported.</p>
<h3 id="internals"><a href="#internals">Internals</a></h3><h4 id="similarities-with-serde"><a href="#similarities-with-serde">Similarities with Serde</a></h4>
<p>The design is inspired by serde. The <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> are analogs of serde’s <code>Serialize</code> and <code>Deserialize</code> respectively.</p>
<p>However unlike serde’s traits provide an exhaustive and flexible mapping to the serde data model, arrow2_convert’s traits provide a much more narrower mapping to arrow2’s data structures.</p>
<p>Specifically, the <code>ArrowSerialize</code> trait provides the logic to serialize a type to the corresponding <code>arrow2::array::MutableArray</code>. The <code>ArrowDeserialize</code> trait deserializes a type from the corresponding <code>arrow2::array::ArrowArray</code>. </p>
<h4 id="workarounds"><a href="#workarounds">Workarounds</a></h4>
<p>Features such as partial implementation specialization and generic associated types (currently only available in nightly builds) can greatly simplify the underlying implementation.</p>
<p>For example custom types need to explicitly enable Vec<T> serialization via the <code>arrow_enable_vec_for_type</code> macro on the primitive type. This is needed since Vec<u8> is a special type in Arrow, but without implementation specialization there’s no way to special-case it.</p>
<p>Availability of generaic associated types would simplify the implementation for large and fixed types, since a generic MutableArray can be defined. Ideally for code reusability, we wouldn’t have to reimplement <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> for large and fixed size types since the primitive types are the same. However, this requires the trait functions to take a generic bounded mutable array as an argument instead of a single array type. This requires the <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> implementations to be able to specify the bounds as part of the associated type, which is not possible without generic associated types.</p>
<p>As a result, we’re forced to sacrifice code reusability and introduce a little bit of complexity by providing separate <code>ArrowSerialize</code> and <code>ArrowDeserialize</code> implementations for large and fixed size types via placeholder structures. This also requires introducing the <code>Type</code> associated type to <code>ArrowField</code> so that the arrow type can be overriden via a macro field attribute without affecting the actual type.</p>
<h3 id="license"><a href="#license">License</a></h3>
<p>Licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or http://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or http://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option.</p>
<h4 id="contribution"><a href="#contribution">Contribution</a></h4>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="deserialize/index.html" title="mod rerun::external::re_log_types::external::arrow2_convert::deserialize">deserialize</a></div><div class="desc docblock-short">Implementation and traits for deserializing from Arrow.</div></li><li><div class="item-name"><a class="mod" href="field/index.html" title="mod rerun::external::re_log_types::external::arrow2_convert::field">field</a></div><div class="desc docblock-short">Implementation and traits for mapping rust types to Arrow types</div></li><li><div class="item-name"><a class="mod" href="serialize/index.html" title="mod rerun::external::re_log_types::external::arrow2_convert::serialize">serialize</a></div><div class="desc docblock-short">Implementation and traits for serializing to Arrow.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.arrow_enable_vec_for_type.html" title="macro rerun::external::re_log_types::external::arrow2_convert::arrow_enable_vec_for_type">arrow_enable_vec_for_type</a></div><div class="desc docblock-short">Enables the blanket implementations of <a href="https://doc.rust-lang.org/1.72.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;T&gt;</code></a> as an Arrow field
if <code>T</code> is an Arrow field.</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.ArrowDeserialize.html" title="derive rerun::external::re_log_types::external::arrow2_convert::ArrowDeserialize">ArrowDeserialize</a></div><div class="desc docblock-short">Derive macro for arrow deserialize</div></li><li><div class="item-name"><a class="derive" href="derive.ArrowField.html" title="derive rerun::external::re_log_types::external::arrow2_convert::ArrowField">ArrowField</a></div><div class="desc docblock-short">Derive macro for arrow fields</div></li><li><div class="item-name"><a class="derive" href="derive.ArrowSerialize.html" title="derive rerun::external::re_log_types::external::arrow2_convert::ArrowSerialize">ArrowSerialize</a></div><div class="desc docblock-short">Derive macro for arrow serialize</div></li></ul></section></div></main></body></html>