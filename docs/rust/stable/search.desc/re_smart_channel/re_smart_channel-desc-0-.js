searchState.loadedDescShard("re_smart_channel", 0, "A channel that keeps track of latency and queue length.\nThe message could not be received because the channel is …\nThe message could not be received because the channel is …\nA message could not be received because the channel is …\nThe channel was created in the context of loading a file …\nThe sender is a background thread reading data from a file …\nWhen received, flush anything already received and then …\nThe channel was created in the context of a javascript …\nThe sender is a javascript client submitting an RRD …\nA stream of messages over message proxy gRPC interface.\nA stream of messages over message proxy gRPC interface.\nA message sent down the channel.\nThe <code>Sender</code> has quit.\nA set of connected <code>Receiver</code>s.\nAn error returned from the <code>recv</code> method.\nAn error returned from the <code>recv_timeout</code> method.\nThe data is streaming in directly from a Rerun Data …\nA file on a Rerun Data Platform server, over <code>rerun://</code> gRPC …\nThe channel was created in the context of loading an <code>.rrd</code> …\nThe sender is a background thread fetching data from an …\nThe sender is a javascript callback triggered by a …\nThe channel was created in the context of loading an <code>.rrd</code> …\nThe channel was created in the context of loading data …\nThe sender is a Rerun SDK running from another thread in …\nAn error returned from the <code>send</code> method.\nStats for a channel, possibly shared between chained …\nIdentifies in what context this smart channel was created, …\nThe payload of a <code>SmartMessage</code>.\nIdentifies who/what sent a particular message in a smart …\nThe channel was created in the context of streaming in RRD …\nThe data is streaming in from standard input.\nThe sender is a TCP client.\nThe channel was created in the context of receiving data …\nA message could not be received because the channel is …\nAn error returned from the <code>try_recv</code> method.\nThe source is unknown.\nThe channel was created in the context of fetching data …\nThe sender is a WebSocket client fetching data from a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps the message.\nReturns <code>true</code> if the receive operation failed because the …\nReturns <code>true</code> if the receive operation failed because the …\nReturns <code>true</code> if the receive operation failed because the …\nReturns <code>true</code> if the receive operation timed out.\nLatest known latency from sending a message to receiving …\nCreate a new channel using the same stats as some other.\nThe name of the channel reported by the javascript client.\nShould include <code>rerun://</code> prefix.\nShould include <code>temp://</code> prefix.\nThe server we are connected to (or are trying to connect …\nShould include <code>http(s)://</code> prefix.\nShould include <code>rerun://</code> prefix.\nShould include <code>temp://</code> prefix.\nThe server we are connected to (or are trying to connect …\nA set of connected <code>Receiver</code>s.\nDoes this viewer accept inbound TCP connections?\nRemove all receivers.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAny connected receivers?\nNo connected receivers?\nMaximum latency among all receivers (or 0, if none).\nSum queue length of all receivers.\nBlocks until a message is ready to be received, or we are …\nDisconnect from any channel with the given source.\nList of connected receiver sources.\nReturns immediately if there is nothing to receive.\nCreate a new channel that use the same stats as this one.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAre we still connected?\nIs the channel currently empty of messages?\nLatest known latency from sending a message to receiving …\nLatest known latency from sending a message to receiving …\nNumber of messages in the channel right now.\nReceives without registering the latency.\nWhere is the data coming from?\nClones the sender with an updated source.\nBlocks until all previously sent messages have been …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIs the channel currently empty of messages?\nLatest known latency from sending a message to receiving …\nLatest known latency from sending a message to receiving …\nNumber of messages in the channel right now.\nUsed to indicate that a sender has left.\nForwards a message as-is.")