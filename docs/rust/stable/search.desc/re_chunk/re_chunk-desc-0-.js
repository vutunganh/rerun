searchState.loadedDescShard("re_chunk", 0, "A chunk of Rerun data, encoded using Arrow. Used for …\nDense arrow-based storage of N rows of multi-component …\nImplements an asynchronous batcher that coalesces …\nDefines the different thresholds of the associated …\nErrors that can occur when creating/manipulating a …\nHelper to incrementally build a <code>Chunk</code>.\nThe actual iterator implementation for …\nThe underlying item type for <code>ChunkComponentIter</code>.\nA <code>ChunkComponentSlicer</code> knows how to efficiently slice …\nErrors that can occur when creating/manipulating a <code>Chunk</code>s, …\nA simple type alias for an <code>Arc&lt;Chunk&gt;</code>.\nContains the error value\nContains the error value\nA query at a given time, for a given timeline.\nContains the success value\nContains the success value\nError when parsing configuration from environment.\nA single row’s worth of data (i.e. a single log call).\nA query over a time range, for a given timeline.\nError spawning one of the background threads.\nHelper to incrementally build a <code>TimeColumn</code>.\nErrors when deserializing/parsing/reading a column of time …\nA <code>Chunk</code> that is ready for transport. Obtained by calling …\nA <code>ChunkShared</code> that is guaranteed to always contain a …\nSplit a chunk if it contains &gt;= rows than this threshold …\nA sparse <code>ListArray</code> for each component.\nThe component data.\nFlush if the accumulated payload has a size in bytes equal …\nFlush if the accumulated payload has a number of rows …\nDuration of the periodic tick.\nThe heap size of this chunk in bytes.\nCallbacks you can install on the <code>ChunkBatcher</code>.\nIf true, the results will include one extra tick on each …\nIs the chunk as a whole sorted by <code>RowId</code>?\nIs <code>Self::times</code> sorted?\nShould the results contain all extra component information …\nShould the results contain all extra timeline information …\nSize of the internal channel of <code>Chunk</code>s.\nSize of the internal channel of commands.\nAuto-generated <code>TUID</code>, uniquely identifying this event and …\nThe respective <code>RowId</code>s for each row of data.\nThe time range covered by <code>Self::times</code>.\nThe time columns.\nUser-specified <code>TimePoint</code> for this event.\nEvery single timestamp for this timeline.\nAlways flushes ASAP.\nCallbacks you can install on the <code>ChunkBatcher</code>.\nImplements an asynchronous batcher that coalesces …\nDefines the different thresholds of the associated …\nErrors that can occur when creating/manipulating a …\nDefault configuration, applicable to most use cases.\nEnvironment variable to configure …\nEnvironment variable to configure <code>Self::flush_num_bytes</code>.\nEnvironment variable to configure <code>Self::flush_num_rows</code>.\nEnvironment variable to configure <code>Self::flush_tick</code>.\nEnvironment variable to configure …\nContains the error value\nNever flushes unless manually told to (or hitting one the …\nContains the success value\nError when parsing configuration from environment.\nA single row’s worth of data (i.e. a single log call).\nHelper class used to buffer time data.\nError spawning one of the background threads.\nReturns a copy of <code>self</code>, overriding existing fields with …\nSplit a chunk if it contains &gt;= rows than this threshold …\nReturns a <em>shared</em> channel in which are sent the batched …\nThe component data.\nInitiates a flush of the pipeline and returns immediately.\nInitiates a flush the batching pipeline and waits for it …\nFlush if the accumulated payload has a size in bytes equal …\nFlush if the accumulated payload has a number of rows …\nDuration of the periodic tick.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>ChunkBatcherConfig</code> using the default values, …\nCallbacks you can install on the <code>ChunkBatcher</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn a single row into a <code>Chunk</code> of its own.\nThis turns a batch of <code>PendingRow</code>s into a <code>Chunk</code>.\nSize of the internal channel of <code>Chunk</code>s.\nSize of the internal channel of commands.\nCreates a new <code>ChunkBatcher</code> using the passed in <code>config</code>.\nCalled when a new row arrives.\nCallback to be run when an Arrow Chunk goes out of scope.\nPush a single time value at the end of this chunk.\nPushes a <code>PendingRow</code> down the batching pipeline.\nAuto-generated <code>TUID</code>, uniquely identifying this event and …\nUser-specified <code>TimePoint</code> for this event.\nThe one and only entrypoint into the pipeline: this is …\nHelper to incrementally build a <code>Chunk</code>.\nHelper to incrementally build a <code>TimeColumn</code>.\nBuilds and returns the final <code>Chunk</code>.\nBuilds and returns the final <code>TimeColumn</code>.\nBuilds and returns the final <code>Chunk</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitializes a new <code>ChunkBuilder</code>.\nInitializes a new <code>TimeColumnBuilder</code>.\nAdd a row’s worth of data by destructuring an archetype …\nAdd a row’s worth of data by serializing a single …\nAdd a row’s worth of data by serializing many …\nAdd a row’s worth of data using the given component data.\nAdd a row’s worth of time data using the given timestamp.\nAdd a row’s worth of data by serializing a single …\nAdd a row’s worth of data by serializing many …\nAdd a row’s worth of data by serializing many sparse …\nAdd a row’s worth of data using the given sparse …\nAdd a row’s worth of data by serializing many sparse …\nDense arrow-based storage of N rows of multi-component …\nErrors that can occur when creating/manipulating a <code>Chunk</code>s, …\nContains the error value\nContains the success value\nErrors when deserializing/parsing/reading a column of time …\nUnconditionally inserts an <code>ArrowListArray</code> as a component …\nUnconditionally inserts a <code>TimeColumn</code>.\nReturns <code>true</code> is two <code>Chunk</code>s are similar, although not …\nInitializes a new <code>ChunkBuilder</code>.\nInitializes a new <code>TimeColumnBuilder</code>.\nInitializes a new <code>ChunkBuilder</code>.\nReturns the cell corresponding to the specified <code>RowId</code> for …\nClones the chunk and assign new IDs to the resulting chunk …\nReturns the deserialized data for the specified component.\nReturns the raw data for the specified component.\nReturns the component data of the specified instance.\nReturns the raw data for the specified component at the …\nReturns the deserialized data for the specified component, …\nReturns the raw data for the specified component, assuming …\nReturns an iterator over the <code>RowId</code>s of a <code>Chunk</code>, for a …\nSlices the <code>Chunk</code> horizontally by keeping only the selected …\nA sparse <code>ListArray</code> for each component.\nRemoves all component columns from the <code>Chunk</code>.\nSlices the <code>Chunk</code> horizontally by keeping only the selected …\nReturns true if two chunks are concatenable.\nConcatenates two <code>Chunk</code>s into a new one.\nConcatenates two <code>TimeColumn</code>s into a new one.\nRemoves duplicate rows from sections of consecutive …\nDensifies the <code>Chunk</code> vertically based on the <code>component_name</code> …\nEmpties the <code>Chunk</code> vertically.\nEmpties the <code>TimeColumn</code> vertically.\nApplies a filter kernel to the <code>Chunk</code> as a whole.\nRuns a filter compute kernel on the time data with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>Chunk</code>.\nCreates a new <code>Chunk</code>.\nReturns all list arrays for the given component name.\nReturns any list-array that matches the given <code>ComponentName</code>…\nThe heap size of this chunk in bytes.\nLike <code>Self::insert</code>, but automatically infers the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nClones the chunk into a new chunk without any time data.\nTurns the chunk into a <code>UnitChunkShared</code>, if possible.\nIs the chunk currently ascendingly sorted by <code>crate::RowId</code>?\nIs the timeline sorted?\nIs the chunk as a whole sorted by <code>RowId</code>?\nIs <code>Self::times</code> sorted?\nLike <code>Self::is_sorted</code>, but actually checks the entire …\nIs the chunk ascendingly sorted by time, for all of its …\nIs the chunk ascendingly sorted by time, for a specific …\nReturns an iterator over the deserialized batches of a …\nReturns an iterator over the indices (<code>(TimeInt, RowId)</code>) of …\nReturns an iterator over the offsets (<code>(offset, len)</code>) of a …\nReturns an iterator over the <code>TimePoint</code>s of a <code>Chunk</code>, for a …\nReturns an iterator over the indices (<code>(TimeInt, RowId)</code>) of …\nReturns an iterator over the indices (<code>(TimeInt, RowId)</code>) of …\nReturns an iterator over the all the sliced component …\nReturns an iterator over the all the sliced component …\nReturns an iterator over the <code>TimePoint</code>s of a <code>Chunk</code>.\nRuns a <code>LatestAtQuery</code> filter on a <code>Chunk</code>.\nCreates a new <code>Chunk</code>.\nCreates a new <code>TimeColumn</code>.\nCreates a new <code>TimeColumn</code> of nanoseconds type.\nCreates a new <code>TimeColumn</code> of sequence type.\nCreates a new <code>TimeColumn</code> of sequence type.\nSimple helper for <code>Self::new</code> for static data.\nHow many columns in total? Includes control, time, and …\nThe cumulative number of events in this chunk.\nThe cumulative number of events in this chunk for each …\nThe number of events in this chunk for the specified …\nReturns <code>true</code> if <code>self</code> and <code>rhs</code> overlap on their <code>RowId</code> range.\nReturns <code>true</code> if <code>self</code> and <code>rhs</code> overlap on any of their time …\nA temporary migration kernel for blueprint data.\nRuns a <code>RangeQuery</code> filter on a <code>Chunk</code>.\nParse the given <code>ArrowArray</code> as a time column.\nParse the given <code>ArrowArray</code> as a time column where null …\nReturns the <code>RowId</code>-range covered by this <code>Chunk</code>.\nComputes the <code>RowId</code> range covered by each individual …\nAll the <code>RowId</code> in this chunk.\nThe respective <code>RowId</code>s for each row of data.\nReturns the <code>RowId</code>s in their raw-est form: a tuple of …\nSlices the <code>Chunk</code> vertically.\nSlices the <code>TimeColumn</code> vertically.\nReturns <code>true</code> if both chunks share the same datatypes for …\nReturns <code>true</code> if both chunks share the same descriptors for …\nReturns <code>true</code> if both chunks share the same entity path.\nReturns <code>true</code> if both chunks contains the same set of …\nReturns an error if the Chunk’s invariants are not …\nReturns an error if the Chunk’s invariants are not …\nRandomly shuffles the chunk using the given <code>seed</code>.\nShuffle the chunk according to the specified <code>swaps</code>.\nSort the chunk, if needed.\nReturns a new <code>Chunk</code> that is sorted by <code>(&lt;timeline&gt;, RowId)</code>.\nMoves all indicator components from <code>self</code> into a new, …\nApplies a take kernel to the <code>Chunk</code> as a whole.\nRuns a take compute kernel on the time data with the …\nThe time range covered by <code>Self::times</code>.\nComputes the time range covered by each individual …\nComputes the time range covered by each individual …\nSlices the <code>Chunk</code> horizontally by keeping only the selected …\nThe time columns.\nSlices the <code>Chunk</code> horizontally by keeping only the selected …\nComputes the maximum value for each and every timeline …\nEvery single timestamp for this timeline.\nReturns an array with the appropriate datatype.\nPrepare the <code>Chunk</code> for transport.\nPrepare the <code>Chunk</code> for transport.\nTurns the chunk into a <code>UnitChunkShared</code>, if possible.\nReturns a version of us with a new <code>ChunkId</code>.\nClones the chunk into a new chunk where all <code>RowId</code>s are …\nA simple type alias for an <code>Arc&lt;Chunk&gt;</code>.\nA <code>ChunkShared</code> that is guaranteed to always contain a …\nReturns the deserialized data for the specified component.\nReturns the raw data for the specified component.\nReturns the deserialized data for the specified component …\nReturns the raw data for the specified component at the …\nReturns the deserialized data for the specified component, …\nReturns the raw data for the specified component, assuming …\nReturns the argument unchanged.\nReturns the index (<code>(TimeInt, RowId)</code> pair) of the single …\nCalls <code>U::from(self)</code>.\nReturns the number of instances of the single row within …\nReturns the <code>RowId</code> of the single row within, on the given …\nThe actual iterator implementation for …\nThe underlying item type for <code>ChunkComponentIter</code>.\nA <code>ChunkComponentSlicer</code> knows how to efficiently slice …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe actual implementation of <code>impl_array_list_native_type!</code>, …\nThe actual implementation of <code>impl_array_native_type!</code>, so …\nThe actual implementation of <code>impl_buffer_native_type!</code>, so …\nThe actual implementation of <code>impl_native_type!</code>, so that we …\nA query at a given time, for a given timeline.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe returned query is guaranteed to never include …\nA query over a time range, for a given timeline.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSee <code>RangeQueryOptions::include_extended_bounds</code> for more …\nIf true, the results will include one extra tick on each …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSee <code>RangeQueryOptions::keep_extra_components</code> for more …\nShould the results contain all extra component information …\nSee <code>RangeQueryOptions::keep_extra_timelines</code> for more …\nShould the results contain all extra timeline information …\nThe returned query is guaranteed to never include …\nThe returned query is guaranteed to never include …\nThe key used to identify a Rerun <code>EntityPath</code> in chunk-level …\nThe key used to identify the size in bytes of the data, …\nThe key used to identify a Rerun <code>ChunkId</code> in chunk-level …\nThe marker used to identify whether a chunk is sorted in …\nThe key used to identify the <code>crate::ArchetypeFieldName</code> in …\nThe key used to identify the <code>crate::ArchetypeName</code> in …\nThe key used to identify the kind of a Rerun column in …\nThe marker used to identify whether a column is sorted in …\nThe value used to identify a Rerun control column in …\nThe value used to identify a Rerun data column in …\nThe value used to identify a Rerun time column in …\nA <code>Chunk</code> that is ready for transport. Obtained by calling …\nReturns the appropriate chunk-level <code>ArrowSchema</code> metadata …\nReturns the appropriate chunk-level <code>ArrowSchema</code> metadata …\nReturns the appropriate chunk-level <code>ArrowSchema</code> metadata …\nReturns the appropriate chunk-level <code>ArrowSchema</code> metadata …\nIterates all columns of the specified <code>kind</code>.\nIterates all data columns present in this chunk.\nIterates all control columns present in this chunk.\nReturns the appropriate field-level <code>ArrowSchema</code> metadata …\nReturns the appropriate field-level <code>ArrowSchema</code> metadata …\nReturns the appropriate field-level <code>ArrowSchema</code> metadata …\nReturns the appropriate field-level <code>ArrowSchema</code> metadata …\nReturns the argument unchanged.\nThe size in bytes of the data, once loaded in memory, in …\nCalls <code>U::from(self)</code>.\nLooks in the chunk metadata for the <code>IS_SORTED</code> marker.\nIterates all timeline columns present in this chunk.")