searchState.loadedDescShard("re_protos", 0, "This crate contains generated types for the remote store …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerated types for the remote store gRPC service API v0.\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nsupported encoder versions for encoding data See <code>RerunData</code> …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nunique recording identifier. At this point in time it is …\nRerunChunk is arrow IPC encoded RecordBatch that has …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nA date-time represented as nanoseconds since unix epoch\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\nThe specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nencoder version used to encode the data\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nInitialized to something random on each thread, then …\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\ncomponent name needs to be a string as user can define …\nData payload is Arrow IPC encoded RecordBatch\nSpecifies how null values should be filled in the returned …\nApproximate nanoseconds since epoch.\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nThe payload is encoded as Arrow-IPC.\nCorresponds to <code>LogMsg::ArrowMsg</code>. Used to transmit actual …\nCorresponds to <code>LogMsg::BlueprintActivationCommand</code>.\nThe recording came from the C++ SDK.\nThe file came from the command line.\nThe type of compression used on the payload.\nInformation about the Rust SDK that created the recording.\nThe file was dragged into the viewer.\nThe encoding of the message payload.\nThe recording came from a file.\nThe file was opened using a file dialog.\nA recording which came from a file.\nDetermines where the file came from.\nTODO(#8631): Remove <code>LogMsg</code>\nLZ4 block compression.\nNo compression.\nThe recording came from some other source.\nThe recording came from the Python SDK.\nVersion of the Python SDK that created the recording.\nThe recording came from the Rust SDK.\nThe recording was produced using a data loader, such as …\nCorresponds to <code>LogMsg::SetStoreInfo</code>. Used to identify a …\nInformation about a recording or blueprint.\nThe source of a recording or blueprint.\nA newtype for <code>StoreSource</code> payload.\nWhat kind of source a recording comes from.\nWe don’t know what encoding the payload is in.\nWe don’t know anything about the source of this …\nWe don’t know where the file came from.\nThe file was served over HTTP.\nThe recording came from some action in the viewer.\nUser-chosen name of the application doing the logging.\nThe ID of the blueprint to activate.\nCompression algorithm used.\nCrate version encoded using our custom scheme.\nEncoding of the payload.\nStore source payload. See <code>StoreSourceKind</code> for what exactly …\nThe new store info.\nTrue if the recording is one of the official Rerun …\nDetermines what is encoded in <code>extra</code>.\nVersion of LLVM used by the Rust compiler.\nNested message and enum types in <code>LogMsg</code>.\nWhether to make the blueprint active immediately.\nWhether to make the blueprint the default.\nArrow-IPC encoded schema and chunk, compressed according …\nA time-based UID that is used to determine how a <code>StoreInfo</code> …\nVersion of the Rust compiler used to compile the SDK.\nWhen the recording started.\nThe ID of the store that this message is for.\nUnique ID of the recording.\nWhere the recording came from.\nVersion of the store crate.\nA message that contains an Arrow-IPC encoded message.\nA message that contains a blueprint activation command.\nA message that contains a new store info.\nTODO(zehiko) add properties as needed\nTODO(zehiko) add properties as needed\nRecording catalog mandatory field names. All mandatory …\nEncoding / decoding error\nDataframePart is arrow IPC encoded RecordBatch\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nused to define which column we want to index\nTODO(zehiko) add properties as needed\nmetadata database access error\nobject store access error\nApplication level error - used as <code>details</code> in the …\nunused\nOptional name of the field within <code>Archetype</code> associated …\nOptional name of the <code>Archetype</code> associated with this data.\nTODO(zehiko) add other properties as needed\nerror code\nComponent / column we want to index\nIndex column that is queried\nColumn projection - define which columns should be …\nSemantic name associated with this data.\nhuman readable description of the recording\nencoder version used to encode the data\nTODO(zehiko) we need to expand this to become something …\nThe path of the entity.\nwhich catalog entry do we want to create index for\nThe catalog entry that we want to search over If not …\nFilter specific recordings that match the criteria …\nunique identifier associated with the request (e.g. …\nNested message and enum types in <code>IndexProperties</code>.\nNested message and enum types in <code>IndexQueryProperties</code>.\nmax number of rows to be returned\nhuman readable details about the error\n(optional) any additional metadata that should be …\nData payload is Arrow IPC encoded RecordBatch\nraw bytes are TransportChunks (i.e. RecordBatches) encoded …\npayload is raw bytes that the relevant codec can interpret\nwhat kind of index do we want to create and what are its …\nIndex type specific properties\nspecific index query properties based on the index type\nQuery data - type of data is index specific. Caller must …\nquery to execute\nunique identifier of the recording\nunique identifier of the recording\nFiltering is very simple right now, we can only select …\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\nWhat is the filter index i.e. timeline for which we will …\ntype of recording\nspecific index query properties based on the index type\nServer streaming response type for the FetchRecording …\nServer streaming response type for the QueryCatalog method.\nServer streaming response type for the Query method.\nGenerated gRPC service name\nServer streaming response type for the SearchIndex method.\nGenerated trait containing gRPC methods that should be …\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nThe response to <code>SearchIndex</code> a RecordBatch with 3 columns:\nGenerated client implementations.\nGenerated server implementations.\nSimple buffer for messages between SDKs and viewers.\nGenerated trait containing gRPC methods that should be …\nSimple buffer for messages between SDKs and viewers.\nServer streaming response type for the ReadMessages method.\nGenerated gRPC service name\nTODO(jan): Would it be more efficient to send a “message …\nComponent describes semantic data that can be used by any …\nUsed to select a component based on its EntityPath and …\nsupported encoder versions for encoding data See <code>RerunData</code> …\nThe unique identifier of an entity, e.g. <code>camera/3/points</code> …\nunique recording identifier. At this point in time it is …\nRerunChunk is arrow IPC encoded RecordBatch that has …\narrow IPC serialized schema\nSpecifies how null values should be filled in the returned …\nA date-time represented as nanoseconds since unix epoch\nUsed to telect a time column.\nA 64-bit number describing either nanoseconds, sequence …\nA time range between start and end time points. Each 64 …\nA recording can have multiple timelines, each is …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nThe specific <em>columns</em> to sample from the final view …\nNested message and enum types in <code>ColumnSelector</code>.\nReturns the enum value of <code>encoder_version</code>, or the default …\nencoder version used to encode the data\nThe index used to filter out <em>rows</em> from the view contents. …\nThe range of index values used to filter out <em>rows</em> from the …\nThe specific index values used to filter out <em>rows</em> from the …\nThe component column used to filter out <em>rows</em> from the view …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>EncoderVersion</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>SparseFillStrategy</code>, or <code>None</code> if <code>value</code> …\nConverts an <code>i32</code> to a <code>StoreKind</code>, or <code>None</code> if <code>value</code> is not a …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nInitialized to something random on each thread, then …\nWhether the view_contents should ignore columns …\nWhether the view_contents should ignore semantically empty …\nWhether the view_contents should ignore columns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>EncoderVersion</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>SparseFillStrategy</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>StoreKind</code>.\nReturns the enum value of <code>kind</code>, or the default if the …\ncomponent name needs to be a string as user can define …\nData payload is Arrow IPC encoded RecordBatch\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nSets <code>sparse_fill_strategy</code> to the provided enum value.\nReturns the enum value of <code>sparse_fill_strategy</code>, or the …\nSpecifies how null values should be filled in the returned …\nApproximate nanoseconds since epoch.\nTODO(zehiko) we need to add support for other types of …\nTODO(zehiko) support for other ranges for other index …\nTODO(zehiko) we need to add support for other types of …\nThe specific index values used to sample <em>rows</em> from the …\nThe subset of the database that the query will run on: a …\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nThe payload is encoded as Arrow-IPC.\nCorresponds to <code>LogMsg::ArrowMsg</code>. Used to transmit actual …\nCorresponds to <code>LogMsg::BlueprintActivationCommand</code>.\nThe recording came from the C++ SDK.\nThe file came from the command line.\nThe type of compression used on the payload.\nInformation about the Rust SDK that created the recording.\nThe file was dragged into the viewer.\nThe encoding of the message payload.\nThe recording came from a file.\nThe file was opened using a file dialog.\nA recording which came from a file.\nDetermines where the file came from.\nTODO(#8631): Remove <code>LogMsg</code>\nLZ4 block compression.\nNo compression.\nThe recording came from some other source.\nThe recording came from the Python SDK.\nVersion of the Python SDK that created the recording.\nThe recording came from the Rust SDK.\nThe recording was produced using a data loader, such as …\nCorresponds to <code>LogMsg::SetStoreInfo</code>. Used to identify a …\nInformation about a recording or blueprint.\nThe source of a recording or blueprint.\nA newtype for <code>StoreSource</code> payload.\nWhat kind of source a recording comes from.\nWe don’t know what encoding the payload is in.\nWe don’t know anything about the source of this …\nWe don’t know where the file came from.\nThe file was served over HTTP.\nThe recording came from some action in the viewer.\nUser-chosen name of the application doing the logging.\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nThe ID of the blueprint to activate.\nReturns the enum value of <code>compression</code>, or the default if …\nCompression algorithm used.\nCrate version encoded using our custom scheme.\nReturns the enum value of <code>encoding</code>, or the default if the …\nEncoding of the payload.\nStore source payload. See <code>StoreSourceKind</code> for what exactly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>Compression</code>, or <code>None</code> if <code>value</code> is not …\nConverts an <code>i32</code> to a <code>Encoding</code>, or <code>None</code> if <code>value</code> is not a …\nConverts an <code>i32</code> to a <code>StoreSourceKind</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>FileSourceKind</code>, or <code>None</code> if <code>value</code> is …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nThe new store info.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if the recording is one of the official Rerun …\nReturns <code>true</code> if <code>value</code> is a variant of <code>Compression</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>Encoding</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>StoreSourceKind</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>FileSourceKind</code>.\nReturns the enum value of <code>kind</code>, or the default if the …\nReturns the enum value of <code>kind</code>, or the default if the …\nDetermines what is encoded in <code>extra</code>.\nVersion of LLVM used by the Rust compiler.\nNested message and enum types in <code>LogMsg</code>.\nWhether to make the blueprint active immediately.\nWhether to make the blueprint the default.\nArrow-IPC encoded schema and chunk, compressed according …\nA time-based UID that is used to determine how a <code>StoreInfo</code> …\nVersion of the Rust compiler used to compile the SDK.\nSets <code>compression</code> to the provided enum value.\nSets <code>encoding</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nSets <code>kind</code> to the provided enum value.\nWhen the recording started.\nThe ID of the store that this message is for.\nUnique ID of the recording.\nWhere the recording came from.\nVersion of the store crate.\nA message that contains an Arrow-IPC encoded message.\nA message that contains a blueprint activation command.\nA message that contains a new store info.\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nTODO(zehiko) add properties as needed\nTODO(zehiko) add properties as needed\nEncoding / decoding error\nDataframePart is arrow IPC encoded RecordBatch\nError codes for application level errors\nTODO(jleibs): Eventually this becomes either …\nused to define which column we want to index\nTODO(zehiko) add properties as needed\nmetadata database access error\nobject store access error\nApplication level error - used as <code>details</code> in the …\nunused\nReturns the value of <code>archetype_field_name</code>, or the default …\nOptional name of the field within <code>Archetype</code> associated …\nReturns the value of <code>archetype_name</code>, or the default value …\nOptional name of the <code>Archetype</code> associated with this data.\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nString value of the enum field names used in the ProtoBuf …\nTODO(zehiko) add other properties as needed\nReturns the enum value of <code>code</code>, or the default if the …\nerror code\nComponent / column we want to index\nIndex column that is queried\nColumn projection - define which columns should be …\nSemantic name associated with this data.\nhuman readable description of the recording\nReturns the enum value of <code>distance_metrics</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nReturns the enum value of <code>encoder_version</code>, or the default …\nencoder version used to encode the data\nTODO(zehiko) we need to expand this to become something …\nThe path of the entity.\nwhich catalog entry do we want to create index for\nThe catalog entry that we want to search over If not …\nFilter specific recordings that match the criteria …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i32</code> to a <code>VectorDistanceMetric</code>, or <code>None</code> if <code>value</code>…\nConverts an <code>i32</code> to a <code>RecordingType</code>, or <code>None</code> if <code>value</code> is …\nConverts an <code>i32</code> to a <code>ErrorCode</code>, or <code>None</code> if <code>value</code> is not a …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nCreates an enum from field names used in the ProtoBuf …\nunique identifier associated with the request (e.g. …\nNested message and enum types in <code>IndexProperties</code>.\nNested message and enum types in <code>IndexQueryProperties</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>VectorDistanceMetric</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>RecordingType</code>.\nReturns <code>true</code> if <code>value</code> is a variant of <code>ErrorCode</code>.\nReturns the value of <code>limit</code>, or the default value if <code>limit</code> …\nmax number of rows to be returned\nhuman readable details about the error\n(optional) any additional metadata that should be …\nData payload is Arrow IPC encoded RecordBatch\nraw bytes are TransportChunks (i.e. RecordBatches) encoded …\npayload is raw bytes that the relevant codec can interpret\nwhat kind of index do we want to create and what are its …\nIndex type specific properties\nspecific index query properties based on the index type\nQuery data - type of data is index specific. Caller must …\nquery to execute\nunique identifier of the recording\nunique identifier of the recording\nFiltering is very simple right now, we can only select …\nSets <code>code</code> to the provided enum value.\nSets <code>distance_metrics</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>encoder_version</code> to the provided enum value.\nSets <code>typ</code> to the provided enum value.\nGenerated client implementations.\nGenerated server implementations.\nrecording storage url (e.g. s3://bucket/file or …\nWhat is the filter index i.e. timeline for which we will …\nReturns the enum value of <code>typ</code>, or the default if the field …\ntype of recording\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nspecific index query properties based on the index type\nEncodes the message to a buffer.\nReturns the encoded length of the message without a length …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDecodes an instance of the message from a buffer, and …\nEnable decompressing responses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nThe response to <code>SearchIndex</code> a RecordBatch with 3 columns:\nCompress requests with the given encoding.\nServer streaming response type for the FetchRecording …\nServer streaming response type for the QueryCatalog method.\nServer streaming response type for the Query method.\nGenerated gRPC service name\nServer streaming response type for the SearchIndex method.\nGenerated trait containing gRPC methods that should be …\nEnable decompressing requests with the given encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\ndata API calls\nmetadata API calls\nTODO(zehiko) support registering more than one recording …\nThe response to <code>SearchIndex</code> a RecordBatch with 3 columns:\nCompress responses with the given encoding, if the client …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGenerated client implementations.\nGenerated server implementations.\nSimple buffer for messages between SDKs and viewers.\nEnable decompressing responses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\nCompress requests with the given encoding.\nTODO(jan): Would it be more efficient to send a “message …\nGenerated trait containing gRPC methods that should be …\nSimple buffer for messages between SDKs and viewers.\nServer streaming response type for the ReadMessages method.\nGenerated gRPC service name\nEnable decompressing requests with the given encoding.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLimits the maximum size of a decoded message.\nLimits the maximum size of an encoded message.\nCompress responses with the given encoding, if the client …\nTODO(jan): Would it be more efficient to send a “message …")