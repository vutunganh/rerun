searchState.loadedDescShard("re_memory", 0, "Run-time memory tracking and profiling.\nPer-callstack statistics.\nNumber of allocation and their total size.\nTracks memory use over time.\nRepresents a limit in how much RAM to use for the entire …\nHow much RAM is the application using?\nHelper to warn if we are using too much RAM.\nFormatted backtrace.\nTrack allocations and memory use.\nAdd an allocation.\nNumber of allocations.\nBytes used by the application according to our own memory …\nBytes used by the application according to our own memory …\nBytes used by the blueprint store according to its own …\nVRAM bytes used by the application according to its own …\nBytes used by the primary caches according to their own …\nBytes used by the datastore according to its own …\nLive allocations at this callstack.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLimit in bytes.\nHuman-readable backtrace.\nFor when we print this statistic.\nBytes allocated by the application according to operating …\nBytes allocated by the application according to operating …\nNumber of bytes.\nIf this was stochastically sampled - at what rate?\nRemove an allocation.\nAmount of available RAM on this machine.\nUtitility functions\nInstall this as the global allocator to get memory usage …\nStatistics about extant allocations larger than <code>MEDIUM_SIZE</code>…\nUsed to prevent re-entrancy when tracking allocations.\nStatistics about some extant allocations larger than  …\nAllocations smaller than are stochastically sampled.\nOnly track allocations of at least this size.\nAdd an allocation.\nNumber of allocations.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll live allocations tracked by the large <code>AllocationTracker</code>…\nAll live largish allocations, fully tracked.\nTotal number of live allocations, and the number of live …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we doing (slightly expensive) tracking of the …\nAll extant allocations.\nThe live allocations done by <code>AllocationTracker</code> used for …\nAll live allocations used for internal book-keeping.\nShould we do (slightly expensive) tracking of the …\nNumber of bytes.\nAll live allocations sampled by the stochastic medium …\nAll live allocations sampled of medium size, …\nRemove an allocation.\nThe most popular callstacks.\nDo detailed statistics of allocations? This is expensive, …\nAllocations smaller than these are left untracked.\nGather statistics from the live tracking, if enabled.\nTurn on callstack tracking (slightly expensive) if a given …\nThe live allocations not tracked by any <code>AllocationTracker</code>.\nAll live allocations that we are NOT tracking (because …\nTrack the callstacks of allocations.\nPer-callstack statistics.\nA hash of a pointer address.\nFormatted backtrace.\nHow much memory is allocated by each callstack?\nLive allocations at this callstack.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCurrent live allocations.\nHuman-readable backtrace.\nFor when we print this statistic.\nDe-duplicated readable backtraces.\nSample every N allocations. Must be power-of-two.\nIf this was stochastically sampled - at what rate?\nReturn the <code>n</code> callstacks that currently is using the most …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAnonymize a path to a Rust source file from a callstack.\nTracks memory use over time.\nAdd data to history\nBytes used by the application according to our own memory …\nBytes used by the blueprint store according to its own …\nVRAM bytes used by the application according to its own …\nBytes used by the primary caches according to their own …\nBytes used by the datastore according to its own …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBytes allocated by the application according to operating …\nRepresents a limit in how much RAM to use for the entire …\nNo limit.\nReturns the argument unchanged.\nSet the limit to some number of bytes.\nSet the limit to some fraction (0-1) of the total …\nCalls <code>U::from(self)</code>.\nReturns how large fraction of memory we should free to go …\nLimit in bytes.\nThe limit can either be absolute (e.g. “16GB”) or …\nHow much RAM is the application using?\nAccording to the OS. This is what matters.\nRead the current memory of the running application.\nBytes used by the application according to our own memory …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBytes allocated by the application according to operating …\nBytes used by the application according to our best …\nHelper to warn if we are using too much RAM.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAmount of available RAM on this machine.\nWarns if we have exceeded the limit.\nReturns monotonically increasing time in seconds.")