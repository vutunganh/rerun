<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Helpers for capturing screenshots of the UI."><title>rerun::external::eframe::egui_wgpu::capture - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="rerun" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../rerun/index.html">rerun</a><span class="version">0.22.1</span></h2></div><h2 class="location"><a href="#">Module capture</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In rerun::external::eframe::egui_wgpu</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../../index.html">rerun</a>::<wbr><a href="../../../index.html">external</a>::<wbr><a href="../../index.html">eframe</a>::<wbr><a href="../index.html">egui_wgpu</a>::<wbr><a class="mod" href="#">capture</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Helpers for capturing screenshots of the UI.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CaptureState.html" title="struct rerun::external::eframe::egui_wgpu::capture::CaptureState">CaptureState</a></div><div class="desc docblock-short">A texture and a buffer for reading the rendered frame back to the cpu.
The texture is required since <a href="../wgpu/struct.TextureUsages.html#associatedconstant.COPY_SRC" title="associated constant rerun::external::eframe::egui_wgpu::wgpu::TextureUsages::COPY_SRC"><code>wgpu::TextureUsages::COPY_SRC</code></a> is not an allowed
flag for the surface texture on all platforms. This means that anytime we want to
capture the frame, we first render it to this texture, and then we can copy it to
both the surface texture (via a render pass) and the buffer (via a texture to buffer copy),
from where we can pull it back
to the cpu.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.capture_channel.html" title="fn rerun::external::eframe::egui_wgpu::capture::capture_channel">capture_channel</a></div><div class="desc docblock-short">Creates a new asynchronous channel, returning the sender/receiver halves.
All data sent on the <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/struct.Sender.html" title="struct std::sync::mpsc::Sender"><code>Sender</code></a> will become available on the <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/struct.Receiver.html" title="struct std::sync::mpsc::Receiver"><code>Receiver</code></a> in
the same order as it was sent, and no <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/struct.Sender.html#method.send" title="method std::sync::mpsc::Sender::send"><code>send</code></a> will block the calling thread
(this channel has an “infinite buffer”, unlike <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/fn.sync_channel.html" title="fn std::sync::mpsc::sync_channel"><code>sync_channel</code></a>, which will
block after its buffer limit is reached). <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/struct.Receiver.html#method.recv" title="method std::sync::mpsc::Receiver::recv"><code>recv</code></a> will block until a message
is available while there is at least one <a href="https://doc.rust-lang.org/1.81.0/std/sync/mpsc/struct.Sender.html" title="struct std::sync::mpsc::Sender"><code>Sender</code></a> alive (including clones).</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.CaptureReceiver.html" title="type rerun::external::eframe::egui_wgpu::capture::CaptureReceiver">CaptureReceiver</a></div></li><li><div class="item-name"><a class="type" href="type.CaptureSender.html" title="type rerun::external::eframe::egui_wgpu::capture::CaptureSender">CaptureSender</a></div></li></ul></section></div></main></body></html>