<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Video frame decoding."><title>re_video::decode - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="re_video" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../re_video/index.html">re_video</a><span class="version">0.22.1</span></h2></div><h2 class="location"><a href="#">Module decode</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate re_video</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">re_video</a>::<wbr><a class="mod" href="#">decode</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/re_video/decode/mod.rs.html#1-467">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="video-frame-decoding"><a class="doc-anchor" href="#video-frame-decoding">§</a>Video frame decoding.</h2><h3 id="whirlwind-tour-of-how-to-interpret-picture-data-from-a-video-perspective"><a class="doc-anchor" href="#whirlwind-tour-of-how-to-interpret-picture-data-from-a-video-perspective">§</a>Whirlwind tour of how to interpret picture data (from a Video perspective)</h3>
<p>Extracted from the <a href="https://wiki.x266.mov/docs/colorimetry/intro">av1 codec wiki</a> and other sources.
Follows the trail of information we get from our AV1 decoder.</p>
<h4 id="how-to-get-from-yuv-to-rgb"><a class="doc-anchor" href="#how-to-get-from-yuv-to-rgb">§</a>How to get from YUV to RGB?</h4>
<p>Things to know about the incoming yuv data:</p>
<ul>
<li><code>picture.bit_depth()</code>
<ul>
<li>is either 8 or 16</li>
<li>that’s how the decoder stores for us but the per component we have either 8 or 10 or 12 bits -&gt; see <code>picture.bits_per_component()</code></li>
</ul>
</li>
<li><code>picture.pixel_layout()</code>
<ul>
<li><code>4:0:0</code> greyscale</li>
<li><code>4:2:0</code> half horizontal and half vertical resolution for chroma</li>
<li><code>4:2:2</code> half horizontal resolution for chroma</li>
<li><code>4:4:4</code> full resolution for chroma</li>
<li>note that the AV1 decoder gives us always (!) planar data</li>
</ul>
</li>
<li><code>picture.color_range()</code>
<ul>
<li>yuv data range may be either <code>limited</code> or <code>full</code></li>
<li><code>full</code> is what you’d naively expect, just full use up the entire 8/10/12 bits!</li>
<li><code>limited</code> means that only a certain range of values is valid
<ul>
<li>weirdly enough, DO NOT CLAMP! a lot of software may say it’s limited but then use the so-called foot and head space anyways to go outside the regular colors
<ul>
<li>reportedly (read this on some forums ;-)) some players <em>do</em> clamp, so let’s not get too concerned about this</li>
</ul>
</li>
<li>it’s a remnant of the analog age, but it’s still very common!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="given-a-normalized-yuv-triplet-how-do-we-get-color"><a class="doc-anchor" href="#given-a-normalized-yuv-triplet-how-do-we-get-color">§</a>Given a normalized YUV triplet, how do we get color?</h4>
<ul>
<li><code>picture.matrix_coefficients()</code> (see <a href="https://wiki.x266.mov/docs/colorimetry/matrix">https://wiki.x266.mov/docs/colorimetry/matrix</a>)
<ul>
<li>this tells us what to multiply the incoming YUV data with to get SOME RGB data</li>
<li>there’s various standards of how to do this, but the most common is BT.709</li>
<li>here’s a fun special one: <code>identity</code> means it’s not actually YUV, but GBR!</li>
</ul>
</li>
<li><code>picture.primaries()</code>
<ul>
<li>now we have RGB but we kinda have no idea what that means!</li>
<li>the color primaries tell us which space we’re in</li>
<li>…meaning that if the primaries are anything else we’d have to do some conversion BUT
it also means that we have no chance of displaying the picture perfectly on a screen taking in sRGB (or any other not-matching color space)</li>
<li><a href="https://en.wikipedia.org/wiki/Rec._709#Relationship_to_sRGB">Wikipedia says</a> sRGB uses the same primaries as BT.709
<ul>
<li>but I also found other sources (e.g. <a href="https://forum.doom9.org/showthread.php?p=1640342#post1640342">this forum post</a>)
clamining that they’re just close enough to be considered the same for practical purposes</li>
</ul>
</li>
</ul>
</li>
<li><code>picture.transfer_characteristics()</code>
<ul>
<li>until this point everything is “gamma compressed”, or more accurately, went through Opto Electric Transfer Function (OETF)
<ul>
<li>i.e. measure of light in, electronic signal out</li>
</ul>
</li>
<li>we have to keep in mind the EOTF that our screen at the other end will use which for today’s renderpipeline is always sRGB
(meaning it’s a 2.2 gamma curve with a small linear part)</li>
<li>Similar to the primaries, BT.709 uses a <em>similar</em> transfer function as sRGB, but not exactly the same
<a href="https://www.image-engineering.de/library/technotes/714-color-spaces-rec-709-vs-srgb">https://www.image-engineering.de/library/technotes/714-color-spaces-rec-709-vs-srgb</a>
<ul>
<li>There’s reason to believe players just ignore this:
<ul>
<li>From a <a href="https://code.videolan.org/videolan/vlc/-/issues/26999">VLC issue</a>:
<blockquote>
<p>We do not support transfers or primaries anyway, so it does not matter
(we do support HDR transfer functions PQ and HLG, not SDR ones and we support BT.2020 primaries, but not SMPTE C (which is what BT.601 NTSC is)).“</p>
</blockquote>
</li>
<li>…I’m sure I found a report of other video players ignoring this and most of everything except <code>matrix_coefficients</code> but I can’t find it anymore :(</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>All of the above are completely optional for a video to specify and there’s sometimes some interplay of relationships with those.
(a standard would often specify several things at once, there’s typical and less typical combinations)
So naturally, people will use terms sloppily and interchangeably,
If anything is lacking a video player has to make a guess.
… and as discussed above, even it’s there, often video players tend to ignore some settings!</p>
<p>With all this out of the way…</p>
<h4 id="whats-the-state-of-us-making-use-of-all-these-things"><a class="doc-anchor" href="#whats-the-state-of-us-making-use-of-all-these-things">§</a>What’s the state of us making use of all these things?</h4>
<ul>
<li>❌ <code>picture.bit_depth()</code>
<ul>
<li>TODO(#7594): ignored, we just pretend everything is 8 bits</li>
</ul>
</li>
<li>✅ <code>picture.pixel_layout()</code></li>
<li>✅ <code>picture.color_range()</code></li>
<li>🟧 <code>picture.matrix_coefficients()</code>
<ul>
<li>we try to figure out whether to use <code>BT.709</code> or <code>BT.601</code> coefficients, using other characteristics for guessing if nothing else is available.</li>
</ul>
</li>
<li>❌ <code>picture.primaries()</code></li>
<li>❌ <code>picture.transfer_characteristics()</code></li>
</ul>
<p>We’ll very likely be good with this until either we get specific feature requests and/or we’ll start
supporting HDR content at which point more properties will be important!</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="async_decoder_wrapper/index.html" title="mod re_video::decode::async_decoder_wrapper">async_decoder_wrapper</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="av1/index.html" title="mod re_video::decode::av1">av1</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">AV1 support.</div></li><li><div class="item-name"><a class="mod" href="ffmpeg_h264/index.html" title="mod re_video::decode::ffmpeg_h264">ffmpeg_h264</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Chunk.html" title="struct re_video::decode::Chunk">Chunk</a></div><div class="desc docblock-short">One chunk of encoded video data, representing a single <a href="../demux/struct.Sample.html" title="struct re_video::demux::Sample"><code>crate::Sample</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.DecodeSettings.html" title="struct re_video::decode::DecodeSettings">DecodeSettings</a></div><div class="desc docblock-short">Settings for video decoding.</div></li><li><div class="item-name"><a class="struct" href="struct.FFmpegVersion.html" title="struct re_video::decode::FFmpegVersion">FFmpegVersion</a></div><div class="desc docblock-short">A successfully parsed <code>FFmpeg</code> version.</div></li><li><div class="item-name"><a class="struct" href="struct.Frame.html" title="struct re_video::decode::Frame">Frame</a></div><div class="desc docblock-short">One decoded video frame.</div></li><li><div class="item-name"><a class="struct" href="struct.FrameContent.html" title="struct re_video::decode::FrameContent">FrameContent</a></div><div class="desc docblock-short">Data for a decoded frame on native targets.</div></li><li><div class="item-name"><a class="struct" href="struct.FrameInfo.html" title="struct re_video::decode::FrameInfo">FrameInfo</a></div><div class="desc docblock-short">Meta information about a decoded video frame, as reported by the decoder.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DecodeHardwareAcceleration.html" title="enum re_video::decode::DecodeHardwareAcceleration">DecodeHardwareAcceleration</a></div><div class="desc docblock-short">How the video should be decoded.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum re_video::decode::Error">Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.FFmpegError.html" title="enum re_video::decode::FFmpegError">FFmpegError</a></div></li><li><div class="item-name"><a class="enum" href="enum.FFmpegVersionParseError.html" title="enum re_video::decode::FFmpegVersionParseError">FFmpegVersionParseError</a></div></li><li><div class="item-name"><a class="enum" href="enum.PixelFormat.html" title="enum re_video::decode::PixelFormat">PixelFormat</a></div><div class="desc docblock-short">Pixel format/layout used by <a href="struct.FrameContent.html#structfield.data" title="field re_video::decode::FrameContent::data"><code>FrameContent::data</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.YuvMatrixCoefficients.html" title="enum re_video::decode::YuvMatrixCoefficients">YuvMatrixCoefficients</a></div><div class="desc docblock-short">Yuv matrix coefficients used by <a href="enum.PixelFormat.html#variant.Yuv" title="variant re_video::decode::PixelFormat::Yuv"><code>PixelFormat::Yuv</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.YuvPixelLayout.html" title="enum re_video::decode::YuvPixelLayout">YuvPixelLayout</a></div><div class="desc docblock-short">Pixel layout used by <a href="enum.PixelFormat.html#variant.Yuv" title="variant re_video::decode::PixelFormat::Yuv"><code>PixelFormat::Yuv</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.YuvRange.html" title="enum re_video::decode::YuvRange">YuvRange</a></div><div class="desc docblock-short">Yuv value range used by <a href="enum.PixelFormat.html#variant.Yuv" title="variant re_video::decode::PixelFormat::Yuv"><code>PixelFormat::Yuv</code></a>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsyncDecoder.html" title="trait re_video::decode::AsyncDecoder">AsyncDecoder</a></div><div class="desc docblock-short">Interface for an asynchronous video decoder.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.ffmpeg_download_url.html" title="fn re_video::decode::ffmpeg_download_url">ffmpeg_download_url</a></div><div class="desc docblock-short">Download URL for the latest version of <code>FFmpeg</code> on the current platform.
None if the platform is not supported.</div></li><li><div class="item-name"><a class="fn" href="fn.new_decoder.html" title="fn re_video::decode::new_decoder">new_decoder</a></div><div class="desc docblock-short">Creates a new async decoder for the given <code>video</code> data.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.OutputCallback.html" title="type re_video::decode::OutputCallback">OutputCallback</a></div></li><li><div class="item-name"><a class="type" href="type.Result.html" title="type re_video::decode::Result">Result</a></div></li></ul></section></div></main></body></html>