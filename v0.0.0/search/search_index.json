{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"docs/","title":"Python Docs","text":"<p>A high-level overview of writing and previewing the Rerun python documentation.</p>"},{"location":"docs/#getting-started-with-docs","title":"Getting started with docs","text":""},{"location":"docs/#dependencies","title":"Dependencies","text":"<p>All of the dependencies for documentation generation are captured in the requirements file:</p> <pre><code>pip install -r rerun_py/requirements-doc.txt\n</code></pre>"},{"location":"docs/#serving-the-docs-locally","title":"Serving the docs locally","text":"<p>The docs can be previewed locally using <code>mkdocs</code></p> <p>This will watch the contents of the <code>rerun_py</code> folder and refresh documentation live as files are changed.</p> <pre><code>mkdocs serve -f rerun_py/mkdocs.yml -w rerun_py\n</code></pre> <p>or</p> <pre><code>just serve-py-docs\n</code></pre>"},{"location":"docs/#how-versioned-docs-are-generated-and-served","title":"How versioned docs are generated and served","text":"<p>Our documentation is versioned with releases and generated via mike</p> <p>The documentation exists as a Github Pages project which is hosted from the contents of the <code>gh-pages</code> branch.</p> <p><code>mike</code> updates this branch with new content as part of CI</p> <p>Every commit that lands to main will generate bleeding edge documentation as HEAD. Behind the scenes, a github action is just running:</p> <pre><code>mike deploy -F rerun_py/mkdocs.yml HEAD\n</code></pre> <p>On release, when github sees a new tag: <code>X.Y.Z</code>, the github action will instead deploy with a version tag:</p> <pre><code>mike deploy -F rerun_py/mkdocs.yml X.Y.Z latest\n</code></pre> <p>You can also locally preview the publicly hosted site with all versions, using mike:</p> <pre><code>mike serve -F rerun_py/mkdocs.yml\n</code></pre> <p>though when locally developing docs you are better off using <code>mkdocs serve</code> as described above since it will handle hot-reloading for you as you edit.</p>"},{"location":"common/","title":"Common APIs","text":"<p>Warning</p> <p>TODO(jleibs): Very high level pointers to common API groups</p>"},{"location":"common/annotation/","title":"Annotations","text":""},{"location":"common/annotation/#rerun.log_annotation_context","title":"<code>def rerun.log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"common/images/","title":"Logging Images","text":""},{"location":"common/images/#rerun.log_image","title":"<code>def rerun.log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"common/images/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_image_file","title":"<code>def rerun.log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_path</code> <code>Path</code> <p>Path to the image file.</p> required <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_depth_image","title":"<code>def rerun.log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"common/images/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/images/#rerun.log_segmentation_image","title":"<code>def rerun.log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"common/images/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"common/initialization/","title":"Initialization","text":""},{"location":"common/initialization/#rerun.init","title":"<code>def rerun.init(application_id, spawn_and_connect=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For instance, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>spawn_and_connect</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn_and_connect</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code>"},{"location":"common/initialization/#rerun.set_recording_id","title":"<code>def rerun.set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The recording ID to use for this process.</p> required"},{"location":"common/initialization/#rerun.connect","title":"<code>def rerun.connect(addr=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer, e.g. with 'python -m rerun'</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>The ip:port to connect to</p> <code>None</code>"},{"location":"common/initialization/#rerun.spawn_and_connect","title":"<code>def rerun.spawn_and_connect(port=9876)</code>","text":"<p>Spawn a Rerun Viewer and stream logging data to it.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to connect to</p> <code>9876</code>"},{"location":"common/initialization/#rerun.spawn_and_connect--see-also","title":"See Also","text":"<ul> <li>rerun.connect</li> </ul>"},{"location":"common/plotting/","title":"Plotting","text":""},{"location":"common/plotting/#rerun.log_scalar","title":"<code>def rerun.log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p> <p>Understanding the plot and attributes hierarchy</p> <p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points. If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code>"},{"location":"common/primitives/","title":"Logging Primitives","text":""},{"location":"common/primitives/#rerun.log_point","title":"<code>def rerun.log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/primitives/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Union[Sequence[float], npt.NDArray[np.float32], None]</code> <p>2x1 or 3x1 array.</p> required <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional color of the point.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_points","title":"<code>def rerun.log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/primitives/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Union[Sequence[Sequence[float]], Optional[npt.NDArray[np.float32]]]</code> <p>Nx2 or Nx3 array</p> required <code>identifiers</code> <code>Optional[Union[Sequence[int], npt.NDArray[Any]]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_rect","title":"<code>def rerun.log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_rects","title":"<code>def rerun.log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"common/primitives/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_obb","title":"<code>def rerun.log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the OBB edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_path","title":"<code>def rerun.log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.NDArray[np.float32]]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_line_segments","title":"<code>def rerun.log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.NDArray[np.float32]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"common/primitives/#rerun.log_arrow","title":"<code>def rerun.log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"common/transforms/","title":"Transforms","text":""},{"location":"common/transforms/#rerun.log_rigid3","title":"<code>def rerun.log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"common/transforms/#rerun.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"common/transforms/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"},{"location":"common/transforms/#rerun.log_pinhole","title":"<code>def rerun.log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"common/transforms/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Horizontal resolution of the child space.</p> required <code>height</code> <code>int</code> <p>Vertical resolution of the child space.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"common/transforms/#rerun.log_unknown_transform","title":"<code>def rerun.log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"common/transforms/#rerun.log_view_coordinates","title":"<code>def rerun.log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"common/transforms/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"package/","title":"Full Package","text":"<ul> <li>rerun: Top-level User-facing APIs. See also: Common APIs<ul> <li>rerun.log: APIs for logging data</li> <li>rerun.color_conversion: Conversion utilities related to colors</li> <li>rerun.components: Helpers for constructing arrow components</li> </ul> </li> </ul>"},{"location":"package/rerun/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/__init__/#rerun","title":"<code>rerun</code>","text":"<p>The Rerun Python SDK, which is a wrapper around the rerun_sdk crate.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Horizontal resolution of the child space.</p> required <code>height</code> <code>int</code> <p>Vertical resolution of the child space.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_image","title":"<code>def log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/__init__/#rerun.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_scalar","title":"<code>def log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p> <p>Understanding the plot and attributes hierarchy</p> <p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points. If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_path","title":"<code>def log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.NDArray[np.float32]]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_obb","title":"<code>def log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the OBB edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_point","title":"<code>def log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Union[Sequence[float], npt.NDArray[np.float32], None]</code> <p>2x1 or 3x1 array.</p> required <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional color of the point.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_tensor","title":"<code>def log_tensor(entity_path, tensor, names=None, meter=None, timeless=False)</code>","text":"<p>Log an arbitrary-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor objector.</p> required <code>names</code> <code>Optional[Iterable[str]]</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>Optional[float]</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p><code>transform</code> is an optional 3x4 affine transform matrix applied to the mesh.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_file</code> <code>bytes</code> <p>Contents of the mesh file</p> required <code>transform</code> <code>Optional[npt.NDArray[np.float32]]</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.get_recording_id","title":"<code>def get_recording_id()</code>","text":"<p>Get the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Returns:</p> Type Description <code>str</code> <p>The recording ID that this process is logging to.</p>"},{"location":"package/rerun/__init__/#rerun.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/__init__/#rerun.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.NDArray[np.float32]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"package/rerun/__init__/#rerun.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/__init__/#rerun.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.set_recording_id","title":"<code>def set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The recording ID to use for this process.</p> required"},{"location":"package/rerun/__init__/#rerun.log_image_file","title":"<code>def log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_path</code> <code>Path</code> <p>Path to the image file.</p> required <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/__init__/#rerun.log_text_entry","title":"<code>def log_text_entry(entity_path, text, level=LogLevel.INFO, color=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.init","title":"<code>def init(application_id, spawn_and_connect=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For instance, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <code>spawn_and_connect</code> <code>bool</code> <p>Spawn a Rerun Viewer and stream logging data to it. Short for calling <code>spawn_and_connect</code> separately. If you don't call this, log events will be buffered indefinitely until you call either <code>connect</code>, <code>show</code>, or <code>save</code></p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_points","title":"<code>def log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/__init__/#rerun.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Union[Sequence[Sequence[float]], Optional[npt.NDArray[np.float32]]]</code> <p>Nx2 or Nx3 array</p> required <code>identifiers</code> <code>Optional[Union[Sequence[int], npt.NDArray[Any]]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.spawn_and_connect","title":"<code>def spawn_and_connect(port=9876)</code>","text":"<p>Spawn a Rerun Viewer and stream logging data to it.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to connect to</p> <code>9876</code>"},{"location":"package/rerun/__init__/#rerun.spawn_and_connect--see-also","title":"See Also","text":"<ul> <li>rerun.connect</li> </ul>"},{"location":"package/rerun/__init__/#rerun.connect","title":"<code>def connect(addr=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer, e.g. with 'python -m rerun'</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>The ip:port to connect to</p> <code>None</code>"},{"location":"package/rerun/__init__/#rerun.spawn_viewer","title":"<code>def spawn_viewer(port=9876)</code>","text":"<p>Spawn a Rerun Viewer, listening on the given port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The port to listen on.</p> <code>9876</code>"},{"location":"package/rerun/__init__/#rerun.serve","title":"<code>def serve()</code>","text":"<p>Serve a Rerun Web Viewer.</p> <p>WARNING: This is an experimental feature.</p>"},{"location":"package/rerun/__init__/#rerun.disconnect","title":"<code>def disconnect()</code>","text":"<p>Disconnect from the remote rerun server (if any).</p>"},{"location":"package/rerun/__init__/#rerun.show","title":"<code>def show()</code>","text":"<p>Show previously logged data.</p> <p>This only works if you have not called <code>connect</code>.</p> <p>This will clear the logged data after showing it.</p> <p>NOTE: There is a bug which causes this function to only work once on some platforms.</p>"},{"location":"package/rerun/__init__/#rerun.save","title":"<code>def save(path)</code>","text":"<p>Save previously logged data to a file.</p> <p>This only works if you have not called <code>connect</code>.</p> <p>This will clear the logged data after saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the data to.</p> required"},{"location":"package/rerun/__init__/#rerun.set_time_sequence","title":"<code>def set_time_sequence(timeline, sequence)</code>","text":"<p>Set the current time for this thread as an integer sequence.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For instance: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>sequence</code> <code>int</code> <p>The current time on the timeline in integer units.</p> required"},{"location":"package/rerun/__init__/#rerun.set_time_seconds","title":"<code>def set_time_seconds(timeline, seconds)</code>","text":"<p>Set the current time for this thread in seconds.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_seconds</code>.</p> <p>For instance: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>The argument should be in seconds, and should be measured either from the unix epoch (1970-01-01), or from some recent time (e.g. your program startup).</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>seconds</code> <code>float</code> <p>The current time on the timeline in seconds.</p> required"},{"location":"package/rerun/__init__/#rerun.set_time_nanos","title":"<code>def set_time_nanos(timeline, nanos)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_nanos</code>.</p> <p>For instance: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>The argument should be in nanoseconds, and should be measured either from the unix epoch (1970-01-01), or from some recent time (e.g. your program startup).</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>str</code> <p>The name of the timeline to set the time for.</p> required <code>nanos</code> <code>int</code> <p>The current time on the timeline in nanoseconds.</p> required"},{"location":"package/rerun/color_conversion/","title":"color_conversion.py","text":""},{"location":"package/rerun/color_conversion/#rerun.color_conversion","title":"<code>rerun.color_conversion</code>","text":"<p>Color conversion utilities.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.u8_array_to_rgba","title":"<code>def u8_array_to_rgba(arr)</code>","text":"<p>Convert an array[4] of uint8 values into a uint32.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>Sequence[int]</code> <p>The array of uint8 values to convert in RGBA order.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The uint32 value as 0xRRGGBBAA.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_value","title":"<code>def linear_to_gamma_u8_value(linear)</code>","text":"<p>Transform color values from linear [0.0, 1.0] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype numpy.floating</p> <p>Intended to implement the following per color value:</p> <pre><code>if l &lt;= 0.0 {\n    0\n} else if l &lt;= 0.0031308 {\n    round(3294.6 * l)\n} else if l &lt;= 1.0 {\n    round(269.025 * l.powf(1.0 / 2.4) - 14.025)\n} else {\n    255\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[Union[np.float32, np.float64]]</code> <p>The linear color values to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color values.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_pixel","title":"<code>def linear_to_gamma_u8_pixel(linear)</code>","text":"<p>Transform color pixels from linear [0, 1] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype np.float32 or np.float64.</p> <p>The last dimension of the colors array <code>linear</code> is expected to represent a single pixel color. - 3 colors means RGB - 4 colors means RGBA</p> <p>Parameters:</p> Name Type Description Default <code>linear</code> <code>npt.NDArray[Union[np.float32, np.float64]]</code> <p>The linear color pixels to transform.</p> required <p>Returns:</p> Type Description <code>np.ndarray[np.uint8]</code> <p>The gamma encoded color pixels.</p>"},{"location":"package/rerun/components/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/components/__init__/#rerun.components","title":"<code>rerun.components</code>","text":"<p>The components package defines Python wrapper types for common registered Rerun components.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.ComponentTypeFactory","title":"<code>def ComponentTypeFactory(name, array_cls, field)</code>","text":"<p>Build a component type wrapper.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.build_dense_union","title":"<code>def build_dense_union(data_type, discriminant, child)</code>","text":"<p>Build a dense UnionArray given the <code>data_type</code>, a discriminant, and the child value array.</p> <p>If the discriminant string doesn't match any possible value, a <code>ValueError</code> is raised.</p>"},{"location":"package/rerun/components/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation","title":"<code>rerun.components.annotation</code>","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray","title":"<code>class ClassIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ClassIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray","title":"<code>class KeypointIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>KeypointIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow","title":"<code>rerun.components.arrow</code>","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray","title":"<code>class Arrow3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray.from_numpy","title":"<code>def from_numpy(origins, vectors)</code>","text":"<p>Build a <code>Arrow3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/box/","title":"box.py","text":""},{"location":"package/rerun/components/box/#rerun.components.box","title":"<code>rerun.components.box</code>","text":""},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray","title":"<code>class Box3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Box3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/color/","title":"color.py","text":""},{"location":"package/rerun/components/color/#rerun.components.color","title":"<code>rerun.components.color</code>","text":""},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray","title":"<code>class ColorRGBAArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ColorRGBAArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/instance/","title":"instance.py","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance","title":"<code>rerun.components.instance</code>","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray","title":"<code>class InstanceArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>InstanceArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/label/","title":"label.py","text":""},{"location":"package/rerun/components/label/#rerun.components.label","title":"<code>rerun.components.label</code>","text":""},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray","title":"<code>class LabelArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray.new","title":"<code>def new(labels)</code>","text":"<p>Build a <code>LabelArray</code> from a sequence of str.</p>"},{"location":"package/rerun/components/linestrip/","title":"linestrip.py","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip","title":"<code>rerun.components.linestrip</code>","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray","title":"<code>class LineStrip2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip2DArray</code> from an array of [Nx2 numpy array].</p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray","title":"<code>class LineStrip3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip3DArray</code> from an array of [Nx3 numpy array].</p>"},{"location":"package/rerun/components/point/","title":"point.py","text":""},{"location":"package/rerun/components/point/#rerun.components.point","title":"<code>rerun.components.point</code>","text":""},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray","title":"<code>class Point2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray","title":"<code>class Point3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion","title":"<code>rerun.components.quaternion</code>","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray","title":"<code>class QuaternionArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>QuaternionArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/radius/","title":"radius.py","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius","title":"<code>rerun.components.radius</code>","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray","title":"<code>class RadiusArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>RadiusArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/rect2d/","title":"rect2d.py","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d","title":"<code>rerun.components.rect2d</code>","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray","title":"<code>class Rect2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray.from_numpy_and_format","title":"<code>def from_numpy_and_format(array, rect_format)</code>","text":"<p>Build a <code>Rect2DArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar","title":"<code>rerun.components.scalar</code>","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray","title":"<code>class ScalarArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ScalarArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray","title":"<code>class ScalarPlotPropsArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray.from_props","title":"<code>def from_props(props)</code>","text":"<p>Build a <code>ScalarPlotPropsArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor","title":"<code>rerun.components.tensor</code>","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray","title":"<code>class TensorArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray.from_numpy","title":"<code>def from_numpy(array, names=None, meaning=None, meter=None)</code>","text":"<p>Build a <code>TensorArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/text_entry/","title":"text_entry.py","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry","title":"<code>rerun.components.text_entry</code>","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray","title":"<code>class TextEntryArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray.from_bodies_and_levels","title":"<code>def from_bodies_and_levels(text_entries)</code>","text":"<p>Build a <code>TextEntryArray</code> from a sequence of text bodies and log levels.</p>"},{"location":"package/rerun/components/vec/","title":"vec.py","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec","title":"<code>rerun.components.vec</code>","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray","title":"<code>class Vec2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray","title":"<code>class Vec3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/log/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/log/__init__/#rerun.log","title":"<code>rerun.log</code>","text":""},{"location":"package/rerun/log/__init__/#rerun.log.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/log/__init__/#rerun.log.set_visible","title":"<code>def set_visible(entity_path, visibile)</code>","text":"<p>set_visible has been deprecated.</p> <p>The replacement is <code>log_cleared()</code>. See: https://github.com/rerun-io/rerun/pull/285 for details</p>"},{"location":"package/rerun/log/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation","title":"<code>rerun.log.annotation</code>","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfoLike","title":"<code>AnnotationInfoLike = Union[Tuple[int, str], Tuple[int, str, Color], AnnotationInfo]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify an AnnotationInfo</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescriptionLike","title":"<code>ClassDescriptionLike = Union[AnnotationInfoLike, ClassDescription]</code>  <code>module-attribute</code>","text":"<p>Type helper representing the different ways to specify a ClassDescription</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo","title":"<code>class AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.id","title":"<code>id: int = 0</code>  <code>class-attribute</code>","text":"<p>The id of the class or key-point to annotate</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.label","title":"<code>label: Optional[str] = None</code>  <code>class-attribute</code>","text":"<p>The label that will be shown in the UI</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo.color","title":"<code>color: Optional[Color] = None</code>  <code>class-attribute</code>","text":"<p>The color that will be applied to the annotated entity</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription","title":"<code>class ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.info","title":"<code>info: Optional[AnnotationInfoLike] = None</code>  <code>class-attribute</code>","text":"<p>The annotation info for the class</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_annotations","title":"<code>keypoint_annotations: Optional[Iterable[AnnotationInfoLike]] = None</code>  <code>class-attribute</code>","text":"<p>The annotation infos for the all key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription.keypoint_connections","title":"<code>keypoint_connections: Optional[Iterable[Union[int, Tuple[int, int]]]] = None</code>  <code>class-attribute</code>","text":"<p>The connections between key-points</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the annotation context in the space hierarchy.</p> required <code>class_descriptions</code> <code>Union[ClassDescriptionLike, Iterable[ClassDescriptionLike]]</code> <p>A single ClassDescription or a collection of ClassDescriptions.</p> required <code>timeless</code> <code>bool</code> <p>If true, the annotation context will be timeless (default: True).</p> <code>True</code>"},{"location":"package/rerun/log/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow","title":"<code>rerun.log.arrow</code>","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/log/bounding_box/","title":"bounding_box.py","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box","title":"<code>rerun.log.bounding_box</code>","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb","title":"<code>def log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the oriented bounding box in the space hierarchy.</p> required <code>half_size</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] half dimensions of the OBB.</p> required <code>position</code> <code>Optional[npt.ArrayLike]</code> <p>Array with [x, y, z] position of the OBB in world space.</p> <code>None</code> <code>rotation_q</code> <code>Optional[npt.ArrayLike]</code> <p>Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>stroke_width</code> <code>Optional[float]</code> <p>Optional width of the OBB edges.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text label placed at <code>position</code>.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the OBB.  The class id provides colors and labels if not specified explicitly.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the bounding box will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/camera/","title":"camera.py","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera","title":"<code>rerun.log.camera</code>","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the child (image) space in the space hierarchy.</p> required <code>child_from_parent</code> <code>npt.ArrayLike</code> <p>Row-major intrinsics matrix for projecting from camera space to image space.</p> required <code>width</code> <code>int</code> <p>Horizontal resolution of the child space.</p> required <code>height</code> <code>int</code> <p>Vertical resolution of the child space.</p> required <code>timeless</code> <code>bool</code> <p>If true, the camera will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/error_utils/","title":"error_utils.py","text":""},{"location":"package/rerun/log/error_utils/#rerun.log.error_utils","title":"<code>rerun.log.error_utils</code>","text":""},{"location":"package/rerun/log/file/","title":"file.py","text":""},{"location":"package/rerun/log/file/#rerun.log.file","title":"<code>rerun.log.file</code>","text":""},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat","title":"<code>class MeshFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Mesh file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.GLB","title":"<code>GLB = 'GLB'</code>  <code>class-attribute</code>","text":"<p>glTF binary format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.MeshFormat.OBJ","title":"<code>OBJ = 'OBJ'</code>  <code>class-attribute</code>","text":"<p>Wavefront .obj format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat","title":"<code>class ImageFormat</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Image file format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.ImageFormat.JPEG","title":"<code>JPEG = 'jpeg'</code>  <code>class-attribute</code>","text":"<p>JPEG format.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p><code>transform</code> is an optional 3x4 affine transform matrix applied to the mesh.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the mesh in the space hierarchy</p> required <code>mesh_format</code> <code>MeshFormat</code> <p>Format of the mesh file</p> required <code>mesh_file</code> <code>bytes</code> <p>Contents of the mesh file</p> required <code>transform</code> <code>Optional[npt.NDArray[np.float32]]</code> <p>Optional 3x4 affine transform matrix applied to the mesh</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the mesh will be timeless (default: False)</p> <code>False</code>"},{"location":"package/rerun/log/file/#rerun.log.file.log_image_file","title":"<code>def log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>img_path</code> <code>Path</code> <p>Path to the image file.</p> required <code>img_format</code> <code>Optional[ImageFormat]</code> <p>Format of the image file.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/","title":"image.py","text":""},{"location":"package/rerun/log/image/#rerun.log.image","title":"<code>rerun.log.image</code>","text":""},{"location":"package/rerun/log/image/#rerun.log.image.log_image","title":"<code>def log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_image--supported-dtypes","title":"Supported dtypes","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space.</li> <li>float32, float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16, float32, float64</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>Tensor</code> <p>A Tensor representing the depth image to log.</p> required <code>meter</code> <code>Optional[float]</code> <p>How long is a meter in the given dtype? For instance: with uint16, perhaps meter=1000 which would mean you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p> <p>See: rerun.log_annotation_context for information on how to map the class-ids to colors and labels.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image--supported-dtypes","title":"Supported dtypes","text":"<p>uint8, uint16</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the image in the space hierarchy.</p> required <code>image</code> <code>npt.ArrayLike</code> <p>A Tensor representing the segmentation image to log.</p> required <code>timeless</code> <code>bool</code> <p>If true, the image will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/lines/","title":"lines.py","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines","title":"<code>rerun.log.lines</code>","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines.log_path","title":"<code>def log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>       2------3     5\n      /        \\   /\n0----1          \\ /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the path in the space hierarchy</p> required <code>positions</code> <code>Optional[npt.NDArray[np.float32]]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the path will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>       2------3     5\n                   /\n0----1            /\n                 4\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the line segments in the space hierarchy</p> required <code>positions</code> <code>npt.NDArray[np.float32]</code> <p>A Nx3 array of points along the path.</p> required <code>stroke_width</code> <code>Optional[float]</code> <p>Width of the line.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the line segments will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/points/","title":"points.py","text":""},{"location":"package/rerun/log/points/#rerun.log.points","title":"<code>rerun.log.points</code>","text":""},{"location":"package/rerun/log/points/#rerun.log.points.log_point","title":"<code>def log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_point--supported-dtypes-for-color","title":"Supported dtypes for <code>color</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the point in the space hierarchy.</p> required <code>position</code> <code>Union[Sequence[float], npt.NDArray[np.float32], None]</code> <p>2x1 or 3x1 array.</p> required <code>radius</code> <code>Optional[float]</code> <p>Optional radius (make it a sphere).</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional color of the point.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show with the point.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the point. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_id</code> <code>Optional[int]</code> <p>Optional key point id for the point, identifying it within a class. If keypoint_id is passed but no class_id was specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the point will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points","title":"<code>def log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points--supported-dtypes-for-colors","title":"Supported dtypes for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the points in the space hierarchy.</p> required <code>positions</code> <code>Union[Sequence[Sequence[float]], Optional[npt.NDArray[np.float32]]]</code> <p>Nx2 or Nx3 array</p> required <code>identifiers</code> <code>Optional[Union[Sequence[int], npt.NDArray[Any]]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional colors of the points.</p> <code>None</code> <code>radii</code> <code>Optional[npt.ArrayLike]</code> <p>Optional radii (make it a sphere).</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-point text to show with the points</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the points. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>keypoint_ids</code> <code>OptionalKeyPointIds</code> <p>Optional key point ids for the points, identifying them within a class. If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0. This is useful to identify points within a single classification (which is identified with class_id). E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the points will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/rects/","title":"rects.py","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects","title":"<code>rerun.log.rects</code>","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects.RectFormat","title":"<code>class RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangle in the space hierarchy.</p> required <code>rect</code> <code>Optional[npt.ArrayLike]</code> <p>the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Optional text to show inside the rectangle.</p> <code>None</code> <code>class_id</code> <code>Optional[int]</code> <p>Optional class id for the rectangle. The class id provides color and label if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rect will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects--supported-dtypes-for-colors","title":"Supported <code>dtype</code>s for <code>colors</code>:","text":"<ul> <li>uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space.</li> <li>float32/float64: all color components should be in 0-1 linear space.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the rectangles in the space hierarchy.</p> required <code>rects</code> <code>Optional[npt.ArrayLike]</code> <p>Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</p> required <code>rect_format</code> <code>RectFormat</code> <p>how to interpret the <code>rect</code> argument</p> <code>RectFormat.XYWH</code> <code>identifiers</code> <code>Optional[Sequence[int]]</code> <p>Unique numeric id that shows up when you hover or select the point.</p> <code>None</code> <code>colors</code> <code>Optional[Union[Color, Colors]]</code> <p>Optional per-rectangle RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>labels</code> <code>Optional[Sequence[str]]</code> <p>Optional per-rectangle text to show inside the rectangle.</p> <code>None</code> <code>class_ids</code> <code>OptionalClassIds</code> <p>Optional class ids for the rectangles. The class id provides colors and labels if not specified explicitly. See rerun.log_annotation_context</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the rects will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar","title":"<code>rerun.log.scalar</code>","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar","title":"<code>def log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p> <p>Understanding the plot and attributes hierarchy</p> <p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy:</p> <ul> <li>Each space represents a single plot.</li> <li>Each entity path within a space that contains scalar data is a line within that plot.</li> <li>Each logged scalar is a point.</li> </ul> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to the scalar in the space hierarchy.</p> required <code>scalar</code> <code>float</code> <p>The scalar value to log.</p> required <code>label</code> <code>Optional[str]</code> <p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points. If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path. The plot itself is named after the space it's in.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB.</p> <p>If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate. If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p> <code>None</code> <code>radius</code> <code>Optional[float]</code> <p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p> <code>None</code> <code>scattered</code> <code>Optional[bool]</code> <p>Specifies whether the point should form a continuous line with its neighbors, or whether it should stand on its own, akin to a scatter plot. Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continuous representation as required.</p> <code>None</code>"},{"location":"package/rerun/log/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor","title":"<code>rerun.log.tensor</code>","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor.Tensor","title":"<code>Tensor = Union[npt.ArrayLike, TorchTensorLike]</code>  <code>module-attribute</code>","text":"<p>Type helper for a tensor-like object that can be logged to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.TorchTensorLike","title":"<code>class TorchTensorLike</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Describes what is need from a Torch Tensor to be loggable to Rerun.</p>"},{"location":"package/rerun/log/tensor/#rerun.log.tensor.log_tensor","title":"<code>def log_tensor(entity_path, tensor, names=None, meter=None, timeless=False)</code>","text":"<p>Log an arbitrary-dimensional tensor.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path to the tensor in the space hierarchy.</p> required <code>tensor</code> <code>npt.ArrayLike</code> <p>A Tensor objector.</p> required <code>names</code> <code>Optional[Iterable[str]]</code> <p>Optional names for each dimension of the tensor.</p> <code>None</code> <code>meter</code> <code>Optional[float]</code> <p>Optional scale of the tensor (e.g. meters per cell).</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the tensor will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/text/","title":"text.py","text":""},{"location":"package/rerun/log/text/#rerun.log.text","title":"<code>rerun.log.text</code>","text":""},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel","title":"<code>class LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.CRITICAL","title":"<code>CRITICAL: Final = 'CRITICAL'</code>  <code>class-attribute</code>","text":"<p>Designates catastrophic failures.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.ERROR","title":"<code>ERROR: Final = 'ERROR'</code>  <code>class-attribute</code>","text":"<p>Designates very serious errors.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.WARN","title":"<code>WARN: Final = 'WARN'</code>  <code>class-attribute</code>","text":"<p>Designates hazardous situations.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.INFO","title":"<code>INFO: Final = 'INFO'</code>  <code>class-attribute</code>","text":"<p>Designates useful information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.DEBUG","title":"<code>DEBUG: Final = 'DEBUG'</code>  <code>class-attribute</code>","text":"<p>Designates lower priority information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel.TRACE","title":"<code>TRACE: Final = 'TRACE'</code>  <code>class-attribute</code>","text":"<p>Designates very low priority, often extremely verbose, information.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler","title":"<code>class LoggingHandler(root_entity_path=None)</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler--mapping","title":"Mapping","text":"<ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.log_text_entry","title":"<code>def log_text_entry(entity_path, text, level=LogLevel.INFO, color=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The object path to log the text entry under.</p> required <code>text</code> <code>str</code> <p>The text to log.</p> required <code>level</code> <code>Optional[str]</code> <p>The level of the text entry (default: <code>LogLevel.INFO</code>). Note this can technically be an arbitrary string, but it's recommended to use one of the constants from LogLevel</p> <code>LogLevel.INFO</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>Optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>Whether the text entry should be timeless.</p> <code>False</code>"},{"location":"package/rerun/log/transform/","title":"transform.py","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform","title":"<code>rerun.log.transform</code>","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path in the space hierarchy where the view coordinate will be set.</p> required <code>xyz</code> <code>str</code> <p>Three-letter acronym for the view coordinate axes.</p> <code>''</code> <code>up</code> <code>str</code> <p>Which axis is up? One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> <code>''</code> <code>right_handed</code> <code>Optional[bool]</code> <p>If True, the coordinate system is right-handed. If False, it is left-handed.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>If true, the view coordinates will be timeless (default: False).</p> <code>False</code>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--parent-from-child","title":"Parent-from-child","text":"<p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p><code>point_parent = translation + quat * point_child * quat*</code></p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>Path of the child space in the space hierarchy.</p> required <code>parent_from_child</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>A tuple of <code>(translation_xyz, quat_xyzw)</code> mapping points in the child space to the parent space.</p> <code>None</code> <code>child_from_parent</code> <code>Optional[Tuple[npt.ArrayLike, npt.ArrayLike]]</code> <p>the inverse of <code>parent_from_child</code></p> <code>None</code> <code>xyz</code> <code>str</code> <p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling log_view_coordinates.</p> <code>''</code> <code>timeless</code> <code>bool</code> <p>If true, the transform will be timeless (default: False).</p> <code>False</code>"}]}